<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","audiolib.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::track::Track;\n\npub(crate) trait AudioLib {\n    fn play(\u0026self, track: \u0026Track) -\u003e Result\u003c(), Error\u003e;\n    fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn is_playing(\u0026self) -\u003e bool;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","error.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\n/// Media player errors.\n///\n/// Defines all runtime errors.\n#[derive(Debug, PartialEq)]\npub enum Error {\n    /// Audio library  error.\n    ///\n    /// Returned whenever there was an error raised by the underlying audio library.\n    AudioLibError(String),\n    /// IO error.\n    ///\n    /// Returned whenever there was a file access error.\n    IoError(String),\n}\n\nimpl From\u003cstd::io::Error\u003e for Error {\n    fn from(error: std::io::Error) -\u003e Self {\n        Error::IoError(format!(\"{}\", error))\n    }\n}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\nimpl std::error::Error for Error {}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let error = Error::AudioLibError(String::from(\"test\"));\n        let formatted_string = format!(\"{}\", error);\n        assert_eq!(\"AudioLibError(\\\"test\\\")\", formatted_string);\n    }\n\n    #[test]\n    fn test_from_io_error() {\n        let result = std::fs::File::open(\"non_existing_file\");\n        let io_error = result.unwrap_err();\n        let error = Error::from(io_error);\n        assert_eq!(\n            Error::IoError(String::from(\"No such file or directory (os error 2)\")),\n            error\n        );\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","lib.rs"],"content":"//! Crate for playing audio files.\n//!\n//! The [`MediaPlayer`](crate::MediaPlayer) can simply be\n//! [`open`](crate::open)ed but may result in an error.\n//!\n//! # Example\n//!\n//! ```rust\n//! use media_player::{open, MediaPlayer, Track};\n//!\n//! // get media_player trait object\n//! let mut media_player = open().unwrap();\n//!\n//! // create Track from String or \u0026str\n//! let track = Track::from(\"tests/rand1.wav\");\n//!\n//! // play the track\n//! media_player.play(\u0026track).unwrap();\n//!\n//! // ...\n//!\n//! // if you play a new track, the old one is stopped\n//! let track2 = Track::from(\"tests/rand2.wav\");\n//! media_player.play(\u0026track2).unwrap();\n//!\n//! // ...\n//!\n//! // you can also stop the playing of the track\n//! media_player.stop().unwrap();\n//! ```\n#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nmod audiolib;\nmod error;\nmod mediaplayer;\nmod track;\n\nmod rodiolib;\n\npub use error::Error;\npub use mediaplayer::MediaPlayer;\npub use track::Track;\n\n/// Opens the [`MediaPlayer`](crate::MediaPlayer), can result in an Error.\n///\n/// Returns an [`AudioLibError`](crate::Error::AudioLibError) if there was\n/// an error raised in the underlying audio library.\npub fn open() -\u003e Result\u003cimpl MediaPlayer, Error\u003e {\n    let audiolib = rodiolib::open()?;\n    mediaplayer::open(audiolib)\n}\n","traces":[{"line":50,"address":[4544272,4544939],"length":1,"stats":{"Line":1},"fn_name":"open"},{"line":51,"address":[4544738,4544282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4544600],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","mediaplayer.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::audiolib::AudioLib;\nuse crate::error::Error;\nuse crate::track::Track;\n/// The [`MediaPlayer`](crate::MediaPlayer) trait.\n///\n/// Enables playing tracks and stopping the playback.\n/// When a new track is played, the playback of the old one is stopped (if still playing).\npub trait MediaPlayer {\n    /// Plays the [`Track`].\n    ///\n    /// Results in an [`IoError`](crate::Error::IoError) if the file does not exist (or any other possible file access error).\n    /// Results in an [`AudioLibError`](crate::Error::AudioLibError) if there was an error raised by the underlying audio library.\n    fn play(\u0026mut self, track: \u0026Track) -\u003e Result\u003c(), Error\u003e;\n\n    /// Stops the playback.\n    ///\n    /// Results in an [`AudioLibError`](crate::Error::AudioLibError) if there was an error raised by the underlying audio library.\n    fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n}\n\nstruct MediaPlayerImplementation\u003cT: AudioLib\u003e {\n    last_track: Option\u003cTrack\u003e,\n    audio_lib: T,\n}\n\nimpl\u003cT: AudioLib\u003e MediaPlayer for MediaPlayerImplementation\u003cT\u003e {\n    fn play(\u0026mut self, track: \u0026Track) -\u003e Result\u003c(), Error\u003e {\n        if let Some(last_track) = \u0026self.last_track {\n            if last_track != track {\n                self.audio_lib.stop()?;\n                self.audio_lib.play(\u0026track)?;\n                self.last_track = Some(track.clone());\n            } else {\n                if !self.audio_lib.is_playing() {\n                    self.audio_lib.play(\u0026track)?;\n                }\n            }\n        } else {\n            self.audio_lib.play(\u0026track)?;\n            self.last_track = Some(track.clone());\n        }\n        Ok(())\n    }\n\n    fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.last_track = None;\n        self.audio_lib.stop()\n    }\n}\n\nimpl\u003cT: AudioLib\u003e MediaPlayerImplementation\u003cT\u003e {\n    fn from(audio_lib: T) -\u003e Result\u003cSelf, Error\u003e {\n        Ok(MediaPlayerImplementation {\n            last_track: None,\n            audio_lib: audio_lib,\n        })\n    }\n}\n\npub(crate) fn open\u003cT: AudioLib\u003e(audio_lib: T) -\u003e Result\u003cimpl MediaPlayer, Error\u003e {\n    MediaPlayerImplementation::from(audio_lib)\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    struct DummyAudioLib;\n    impl AudioLib for DummyAudioLib {\n        fn play(\u0026self, _track: \u0026Track) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn is_playing(\u0026self) -\u003e bool {\n            false\n        }\n    }\n\n    #[test]\n    fn test_play() {\n        let mut media_player = MediaPlayerImplementation::from(DummyAudioLib).unwrap();\n        let result = media_player.play(\u0026\"/path/to/track\".into());\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_new_song_interrupts_old() {\n        let mut media_player = MediaPlayerImplementation::from(DummyAudioLib).unwrap();\n        media_player.play(\u0026\"/path/to/track/1\".into()).unwrap();\n        media_player.play(\u0026\"song2\".into()).unwrap();\n        assert_eq!(media_player.last_track, Some(Track::from(\"song2\")));\n    }\n\n    #[test]\n    fn test_old_song_is_played_again() {\n        let mut media_player = MediaPlayerImplementation::from(DummyAudioLib).unwrap();\n        media_player\n            .play(\u0026String::from(\"/path/to/track/1\").into())\n            .unwrap();\n        media_player.play(\u0026\"/path/to/track/1\".into()).unwrap();\n        assert_eq!(\n            media_player.last_track,\n            Some(Track::from(\"/path/to/track/1\"))\n        );\n    }\n}\n","traces":[{"line":31,"address":[4599200,4600496],"length":1,"stats":{"Line":3},"fn_name":"play\u003cmedia_player::mediaplayer::tests::DummyAudioLib\u003e"},{"line":32,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":33,"address":[4251671,4252563,4252988],"length":1,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4599424,4599682,4599612],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[4252240,4252041,4252906],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[4599907,4599991,4599346],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4600247,4600177,4599276],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[4600598,4600418,4600224],"length":1,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4580288],"length":1,"stats":{"Line":1},"fn_name":"open\u003cmedia_player::rodiolib::RodioLib\u003e"},{"line":65,"address":[4580298],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","rodiolib","mod.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse rodio::{OutputStream, OutputStreamHandle, Sink};\n\nuse std::fs::File;\nuse std::io::BufReader;\n\nuse crate::audiolib::AudioLib;\nuse crate::error::Error;\nuse crate::track::Track;\n\nstruct RodioLib {\n    sink: Sink,\n    stream: OutputStream,\n    stream_handle: OutputStreamHandle,\n}\n\nfn create_new_triple() -\u003e Result\u003c(Sink, OutputStream, OutputStreamHandle), Error\u003e {\n    let (stream, stream_handle) = OutputStream::try_default().unwrap();\n    let sink = Sink::try_new(\u0026stream_handle)?;\n    Ok((sink, stream, stream_handle))\n}\n\nimpl RodioLib {\n    fn new() -\u003e Result\u003cSelf, Error\u003e {\n        let (sink, stream, stream_handle) = create_new_triple()?;\n\n        Ok(RodioLib {\n            sink: sink,\n            stream: stream,\n            stream_handle: stream_handle,\n        })\n    }\n}\n\nimpl AudioLib for RodioLib {\n    fn play(\u0026self, track: \u0026Track) -\u003e Result\u003c(), Error\u003e {\n        let file = File::open(track)?;\n        let source = rodio::Decoder::new(BufReader::new(file))?;\n        self.sink.append(source);\n        self.sink.play();\n        Ok(())\n    }\n    fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.sink.stop();\n        let (sink, stream, stream_handle) = create_new_triple()?;\n        self.sink = sink;\n        self.stream = stream;\n        self.stream_handle = stream_handle;\n        Ok(())\n    }\n    fn is_playing(\u0026self) -\u003e bool {\n        !self.sink.empty()\n    }\n}\n\npub(crate) fn open() -\u003e Result\u003cimpl AudioLib, Error\u003e {\n    RodioLib::new()\n}\n\nimpl From\u003crodio::PlayError\u003e for Error {\n    fn from(error: rodio::PlayError) -\u003e Self {\n        Error::AudioLibError(format!(\"{}\", error))\n    }\n}\n\nimpl From\u003crodio::StreamError\u003e for Error {\n    fn from(error: rodio::StreamError) -\u003e Self {\n        Error::AudioLibError(format!(\"{}\", error))\n    }\n}\n\nimpl From\u003crodio::DevicesError\u003e for Error {\n    fn from(error: rodio::DevicesError) -\u003e Self {\n        Error::AudioLibError(format!(\"{}\", error))\n    }\n}\n\nimpl From\u003crodio::decoder::DecoderError\u003e for Error {\n    fn from(error: rodio::decoder::DecoderError) -\u003e Self {\n        Error::AudioLibError(format!(\"{}\", error))\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use std::time::Duration;\n\n    use super::*;\n\n    #[test]\n    fn test_create_triple() {\n        let result = create_new_triple();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_is_playing() {\n        let mut rodio_lib = open().unwrap();\n        let is_playing = rodio_lib.is_playing();\n        assert_eq!(false, is_playing);\n\n        let track = Track::from(\"tests/rand1.wav\");\n        rodio_lib.play(\u0026track).unwrap();\n        assert_eq!(true, rodio_lib.is_playing());\n\n        rodio_lib.stop().unwrap();\n        assert_eq!(false, rodio_lib.is_playing());\n    }\n\n    #[test]\n    #[ignore = \"Test of correct usage of rodio\"]\n    fn test_is_playing_to_the_end() {\n        let mut rodio_lib = open().unwrap();\n        let is_playing = rodio_lib.is_playing();\n        assert_eq!(false, is_playing);\n\n        let track = Track::from(\"tests/rand1.wav\");\n        rodio_lib.play(\u0026track).unwrap();\n        assert_eq!(true, rodio_lib.is_playing());\n\n        for i in 0..32 {\n            std::thread::sleep(Duration::from_secs(1));\n            println!(\"Time elapsed: {} s\", i + 1);\n            assert_eq!(true, rodio_lib.is_playing());\n        }\n        std::thread::sleep(Duration::from_secs(3));\n        assert_eq!(false, rodio_lib.is_playing());\n    }\n\n    #[test]\n    fn test_from_play_error() {\n        let rodio_error = rodio::PlayError::NoDevice;\n        let error = Error::from(rodio_error);\n        assert_eq!(Error::AudioLibError(String::from(\"NoDevice\")), error);\n    }\n\n    #[test]\n    fn test_from_stream_error() {\n        let rodio_error = rodio::StreamError::NoDevice;\n        let error = Error::from(rodio_error);\n        assert_eq!(Error::AudioLibError(String::from(\"NoDevice\")), error);\n    }\n\n    #[test]\n    fn test_from_devices_error() {\n        extern crate cpal;\n\n        let rodio_error = rodio::DevicesError::BackendSpecific {\n            err: cpal::BackendSpecificError {\n                description: String::from(\"\"),\n            },\n        };\n        let error = Error::from(rodio_error);\n        assert_eq!(\n            Error::AudioLibError(String::from(\"A backend-specific error has occurred: \")),\n            error\n        );\n    }\n\n    #[test]\n    fn test_from_decoder_error() {\n        let rodio_error = rodio::decoder::DecoderError::UnrecognizedFormat;\n        let error = Error::from(rodio_error);\n        assert_eq!(\n            Error::AudioLibError(String::from(\"Unrecognized format\")),\n            error\n        );\n    }\n}\n","traces":[{"line":20,"address":[4585504,4586161],"length":1,"stats":{"Line":2},"fn_name":"create_new_triple"},{"line":21,"address":[4585514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4586024,4586176,4585660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4585807],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4586240],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":28,"address":[4586726,4586250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4586594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4586518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4586557],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4586912,4587554],"length":1,"stats":{"Line":2},"fn_name":"play"},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[4587364],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4587496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4587508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4588502,4587680],"length":1,"stats":{"Line":2},"fn_name":"stop"},{"line":47,"address":[4587698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4587748,4588288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4588522,4588209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[4588603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4589072],"length":1,"stats":{"Line":2},"fn_name":"open"},{"line":60,"address":[4589080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":34,"coverable":35},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","track.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse std::path::Path;\n\n/// The track (i.e. its path)\n///\n/// The [`Track`](crate::Track) is created from a [`String`](std::string::String) or a [`\u0026str`](std::str) and contains the path to the track.\n#[derive(Debug, PartialEq, Clone)]\npub struct Track(String);\n\nimpl From\u003cString\u003e for Track {\n    fn from(path: String) -\u003e Self {\n        Track(path)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for Track {\n    fn from(path: \u0026str) -\u003e Self {\n        Track(path.into())\n    }\n}\n\nimpl AsRef\u003cstr\u003e for Track {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        self.0.as_ref()\n    }\n}\n\nimpl AsRef\u003cPath\u003e for Track {\n    fn as_ref(\u0026self) -\u003e \u0026Path {\n        self.0.as_ref()\n    }\n}\n\nimpl std::fmt::Display for Track {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_as_ref() {\n        let track = Track::from(\"track\");\n        let as_ref: \u0026str = track.as_ref();\n        assert_eq!(\"track\", as_ref);\n    }\n\n    #[test]\n    fn test_display() {\n        let track = Track::from(\"track\");\n        let formatted_track = format!(\"{}\", track);\n        assert_eq!(\"track\".to_string(), formatted_track);\n    }\n}\n","traces":[{"line":14,"address":[11947312],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":15,"address":[7461095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4577760],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":21,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[7461232],"length":1,"stats":{"Line":1},"fn_name":"as_ref"},{"line":27,"address":[11947465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4577897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","tests","integration_tests.rs"],"content":"#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod media_player_integration_tests {\n    use media_player::{open, MediaPlayer, Track};\n    use std::thread::sleep;\n    use std::time::Duration;\n\n    #[test]\n    fn test_double_play() {\n        let mut media_player = open().unwrap();\n        let track = Track::from(\"tests/rand1.wav\");\n        media_player.play(\u0026track).unwrap();\n        assert!(true);\n\n        sleep(Duration::from_millis(200));\n\n        let track2 = Track::from(\"tests/rand2.wav\");\n        media_player.play(\u0026track2).unwrap();\n        assert!(true);\n        sleep(Duration::from_millis(200));\n\n        media_player.stop().unwrap();\n        assert!(true);\n    }\n\n    #[test]\n    #[ignore = \"Test of correct usage of rodio\"]\n    fn test_play_until_the_end() {\n        let mut media_player = open().unwrap();\n        let track = Track::from(\"tests/rand1.wav\");\n        media_player.play(\u0026track).unwrap();\n        for i in 0..33 {\n            std::thread::sleep(Duration::from_secs(1));\n            println!(\"Time elapsed: {} s\", i + 1);\n        }\n        assert!(true);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player_test","src","main.rs"],"content":"extern crate rodio;\nuse rodio::Decoder;\nuse rodio::OutputStream;\nuse rodio::OutputStreamHandle;\nuse rodio::Sink;\nuse rodio::Source;\nuse std::fs::File;\nuse std::io::BufReader;\nuse std::thread::sleep;\nuse std::time::Duration;\n\n#[cfg(not(tarpaulin_include))]\nfn do_play() {\n    let (stream, stream_handle) = rodio::OutputStream::try_default().unwrap();\n    //let sink = Sink::try_new(\u0026stream_handle).unwrap();\n    let file = File::open(\"sound.flac\").unwrap();\n    let source = rodio::Decoder::new(BufReader::new(file)).unwrap();\n    let sink = Sink::try_new(\u0026stream_handle).unwrap();\n    //let (sink, output_queue) = Sink::new_idle();\n    sink.set_volume(0.1);\n    //let sink = stream_handle.play_raw(source.convert_samples()).unwrap();\n    //let source = rodio::source::SineWave::new(440);\n    //sink.append(source);\n    sink.append(source);\n    let is_playing = !sink.empty();\n    println!(\"Still playing? {}\", is_playing);\n    println!(\"Is paused? {}\", sink.is_paused());\n    sink.play();\n    let mut counter = 0;\n    loop {\n        sleep(Duration::from_secs(2));\n        let is_playing = !sink.empty();\n        println!(\"Still playing? {}\", is_playing);\n        println!(\"Is paused? {}\", sink.is_paused());\n        if counter == 5 {\n            sink.stop();\n            let is_playing = !sink.empty();\n            println!(\"Still playing? {}\", is_playing);\n        }\n        if counter == 7 {\n            println!(\"Restart\");\n            let file2 = File::open(\"sound2.wav\").unwrap();\n            let source2 = rodio::Decoder::new(BufReader::new(file2)).unwrap();\n            sink.append(source2);\n            sink.play();\n        }\n        counter += 1;\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn play(path: \u0026str) -\u003e (Sink, OutputStream, OutputStreamHandle) {\n    let (stream, stream_handle) = rodio::OutputStream::try_default().unwrap();\n\n    let file = File::open(path).unwrap();\n    let source = rodio::Decoder::new(BufReader::new(file)).unwrap();\n\n    let sink = Sink::try_new(\u0026stream_handle).unwrap();\n    sink.set_volume(0.1);\n    sink.append(source);\n    sink.play();\n    (sink, stream, stream_handle)\n}\n\n#[cfg(not(tarpaulin_include))]\nfn do_play2() {\n    let (mut sink, mut stream, mut stream_handle) = play(\"sound.flac\");\n\n    let mut counter = 1;\n\n    loop {\n        let is_playing = !sink.empty();\n        println!(\"Still playing? {}\", is_playing);\n        if counter == 5 {\n            sink.stop();\n            println!(\"Stopped\");\n        }\n        if counter == 7 {\n            let (sink_new, stream_new, stream_handle_new) = play(\"sound2.wav\");\n            sink = sink_new;\n            stream = stream_new;\n            stream_handle = stream_handle_new;\n            println!(\"Started new sound\");\n        }\n        if counter == 25 {\n            println!(\"Should have stopped playing\");\n            println!(\"Still playing? {}\", is_playing);\n            break;\n        }\n        sleep(Duration::from_secs(2));\n        counter += 1;\n    }\n\n    println!(\"sound over\");\n}\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    do_play2();\n    //let (sink, stream, stream_handle) = play(\"sound.flac\");\n    // let path =\"sound.flac\";\n    // let (stream, stream_handle) = rodio::OutputStream::try_default().unwrap();\n\n    // let file = File::open(path).unwrap();\n    // let source = rodio::Decoder::new(BufReader::new(file)).unwrap();\n\n    // let sink = Sink::try_new(\u0026stream_handle).unwrap();\n    // sink.set_volume(0.1);\n    // sink.append(source);\n    //loop {}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","cli_app.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse clap::{App, Arg};\nuse std::num::ParseIntError;\n\n/// Name of the Vendor ID command line option.\npub const VENDOR_ID_ARGUMENT_NAME: \u0026str = \"Vendor ID\";\n/// Name of the Product ID command line option.\npub const PRODUCT_ID_ARGUMENT_NAME: \u0026str = \"Product ID\";\n/// Name of the Tracks File command line option.\npub const TRACKS_FILE_ARGUMENT_NAME: \u0026str = \"Tracks File\";\n/// Name of the Timeout command line option.\npub const TIMEOUT_ARGUMENT_NAME: \u0026str = \"Timeout\";\n/// Name of the Log Level command line option.\npub const LOG_LEVEL_ARGUMENT_NAME: \u0026str = \"Log Level\";\n/// Name of the Console Log command line flag.\npub const CONSOLE_LOG_ARGUMENT_NAME: \u0026str = \"Console Log\";\n\n/// Creates the [`clap::App`](https://docs.rs/clap/2.33.3/clap/struct.App.html) of the rfid_media_player application.\npub fn create_app\u003c'a, 'b\u003e() -\u003e App\u003c'a, 'b\u003e {\n    App::new(\"RFID Media Player\")\n        .version(\"1.0.0\")\n        .author(\"rusty-octopus \u003coctopus@posteo.net\u003e\")\n        .about(\"Reads RFID cards and plays the tracks that are associated to the RFID values of these cards.\")\n        .arg(\n            Arg::with_name(VENDOR_ID_ARGUMENT_NAME)\n                .short(\"v\")\n                .long(\"vendor_id\")\n                .value_name(\"VENDOR_ID\")\n                .help(\"The Vendor ID of the RFID card reader.\\\n                Must be a valid unsigned integer with at most 16 bits.\")\n                .required(true).validator(validate_id),\n        )\n        .arg(\n          Arg::with_name(PRODUCT_ID_ARGUMENT_NAME)\n              .short(\"p\")\n              .long(\"product_id\")\n              .value_name(\"PRODUCT_ID\")\n              .help(\"The Product ID of the RFID card reader.\\\n              Must be a valid unsigned integer with at most 16 bits.\")\n              .required(true).validator(validate_id),\n      )\n      .arg(\n        Arg::with_name(TRACKS_FILE_ARGUMENT_NAME)\n            .short(\"t\")\n            .long(\"tracks\")\n            .value_name(\"TRACKS_FILE\")\n            .help(\"The YAML file that contains the mapping from RFID value to the path of the associated track.\\\n            Mapping must be defined like:\\n\\\n            \\\"\u003crfid value as string incl. leading zeros\u003e: \u003cpath to track\u003e\\\"\")\n            .required(true),\n\n      )\n      .arg(\n        Arg::with_name(TIMEOUT_ARGUMENT_NAME)\n            .short(\"o\")\n            .long(\"timeout\")\n            .value_name(\"TIMEOUT\")\n            .help(\"The timeout in milliseconds (ms) for the USB device interrupt read.\\\n            This means the time the read of the USB device should be blocking.\\\n            Aborting the application (e.g. via Ctrl+c) may be delayed up by this timeout value.\\\n            Do not use this value unless you know what you are doing.\\\n            Must be a valid unsigned integer with at most 64 bits in decimal radix.\")\n            .required(false).validator(validate_timeout)\n            .default_value(\"1000\"))\n      .arg(\n        Arg::with_name(LOG_LEVEL_ARGUMENT_NAME)\n          .short(\"l\")\n          .long(\"log_level\")\n          .value_name(\"LOG_LEVEL\")\n          .help(\"The log level for the logger.\")\n          .possible_value(\"error\")\n          .possible_value(\"warn\")\n          .possible_value(\"info\")\n          .possible_value(\"debug\")\n          .possible_value(\"trace\")\n          .required(false).default_value(\"info\"))\n      .arg(Arg::with_name(CONSOLE_LOG_ARGUMENT_NAME).long(\"console_log\").short(\"c\").help(\"Log will be duplicated to the console (stdout).\"))\n}\n\n/// Tries to convert a [`String`](std::string::String) into an [`u16`](std::u16).\n///\n/// Returns a [`ParseIntError`](std::num::ParseIntError) whenever the given [`String`](std::string::String) contains an invalid decimal or hexidecimal digit.\npub fn convert_to_id(id_string: String) -\u003e Result\u003cu16, ParseIntError\u003e {\n    let mut conversion_result = u16::from_str_radix(\u0026id_string, 16);\n    if conversion_result.is_err() {\n        conversion_result = u16::from_str_radix(\u0026id_string, 10);\n    }\n    conversion_result\n}\n\nfn validate_id(id_string: String) -\u003e Result\u003c(), String\u003e {\n    let conversion_result = convert_to_id(id_string);\n\n    if conversion_result.is_err() {\n        return Err(\"ID value must be a valid hexadecimal or decimal unsigned integer number with at least 16 bits.\".to_string());\n    }\n    Ok(())\n}\n\nfn validate_timeout(timeout_string: String) -\u003e Result\u003c(), String\u003e {\n    let conversion_result = u64::from_str_radix(\u0026timeout_string, 10);\n\n    if conversion_result.is_err() {\n        return Err(\n            \"Timeout value must be a valid decimal unsigned integer with at least 16 bits.\"\n                .to_string(),\n        );\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_convert_to_id() {\n        let result = convert_to_id(\"FF\".to_string());\n        assert_eq!(Ok(255), result);\n        let result = convert_to_id(\"G\".to_string());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_validate_id() {\n        let result = validate_id(\"FF\".to_string());\n        assert_eq!(Ok(()), result);\n        let result = validate_id(\"G\".to_string());\n        assert_eq!(Err(\"ID value must be a valid hexadecimal or decimal unsigned integer number with at least 16 bits.\".to_string()), result);\n    }\n\n    #[test]\n    fn test_validate_timeout() {\n        let result = validate_timeout(\"1000\".to_string());\n        assert_eq!(Ok(()), result);\n        let result = validate_timeout(\"G\".to_string());\n        assert_eq!(\n            Err(\n                \"Timeout value must be a valid decimal unsigned integer with at least 16 bits.\"\n                    .to_string()\n            ),\n            result\n        );\n    }\n\n    #[test]\n    fn test_create_app() {\n        let app = create_app();\n        let matches = app.get_matches_from(vec![\n            \"rfid_media_player\",\n            \"--vendor_id\",\n            \"1\",\n            \"--product_id\",\n            \"2\",\n            \"--tracks\",\n            \"path/to/tracks\",\n        ]);\n        assert_eq!(Some(\"1\"), matches.value_of(VENDOR_ID_ARGUMENT_NAME));\n        assert_eq!(Some(\"2\"), matches.value_of(PRODUCT_ID_ARGUMENT_NAME));\n        assert_eq!(\n            Some(\"path/to/tracks\"),\n            matches.value_of(TRACKS_FILE_ARGUMENT_NAME)\n        );\n    }\n}\n","traces":[{"line":22,"address":[4373384,4371280],"length":1,"stats":{"Line":1},"fn_name":"create_app"},{"line":28,"address":[9170577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[9170882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[9171187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[9171465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[9172586,9171790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[9171806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[9172296,9172558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4373186,4373399,4373363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[4373903,4373696],"length":1,"stats":{"Line":1},"fn_name":"convert_to_id"},{"line":87,"address":[4373705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4373773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4373801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4373936],"length":1,"stats":{"Line":1},"fn_name":"validate_id"},{"line":95,"address":[4373943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4374004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[9173187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[9173171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4374367,4374112],"length":1,"stats":{"Line":1},"fn_name":"validate_timeout"},{"line":104,"address":[4374127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4374231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4374301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4374277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4374257],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","error.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse media_player;\nuse rfid_reader;\nuse track_store;\n\n/// RFID Media Player Errors\n///\n/// Defines all runtime errors.\n#[derive(Debug, PartialEq)]\npub enum Error {\n    /// Media player error.\n    ///\n    /// Returned whenever an error with the media player occurred.\n    MediaPlayerError(String),\n    /// RFID reader error.\n    ///\n    /// Returned whenever an error with the RFID reader occurred.\n    RfidReaderError(String),\n    /// Track store error.\n    ///\n    /// Returned whenever an error with the track store occurred.\n    TrackStoreError(String),\n}\n\nmacro_rules! implement_from_error_trait {\n    ($error_type:tt, $other_error_type:ty, $error_variant:ident) =\u003e {\n        impl From\u003c$other_error_type\u003e for $error_type {\n            fn from(error: $other_error_type) -\u003e Self {\n                $error_type::$error_variant(format!(\"{}\", error))\n            }\n        }\n    };\n}\n\nimplement_from_error_trait!(Error, media_player::Error, MediaPlayerError);\nimplement_from_error_trait!(Error, rfid_reader::Error, RfidReaderError);\nimplement_from_error_trait!(Error, track_store::Error, TrackStoreError);\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\nimpl std::error::Error for Error {}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_from_media_player_error() {\n        let media_player_error = media_player::Error::IoError(\"Test\".to_string());\n        let error = Error::from(media_player_error);\n        assert_eq!(\n            Error::MediaPlayerError(\"IoError(\\\"Test\\\")\".to_string()),\n            error\n        );\n    }\n\n    #[test]\n    fn test_from_rfid_reader_error() {\n        let other_error = rfid_reader::Error::Timeout;\n        let error = Error::from(other_error);\n        assert_eq!(Error::RfidReaderError(\"Timeout\".to_string()), error);\n    }\n\n    #[test]\n    fn test_from_track_store_error() {\n        let other_error = track_store::Error::LoadError(\"Test\".to_string());\n        let error = Error::from(other_error);\n        assert_eq!(\n            Error::TrackStoreError(\"LoadError(\\\"Test\\\")\".to_string()),\n            error\n        );\n    }\n\n    #[test]\n    fn test_display() {\n        let other_error = rfid_reader::Error::Timeout;\n        let error = Error::from(other_error);\n        let formatted_error = format!(\"{:}\", error);\n        assert_eq!(\"RfidReaderError(\\\"Timeout\\\")\", formatted_error);\n    }\n}\n","traces":[{"line":31,"address":[4275904,4275296,4275568,4275600,4275872,4276176],"length":1,"stats":{"Line":4},"fn_name":"from"},{"line":32,"address":[4275914,4275610,4275306],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","lib.rs"],"content":"//! The library of the rfid_media_player application.\n//!\n//! The [`RfidMediaPlayer`](crate::RfidMediaPlayer) can be [`open`](crate::open)ed in order to run it in the `main.rs`.\n//! It also helps creating an app with [crate::create_app](crate::create_app) to be used for the command line application.\n//! Finally it defines [`Error`](crate::Error)s that can happen during open or running the application.\n//!\n//! This library is used internally by the rfid_media_player application.\n//! It is implemented in order to test most of the logic of the main application.\n//!\n//! Example usage can be found in `main.rs`.\n#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse media_player;\nuse rfid_reader::{ProductId, VendorId};\nuse track_store;\n\nuse std::time::Duration;\n\nuse log::error;\n\nmod cli_app;\nmod error;\nmod rfidmediaplayer;\n\npub use cli_app::{\n    convert_to_id, create_app, CONSOLE_LOG_ARGUMENT_NAME, LOG_LEVEL_ARGUMENT_NAME,\n    PRODUCT_ID_ARGUMENT_NAME, TIMEOUT_ARGUMENT_NAME, TRACKS_FILE_ARGUMENT_NAME,\n    VENDOR_ID_ARGUMENT_NAME,\n};\npub use error::Error;\npub use rfidmediaplayer::RfidMediaPlayer;\n\n/// Tries to open the [`RfidMediaPlayer`](crate::RfidMediaPlayer).\n///\n/// Returns an [`RfidMediaPlayer`](crate::RfidMediaPlayer) trait object.\n///\n/// Returns an [`Error`](crate::Error) whenever there is a problem with the rfid_reader, track_store or media_player.\npub fn open(\n    vendor_id: VendorId,\n    product_id: ProductId,\n    timeout: Duration,\n    yaml_string: \u0026str,\n) -\u003e Result\u003cimpl RfidMediaPlayer, crate::Error\u003e {\n    let mut result = Err(Error::TrackStoreError(\n        \"Track store not loaded yet\".to_string(),\n    ));\n    let result_track_store = track_store::load(yaml_string);\n    if let Ok(track_store) = result_track_store {\n        let result_rfid_reader = rfid_reader::open(vendor_id, product_id, timeout);\n        if let Ok(rfid_reader) = result_rfid_reader {\n            let result_media_player = media_player::open();\n            if let Ok(media_player) = result_media_player {\n                result = Ok(rfidmediaplayer::open(\n                    media_player,\n                    rfid_reader,\n                    track_store,\n                ));\n            } else if let Err(media_player_error) = result_media_player {\n                error!(\n                    \"Opening media player resulted in error: {}\",\n                    media_player_error\n                );\n                result = Err(crate::Error::from(media_player_error))\n            }\n        } else if let Err(rfid_reader_error) = result_rfid_reader {\n            error!(\n                \"Opening rfid reader resulted in error: {}\",\n                rfid_reader_error\n            );\n            result = Err(crate::Error::from(rfid_reader_error))\n        }\n    } else if let Err(result_track_store_error) = result_track_store {\n        error!(\n            \"Loading track store resulted in error: {}\",\n            result_track_store_error\n        );\n        result = Err(crate::Error::from(result_track_store_error))\n    }\n\n    result\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_invalid_yaml() {\n        let result = open(\n            VendorId::from(1),\n            ProductId::from(1),\n            Duration::from_millis(1000),\n            \"test\",\n        );\n        if let Err(error) = result {\n            assert_eq!(Error::TrackStoreError(\"LoadError(\\\"invalid type: string \\\\\\\"test\\\\\\\", expected a map at line 1 column 1\\\")\".to_string()), error);\n        } else {\n            assert!(false);\n        }\n    }\n\n    #[test]\n    fn test_wrong_device() {\n        let result = open(\n            VendorId::from(1),\n            ProductId::from(1),\n            Duration::from_millis(1000),\n            \"1234: path\",\n        );\n        if let Err(error) = result {\n            assert_eq!(\n                Error::RfidReaderError(\"DeviceNotFound(VendorId(1), ProductId(1))\".to_string()),\n                error\n            );\n        } else {\n            assert!(false);\n        }\n    }\n}\n","traces":[{"line":40,"address":[9173536,9176553],"length":1,"stats":{"Line":1},"fn_name":"open"},{"line":46,"address":[9173798,9173610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[9173706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[9173894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[9175906,9173945,9173976],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[9174048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[9175332,9174171,9174140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4280363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4280382,4280429,4282709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4280744,4282624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4280514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4280560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4280648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4280409,4282807,4280819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4281005,4280872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4281279,4282714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4281404,4283431,4282809,4280247,4281417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4281470,4281591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[4281841,4282925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4281966,4282588,4283018,4281979,4283233,4280052,4283466],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[4282032,4282153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4283140,4282403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[4282528],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":23},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","main.rs"],"content":"use rfid_media_player::{\n    convert_to_id, create_app, open, RfidMediaPlayer, CONSOLE_LOG_ARGUMENT_NAME,\n    LOG_LEVEL_ARGUMENT_NAME, PRODUCT_ID_ARGUMENT_NAME, TIMEOUT_ARGUMENT_NAME,\n    TRACKS_FILE_ARGUMENT_NAME, VENDOR_ID_ARGUMENT_NAME,\n};\n\nuse rfid_reader::{ProductId, VendorId};\n\nuse flexi_logger::{Duplicate, LogTarget, Logger};\nuse log::info;\n\nuse signal_hook::consts::TERM_SIGNALS;\nuse signal_hook::iterator::Signals;\n\nuse std::sync::Arc;\nuse std::thread;\nuse std::{\n    sync::atomic::{AtomicBool, Ordering},\n    time::Duration,\n};\n\n#[cfg(not(tarpaulin_include))]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let matches = create_app().get_matches();\n\n    // default is set, therefore unwrapping is safe.\n    let log_spec = matches.value_of(LOG_LEVEL_ARGUMENT_NAME).unwrap();\n\n    let mut logger = Logger::with_str(log_spec).log_target(LogTarget::File);\n\n    let stdout = matches.is_present(CONSOLE_LOG_ARGUMENT_NAME);\n    if stdout {\n        logger = logger.duplicate_to_stdout(Duplicate::All);\n    }\n    logger.start()?;\n\n    info!(\"Started rfid_media_player\");\n\n    let vendor_id = VendorId::from(convert_to_id(\n        matches\n            .value_of(VENDOR_ID_ARGUMENT_NAME)\n            .unwrap()\n            .to_string(),\n    )?);\n    let product_id = ProductId::from(convert_to_id(\n        matches\n            .value_of(PRODUCT_ID_ARGUMENT_NAME)\n            .unwrap()\n            .to_string(),\n    )?);\n\n    let timeout = Duration::from_millis(u64::from_str_radix(\n        matches.value_of(TIMEOUT_ARGUMENT_NAME).unwrap(),\n        10,\n    )?);\n\n    let yaml_string =\n        std::fs::read_to_string(matches.value_of(TRACKS_FILE_ARGUMENT_NAME).unwrap())?;\n\n    let mut rfid_media_player = open(vendor_id, product_id, timeout, \u0026yaml_string)?;\n\n    info!(\"Application opened successfully\");\n\n    // Shared atomic bool to signal that the program is aborted\n    let running = Arc::new(AtomicBool::new(true));\n    let r = running.clone();\n\n    // all terminating signals\n    let mut signals = Signals::new(TERM_SIGNALS)?;\n\n    // spawn a thread to react to all terminating signals\n    thread::spawn(move || {\n        for sig in signals.forever() {\n            info!(\"Received signal {:?}\", sig);\n            r.store(false, Ordering::SeqCst);\n        }\n    });\n\n    while running.load(Ordering::SeqCst) {\n        rfid_media_player.run()?;\n    }\n    info!(\"Shutting down ...\");\n    rfid_media_player.shutdown()?;\n    info!(\"Shutting complete.\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","rfidmediaplayer.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\n\nuse log::{debug, error, info, warn};\n\nuse media_player::MediaPlayer;\nuse rfid_reader::RfidReader;\nuse track_store::TrackStore;\n\n/// The `RfidMediaPlayer` trait.\npub trait RfidMediaPlayer {\n    /// `run`s the `RfidMediaPlayer`.\n    ///\n    /// Returns either a success or an [`Error`](crate::Error).\n    /// Implementors must implement run non-blocking in order to allow the callee\n    /// to stop the application on terminated signals etc.\n    fn run(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    /// `shutdown`s the `RfidMediaPlayer`.\n    ///\n    /// Returns either a success or an [`Error`](crate::Error).\n    /// Must be called before the application is stopped.\n    fn shutdown(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n}\n\nstruct RfidMediaPlayerImplementation\u003cM, R, T\u003e\nwhere\n    M: MediaPlayer,\n    R: RfidReader,\n    T: TrackStore,\n{\n    media_player: M,\n    rfid_reader: R,\n    track_store: T,\n}\n\n/// Opens the `RfidMediaPlayer`.\npub(crate) fn open\u003cM, R, T\u003e(media_player: M, rfid_reader: R, track_store: T) -\u003e impl RfidMediaPlayer\nwhere\n    M: MediaPlayer,\n    R: RfidReader,\n    T: TrackStore,\n{\n    RfidMediaPlayerImplementation::open(media_player, rfid_reader, track_store)\n}\n\nimpl\u003cM, R, T\u003e RfidMediaPlayer for RfidMediaPlayerImplementation\u003cM, R, T\u003e\nwhere\n    M: MediaPlayer,\n    R: RfidReader,\n    T: TrackStore,\n{\n    fn run(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let mut result = Ok(());\n        let read_result = self.rfid_reader.read();\n        match read_result {\n            Ok(rfid_value) =\u003e {\n                info!(\"Received RFID value: {}\", rfid_value);\n                let option_track_path = get_track(\u0026self.track_store, rfid_value);\n                if let Some(track_path) = option_track_path {\n                    result = play_track(\u0026mut self.media_player, track_path);\n                }\n            }\n            Err(error) =\u003e match error {\n                rfid_reader::Error::Timeout =\u003e result = Ok(()),\n                _ =\u003e {\n                    error!(\"Reading RFID resolved in error: {}\", error);\n                    result = Err(Error::from(error));\n                }\n            },\n        }\n        result\n    }\n\n    fn shutdown(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let mut result = Ok(());\n        let rfid_reader_deinit_result = self.rfid_reader.deinitialize();\n        if let Err(error) = rfid_reader_deinit_result {\n            error!(\n                \"RFID reader could not be deinitialized without error: {}\",\n                error\n            );\n            result = Err(Error::from(error))\n        }\n        let media_player_stop_result = self.media_player.stop();\n        if let Err(error) = media_player_stop_result {\n            error!(\"Stopping media player resulted in error: {}\", error);\n            result = Err(Error::from(error))\n        }\n        result\n    }\n}\n\nimpl\u003cM, R, T\u003e RfidMediaPlayerImplementation\u003cM, R, T\u003e\nwhere\n    M: MediaPlayer,\n    R: RfidReader,\n    T: TrackStore,\n{\n    fn open(media_player: M, rfid_reader: R, track_store: T) -\u003e Self {\n        RfidMediaPlayerImplementation {\n            media_player: media_player,\n            rfid_reader: rfid_reader,\n            track_store: track_store,\n        }\n    }\n}\n\nfn get_track\u003c'a\u003e(\n    track_store: \u0026'a impl TrackStore,\n    rfid_value: String,\n) -\u003e Option\u003c\u0026'a track_store::TrackPath\u003e {\n    debug!(\"Get track for rfid {}\", rfid_value);\n    let id = track_store::Id::from(rfid_value);\n    debug!(\"Converted to id {}\", id);\n    let option = track_store.get_path(\u0026id);\n    debug!(\"Optional path to id {:?}\", option);\n    match option {\n        Some(track_path) =\u003e {\n            info!(\"Found track {} for RFID {}.\", track_path, id);\n            Some(track_path)\n        }\n        None =\u003e {\n            warn!(\"found no track for RFID {}.\", id);\n            None\n        }\n    }\n}\n\nfn play_track(\n    media_player: \u0026mut impl MediaPlayer,\n    track_path: \u0026track_store::TrackPath,\n) -\u003e Result\u003c(), Error\u003e {\n    let track: media_player::Track = media_player::Track::from(track_path.as_ref());\n    let play_result = media_player.play(\u0026track);\n    match play_result {\n        Ok(()) =\u003e {\n            info!(\"Start playing track {}\", track);\n            Ok(())\n        }\n        Err(error) =\u003e {\n            error!(\n                \"Track {} could not be played, received error: {}\",\n                track, error\n            );\n            Err(Error::from(error))\n        }\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    struct OkMediaPlayer;\n    impl MediaPlayer for OkMediaPlayer {\n        fn play(\u0026mut self, _track: \u0026media_player::Track) -\u003e Result\u003c(), media_player::Error\u003e {\n            Ok(())\n        }\n        fn stop(\u0026mut self) -\u003e Result\u003c(), media_player::Error\u003e {\n            Ok(())\n        }\n    }\n\n    struct ErrMediaPlayer;\n    impl MediaPlayer for ErrMediaPlayer {\n        fn play(\u0026mut self, _track: \u0026media_player::Track) -\u003e Result\u003c(), media_player::Error\u003e {\n            Err(media_player::Error::AudioLibError(\"play\".to_string()))\n        }\n        fn stop(\u0026mut self) -\u003e Result\u003c(), media_player::Error\u003e {\n            Err(media_player::Error::AudioLibError(\"stop\".to_string()))\n        }\n    }\n\n    struct SomeTrackStore(track_store::TrackPath);\n    impl TrackStore for SomeTrackStore {\n        fn get_path(\u0026self, _id: \u0026track_store::Id) -\u003e Option\u003c\u0026track_store::TrackPath\u003e {\n            Some(\u0026self.0)\n        }\n    }\n\n    struct NoneTrackStore;\n    impl TrackStore for NoneTrackStore {\n        fn get_path(\u0026self, _id: \u0026track_store::Id) -\u003e Option\u003c\u0026track_store::TrackPath\u003e {\n            None\n        }\n    }\n\n    #[derive(Debug)]\n    struct OkRfidReader;\n    impl RfidReader for OkRfidReader {\n        fn read(\u0026self) -\u003e Result\u003cString, rfid_reader::Error\u003e {\n            Ok(\"1234\".to_string())\n        }\n        fn deinitialize(\u0026mut self) -\u003e Result\u003c(), rfid_reader::Error\u003e {\n            Ok(())\n        }\n    }\n\n    #[derive(Debug)]\n    struct ErrRfidReader;\n    impl RfidReader for ErrRfidReader {\n        fn read(\u0026self) -\u003e Result\u003cString, rfid_reader::Error\u003e {\n            Err(rfid_reader::Error::OtherUsbError(\"read\".to_string()))\n        }\n        fn deinitialize(\u0026mut self) -\u003e Result\u003c(), rfid_reader::Error\u003e {\n            Err(rfid_reader::Error::OtherUsbError(\n                \"deinitialize\".to_string(),\n            ))\n        }\n    }\n\n    #[derive(Debug)]\n    struct TimeoutRfidReader;\n    impl RfidReader for TimeoutRfidReader {\n        fn read(\u0026self) -\u003e Result\u003cString, rfid_reader::Error\u003e {\n            Err(rfid_reader::Error::Timeout)\n        }\n        fn deinitialize(\u0026mut self) -\u003e Result\u003c(), rfid_reader::Error\u003e {\n            Ok(())\n        }\n    }\n\n    #[test]\n    fn test_play_track() {\n        let mut ok = OkMediaPlayer;\n        let result = play_track(\u0026mut ok, \u0026track_store::TrackPath::from(\"\"));\n        assert_eq!(Ok(()), result);\n\n        let mut err = ErrMediaPlayer;\n        let result = play_track(\u0026mut err, \u0026track_store::TrackPath::from(\"\"));\n        assert_eq!(\n            Err(Error::MediaPlayerError(\n                \"AudioLibError(\\\"play\\\")\".to_string()\n            )),\n            result\n        );\n    }\n    #[test]\n    fn test_get_track() {\n        let some = SomeTrackStore(track_store::TrackPath::from(\"path\"));\n        let option = get_track(\u0026some, \"\".to_string());\n        assert_eq!(Some(\u0026track_store::TrackPath::from(\"path\")), option);\n\n        let none = NoneTrackStore;\n        let option = get_track(\u0026none, \"\".to_string());\n        assert_eq!(None, option);\n    }\n\n    #[test]\n    fn test_ok_run_and_shutdown() {\n        let mut rfid_media_player = open(\n            OkMediaPlayer,\n            OkRfidReader,\n            SomeTrackStore(track_store::TrackPath::from(\"path\")),\n        );\n\n        let result = rfid_media_player.run();\n\n        assert_eq!(Ok(()), result);\n\n        let result = rfid_media_player.shutdown();\n\n        assert_eq!(Ok(()), result);\n    }\n\n    #[test]\n    fn test_err_run_and_shutdown() {\n        let mut rfid_media_player = open(\n            OkMediaPlayer,\n            ErrRfidReader,\n            SomeTrackStore(track_store::TrackPath::from(\"path\")),\n        );\n\n        let result = rfid_media_player.run();\n\n        assert_eq!(\n            Err(Error::RfidReaderError(\n                \"OtherUsbError(\\\"read\\\")\".to_string()\n            )),\n            result\n        );\n\n        let result = rfid_media_player.shutdown();\n\n        assert_eq!(\n            Err(Error::RfidReaderError(\n                \"OtherUsbError(\\\"deinitialize\\\")\".to_string()\n            )),\n            result\n        );\n    }\n\n    #[test]\n    fn test_err_media_player_shutdown() {\n        let mut rfid_media_player = open(\n            ErrMediaPlayer,\n            OkRfidReader,\n            SomeTrackStore(track_store::TrackPath::from(\"path\")),\n        );\n\n        let result = rfid_media_player.shutdown();\n\n        assert_eq!(\n            Err(Error::MediaPlayerError(\n                \"AudioLibError(\\\"stop\\\")\".to_string()\n            )),\n            result\n        );\n    }\n\n    #[test]\n    fn test_timeout_run() {\n        let mut rfid_media_player = open(\n            OkMediaPlayer,\n            TimeoutRfidReader,\n            SomeTrackStore(track_store::TrackPath::from(\"path\")),\n        );\n\n        let result = rfid_media_player.run();\n\n        assert_eq!(Ok(()), result);\n    }\n}\n","traces":[{"line":40,"address":[4286016,4285776,4285648,4285952,4285712],"length":1,"stats":{"Line":4},"fn_name":"open\u003crfid_media_player::rfidmediaplayer::tests::OkMediaPlayer,rfid_media_player::rfidmediaplayer::tests::OkRfidReader,rfid_media_player::rfidmediaplayer::tests::SomeTrackStore\u003e"},{"line":46,"address":[4285655,4285959,4285719,4285786,4286023],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[4291585,4290208,4289521,4287457,4286080,4288144],"length":1,"stats":{"Line":3},"fn_name":"run\u003crfid_media_player::rfidmediaplayer::tests::OkMediaPlayer,rfid_media_player::rfidmediaplayer::tests::TimeoutRfidReader,rfid_media_player::rfidmediaplayer::tests::SomeTrackStore\u003e"},{"line":56,"address":[4290226,4286098,4288162],"length":1,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[4288217,4286153,4290281],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[4290416,4291012,4286884,4288352,4286288,4288948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4290304,4288240,4286176,4286290,4288354,4290418],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[4288515,4290579,4286330,4286451,4290458,4288394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4286705,4288769,4290833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4287603,4290918,4289667,4291731,4286790,4288854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4291168,4286889,4287040,4291085,4291017,4289021,4289104,4286957,4288953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[4291872,4287744,4289808,4287288,4289352,4291416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4287423,4289487,4291551],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[4292272,4293679,4295839,4296592,4294432,4297999],"length":1,"stats":{"Line":3},"fn_name":"shutdown\u003crfid_media_player::rfidmediaplayer::tests::ErrMediaPlayer,rfid_media_player::rfidmediaplayer::tests::OkRfidReader,rfid_media_player::rfidmediaplayer::tests::SomeTrackStore\u003e"},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[4301663,4304127,4301744,4299280],"length":1,"stats":{"Line":2},"fn_name":"get_track\u003crfid_media_player::rfidmediaplayer::tests::SomeTrackStore\u003e"},{"line":115,"address":[4301930,4299295,4301759,4299466],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[4302214,4299750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[4299949,4299816,4302413,4302280],"length":1,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[4300245,4302709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[4302740,4300276,4302873,4300409],"length":1,"stats":{"Line":4},"fn_name":null},{"line":120,"address":[4300755,4303732,4301268,4303219],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4300689,4303153,4303221,4300757],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[4303237,4300894,4303358,4300773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[4301252,4303716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[4301273,4303178,4303820,4300714,4303737,4301356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[4301600,4304064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[4305584,4306841,4304208,4305465],"length":1,"stats":{"Line":2},"fn_name":"play_track\u003crfid_media_player::rfidmediaplayer::tests::ErrMediaPlayer\u003e"},{"line":136,"address":[4304234,4305610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[4304345,4305721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[4304460,4304860,4305836,4306236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[4304352,4305728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[4304592,4305838,4304462,4305968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[4304853,4306229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[4304376,4305752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[4304865,4305792,4306241,4306324,4304948,4304416],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[4305307,4306683],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":50,"coverable":52},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","examples","print_value.rs"],"content":"use rfid_reader::{open, Error, ProductId, RfidReader, VendorId};\nuse std::time::Duration;\n\nfn main() {\n    let vendor_id = VendorId::from(0x16c0);\n    let product_if = ProductId::from(0x27db);\n    let reader = open(vendor_id, product_if, Duration::from_secs(2));\n\n    if reader.is_ok() {\n        let mut reader = reader.unwrap();\n        let mut counter = 0;\n        while counter \u003c 5 {\n            counter += 1;\n            let read_result = reader.read();\n            match read_result {\n                Ok(value) =\u003e println!(\"Value: {}\", value),\n                Err(error) =\u003e println!(\"Read Error: {}\", error),\n            }\n        }\n        reader.deinitialize();\n    } else {\n        println!(\n            \"Reader could not be opened. Error: {:?}\",\n            reader.unwrap_err()\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","error.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::id::{ProductId, VendorId};\n/// RFID Reader errors.\n///\n/// Defines all runtime errors.\n#[derive(Debug, PartialEq)]\npub enum Error {\n    /// Device Not Found.\n    ///\n    /// Returned whenever the device defined by [VendorId](crate::VendorId) and [ProductId](crate::ProductId).\n    DeviceNotFound(VendorId, ProductId),\n    /// Timeout error.\n    ///\n    /// The read returned a timeout. Mostly used internally.\n    Timeout,\n    /// Access.\n    ///\n    /// Access to Device denied. This usually happens when the user rights are not sufficient.\n    /// Try using the RFID reader with more privileges.\n    Access,\n    /// Readable Endpoint Not Found.\n    ///\n    /// Returned whenever no readable endpoint could be found for the device defined by [VendorId](crate::VendorId) and [ProductId](crate::ProductId).\n    ReadableEndPointNotFound(VendorId, ProductId),\n    /// Invalid Data.\n    ///\n    /// Returned whenever invalid (or unexpected) data is received.\n    InvalidData(u8),\n    /// Too Few Received Data.\n    ///\n    /// Returned whenever too few bytes were received.\n    TooFewReceivedData(usize),\n    /// Key Not Existing.\n    ///\n    /// Returned whenever a byte value cannot be mapped to a key.\n    KeyNotExisting(u8),\n    /// Other Usb Error.\n    ///\n    /// Returned whenever an other error from the used USB library\n    /// that is of minor importance for the RFID reader is returned.\n    OtherUsbError(String),\n}\n\nimpl std::error::Error for Error {}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let error = Error::Timeout;\n        assert_eq!(\"Timeout\", format!(\"{}\", error));\n    }\n}\n","traces":[{"line":50,"address":[4261936],"length":1,"stats":{"Line":3},"fn_name":"fmt"},{"line":51,"address":[4261953],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","humbleusbdevice.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\n\npub trait HumbleUsbDevice {\n    fn has_attached_kernel_driver(\u0026self) -\u003e Result\u003cbool, Error\u003e;\n    fn detach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn attach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn read(\u0026self, buffer: \u0026mut [u8]) -\u003e Result\u003c(), Error\u003e;\n    fn claim_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn release_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn set_active_configuration(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn set_alternate_setting(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn initialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if self.has_attached_kernel_driver()? {\n            self.detach_kernel_driver()?;\n            self.set_active_configuration()?;\n            self.claim_interface()?;\n            self.set_alternate_setting()?;\n        }\n        Ok(())\n    }\n    fn set_deinitialized(\u0026mut self);\n    fn deinitialized(\u0026self) -\u003e bool;\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if !self.deinitialized() {\n            self.set_deinitialized();\n            if self.has_attached_kernel_driver()? {\n                self.attach_kernel_driver()?;\n                self.release_interface()?;\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":16,"address":[4266640],"length":1,"stats":{"Line":2},"fn_name":"initialize\u003crfid_reader::rusb::rusbhumbleusbdevice::RusbHumbleUsbDevice\u003crusb::context::Context\u003e\u003e"},{"line":17,"address":[4266658,4266896,4267686],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4276149,4276234,4277397,4277482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4267160,4266963,4267227],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[7334430,7334630,7334699],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[4267691,4267642,4267445],"length":1,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[4277115,4278363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4267888],"length":1,"stats":{"Line":1},"fn_name":"deinitialize\u003crfid_reader::rusb::rusbhumbleusbdevice::RusbHumbleUsbDevice\u003crusb::context::Context\u003e\u003e"},{"line":28,"address":[4267911,4268667],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[4267953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[4268188,4268273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4268250,4268447,4268496],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[4268674],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","id.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse std::fmt;\n#[derive(Debug, PartialEq, Clone, Copy)]\n/// Describes a Vendor Id of a USB device.\npub struct VendorId(u16);\n#[derive(Debug, PartialEq, Clone, Copy)]\n/// Describes a Product Id of a USB device.\npub struct ProductId(u16);\n\nmacro_rules! implement_from_trait {\n    ($id_type:tt) =\u003e {\n        impl From\u003cu16\u003e for $id_type {\n            fn from(id: u16) -\u003e Self {\n                $id_type(id)\n            }\n        }\n    };\n}\n\nmacro_rules! implement_into_trait {\n    ($id_type:tt) =\u003e {\n        impl Into\u003cu16\u003e for $id_type {\n            fn into(self) -\u003e u16 {\n                self.0\n            }\n        }\n    };\n}\n\nmacro_rules! implement_display_trait {\n    ($id_type:tt) =\u003e {\n        impl fmt::Display for $id_type {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                write!(f, \"{:#06x}\", self.0)\n            }\n        }\n    };\n}\n\nimplement_from_trait!(VendorId);\nimplement_from_trait!(ProductId);\nimplement_into_trait!(VendorId);\nimplement_into_trait!(ProductId);\nimplement_display_trait!(VendorId);\nimplement_display_trait!(ProductId);\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn vendor_id_from() {\n        let vendor_id = VendorId::from(16);\n        assert_eq!(16, vendor_id.0);\n    }\n\n    #[test]\n    fn product_id_from() {\n        let product_id = ProductId::from(16);\n        assert_eq!(16, product_id.0);\n    }\n\n    #[test]\n    fn vendor_id_display() {\n        let vendor_id = VendorId::from(16);\n        assert_eq!(\"0x0010\", format!(\"{}\", vendor_id));\n    }\n\n    #[test]\n    fn product_id_display() {\n        let product = ProductId::from(16);\n        assert_eq!(\"0x0010\", format!(\"{}\", product));\n    }\n}\n","traces":[{"line":16,"address":[4254448,4254480],"length":1,"stats":{"Line":5},"fn_name":"from"},{"line":17,"address":[4254457,4254489],"length":1,"stats":{"Line":5},"fn_name":null},{"line":26,"address":[4254512,4254528],"length":1,"stats":{"Line":6},"fn_name":"into"},{"line":36,"address":[4254752,4254544],"length":1,"stats":{"Line":2},"fn_name":"fmt"},{"line":37,"address":[4254574,4254782],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","keymap.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\n\n#[derive(Debug, PartialEq)]\npub(crate) enum Key {\n    Digit(char),\n    Enter,\n}\npub(crate) trait KeyMap: std::fmt::Debug {\n    fn map(\u0026self, key: u8) -\u003e Result\u003cKey, Error\u003e;\n}\n\nimpl Into\u003cchar\u003e for Key {\n    fn into(self) -\u003e char {\n        match self {\n            Self::Digit(c) =\u003e c,\n            Self::Enter =\u003e 'Z',\n        }\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_into_char() {\n        let digit = Key::Digit('9');\n        let c = digit.into();\n        assert_eq!('9', c);\n        let digit = Key::Enter;\n        let c = digit.into();\n        assert_eq!('Z', c);\n    }\n}\n","traces":[{"line":17,"address":[4273424],"length":1,"stats":{"Line":1},"fn_name":"into"},{"line":18,"address":[4273459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4273463,4273431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[4273451],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","lib.rs"],"content":"//! A crate for a RFID Reader USB device.\n//!\n//! The RFID Reader can be opened to get a [RfidReader](crate::RfidReader).\n//! One can read the processed data as String from this device.\n//! It makes also sense to de-initialize the [RfidReader](crate::RfidReader) upon finishing.\n//!\n//! This crate is specifically implemented for a Neuftech RFID reader,\n//! but may be extended to support other manufacturers.\n//!\n//! # Example\n//! ```rust,no_run\n//! use std::time::Duration;\n//! use rfid_reader::{VendorId, ProductId, RfidReader};\n//!\n//! // set Vendor Id and Product Id\n//! let vendor_id = VendorId::from(0x16c0);\n//! let product_id = ProductId::from(0x27db);\n//!\n//! // Define a timeout (i.e. how long waits the reader for a RFID chip).\n//! // From my experience, the longer the better, however it will block this amount of time.\n//! let timeout = Duration::from_secs(60);\n//! // get the rfid device, this may fail, for example when the device does not exist\n//! let mut rfid_reader = rfid_reader::open(vendor_id, product_id, timeout).unwrap();\n//!\n//! // Read from the device. This is blocking!\n//! // It should normally return a String containing numbers, but it may also fail.\n//! // It will return Error::Timeout whenever the timeout has expired\n//! let data = rfid_reader.read().unwrap();\n//!\n//! // Ideally de-initialize the device when no longer needed.\n//! // This may fail therefore it makes sense to call it in order to get the error instead of\n//! // a panic.\n//! let result = rfid_reader.deinitialize();\n//! if result.is_err() {\n//!   println!(\"De-initialize failed: {}\", result.unwrap_err());\n//! }\n//! ```\n#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse std::time::Duration;\n\nmod error;\nmod humbleusbdevice;\nmod id;\nmod keymap;\nmod neuftech;\nmod rfidreader;\nmod rusb;\nmod usbreader;\n\npub use error::Error;\npub use id::{ProductId, VendorId};\npub use rfidreader::RfidReader;\n\n/// Tries to open an [RfidReader](crate::RfidReader).\n///\n/// Given the VendorId and the ProductId of the device, this function tries to open the device.\n/// The `timeout` is used to wait blocking for an interrupt of the USB device.\n/// From my experience: The longer the timeout the better.\n///\n/// May fail. Most important errors are [Error::DeviceNotFound](crate::error::Error::DeviceNotFound),\n/// when the device could not be found. Or [Error::Access](crate::error::Error::Access) when there is\n/// insufficient rights to open device.\n#[cfg(not(tarpaulin_include))]\npub fn open(\n    vendor_id: VendorId,\n    product_id: ProductId,\n    timeout: Duration,\n) -\u003e Result\u003cimpl RfidReader, Error\u003e {\n    let key_map = neuftech::NeuftechKeyMap;\n    let rusb_device = rusb::open(vendor_id, product_id, timeout)?;\n    let usb_reader = neuftech::new(rusb_device)?;\n    Ok(rfidreader::from(key_map, usb_reader))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","neuftech","keymap.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::keymap::{Key, KeyMap};\n\npub struct NeuftechKeyMap;\n\nimpl KeyMap for NeuftechKeyMap {\n    fn map(\u0026self, key: u8) -\u003e Result\u003cKey, Error\u003e {\n        const OFFSET_KEY_TO_UTF8: u8 = 0x13;\n        match key {\n            // Key board codes are 30-30 for keys 1-9 (utf8 hex values 0x31-0x39)\n            30..=38 =\u003e Ok(Key::Digit(char::from(key + OFFSET_KEY_TO_UTF8))),\n            // Key board code 39 is for key 0\n            39 =\u003e Ok(Key::Digit(char::from(0x30))),\n            // Key board code for 40 is Enter\n            40 =\u003e Ok(Key::Enter),\n            // Neuftech should only report numbers, enter or control codes\n            _ =\u003e Err(Error::KeyNotExisting(key)),\n        }\n    }\n}\n\nimpl std::fmt::Debug for NeuftechKeyMap {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"NeuftechKeyMap\").finish()\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n    use std::convert::TryInto;\n\n    #[test]\n    fn test_digits() {\n        let keymap = NeuftechKeyMap;\n        let digits: Vec\u003cResult\u003cKey, Error\u003e\u003e = ('1'..='9').map(|c| Ok(Key::Digit(c))).collect();\n        let mapped_keys: Vec\u003cResult\u003cKey, Error\u003e\u003e = (30..39)\n            .map(|i| keymap.map(usize::try_into(i).unwrap()))\n            .collect();\n        assert_eq!(digits, mapped_keys);\n        assert_eq!(Ok(Key::Digit('0')), keymap.map(39));\n    }\n\n    #[test]\n    fn test_enter() {\n        let keymap = NeuftechKeyMap;\n        assert_eq!(Ok(Key::Enter), keymap.map(40));\n    }\n\n    #[test]\n    fn test_error() {\n        let keymap = NeuftechKeyMap;\n        assert_eq!(Err(Error::KeyNotExisting(17)), keymap.map(17));\n    }\n\n    #[test]\n    fn test_debug() {\n        let key_map = NeuftechKeyMap;\n        assert_eq!(\"NeuftechKeyMap\", format!(\"{:?}\", key_map));\n    }\n}\n","traces":[{"line":11,"address":[4317232],"length":1,"stats":{"Line":1},"fn_name":"map"},{"line":13,"address":[4317364,4317426,4317468],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[4317248,4317528,4317370,4317498],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4317475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4317308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4317536],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":28,"address":[4317550],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","neuftech","mod.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nmod keymap;\nmod usbreader;\n\npub(crate) use keymap::NeuftechKeyMap;\npub(crate) use usbreader::new;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","neuftech","usbreader.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::humbleusbdevice::HumbleUsbDevice;\n\nuse crate::usbreader::UsbReader;\n\npub(crate) struct NeuftechUsbReader\u003cT\u003e\nwhere\n    T: HumbleUsbDevice,\n{\n    usb_device: T,\n}\n\nimpl\u003cT: HumbleUsbDevice\u003e std::fmt::Debug for NeuftechUsbReader\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"NeuftechUsbReader\").finish()\n    }\n}\n\npub(crate) fn new\u003cT: HumbleUsbDevice\u003e(humble_usb_device: T) -\u003e Result\u003cimpl UsbReader, Error\u003e {\n    NeuftechUsbReader::new(humble_usb_device)\n}\n\nimpl\u003cT: HumbleUsbDevice\u003e NeuftechUsbReader\u003cT\u003e {\n    fn new(usb_device: T) -\u003e Result\u003cSelf, Error\u003e {\n        let mut usb_device = usb_device;\n        usb_device.initialize()?;\n        Ok(NeuftechUsbReader { usb_device })\n    }\n}\n\nimpl\u003cT: HumbleUsbDevice\u003e UsbReader for NeuftechUsbReader\u003cT\u003e {\n    fn read(\u0026self) -\u003e Result\u003cBox\u003c[u8]\u003e, Error\u003e {\n        let mut raw_data_interpreter = RawDataInterpreter::default();\n        let mut buffer = [0; 3];\n        while !raw_data_interpreter.finished_processing() {\n            let result = self.usb_device.read(\u0026mut buffer);\n            if result.is_ok() {\n                raw_data_interpreter.process(\u0026buffer)?;\n            } else {\n                let error = result.unwrap_err();\n                return Err(error);\n            }\n        }\n        Ok(Box::new(raw_data_interpreter.data))\n    }\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.usb_device.deinitialize()\n    }\n}\n\n#[derive(Debug, PartialEq)]\nenum RawDataInterpretation {\n    Value(u8),\n    Repeated,\n    Enter,\n}\n\nimpl RawDataInterpretation {\n    fn from(data: \u0026[u8]) -\u003e Result\u003cRawDataInterpretation, Error\u003e {\n        if data.len() \u003e= 3 {\n            let value = data[2];\n            let return_value = match value {\n                0 =\u003e Ok(Self::Repeated),\n                30..=39 =\u003e Ok(Self::Value(value)),\n                40 =\u003e Ok(Self::Enter),\n                _ =\u003e Err(Error::InvalidData(value)),\n            };\n            return return_value;\n        }\n        Err(Error::TooFewReceivedData(data.len()))\n    }\n}\n\nstruct RawDataInterpreter {\n    finished: bool,\n    index: usize,\n    data: [u8; 10],\n    last: Option\u003cRawDataInterpretation\u003e,\n}\n\nimpl Default for RawDataInterpreter {\n    fn default() -\u003e Self {\n        RawDataInterpreter {\n            finished: false,\n            index: 0,\n            data: [0; 10],\n            last: None,\n        }\n    }\n}\n\nimpl RawDataInterpreter {\n    fn process(\u0026mut self, raw_data: \u0026[u8]) -\u003e Result\u003c(), Error\u003e {\n        let raw_data_interpretation = RawDataInterpretation::from(raw_data)?;\n        match raw_data_interpretation {\n            RawDataInterpretation::Value(value) =\u003e {\n                self.data[self.index] = value;\n                self.last = Some(raw_data_interpretation);\n                self.index += 1;\n            }\n            RawDataInterpretation::Enter =\u003e {\n                self.last = Some(raw_data_interpretation);\n            }\n            RawDataInterpretation::Repeated =\u003e {\n                if self.index == 10 \u0026\u0026 self.last == Some(RawDataInterpretation::Enter) {\n                    self.finished = true;\n                }\n            }\n        }\n        Ok(())\n    }\n    fn finished_processing(\u0026self) -\u003e bool {\n        self.finished\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    struct ReadErrorHumbleUsbDevice {\n        deinitialized: bool,\n    }\n\n    impl HumbleUsbDevice for ReadErrorHumbleUsbDevice {\n        fn has_attached_kernel_driver(\u0026self) -\u003e Result\u003cbool, Error\u003e {\n            Ok(true)\n        }\n        fn detach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn attach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn read(\u0026self, buffer: \u0026mut [u8]) -\u003e Result\u003c(), Error\u003e {\n            Err(Error::InvalidData(0))\n        }\n        fn claim_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn release_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_active_configuration(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_alternate_setting(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_deinitialized(\u0026mut self) {\n            self.deinitialized = true;\n        }\n        fn deinitialized(\u0026self) -\u003e bool {\n            self.deinitialized\n        }\n    }\n\n    #[test]\n    fn test_raw_data_interpretation() {\n        let data: [u8; 1] = [0];\n        let result = RawDataInterpretation::from(\u0026data);\n        assert_eq!(Err(Error::TooFewReceivedData(1)), result);\n\n        let data: [u8; 3] = [1, 0, 39];\n        let result = RawDataInterpretation::from(\u0026data);\n        assert_eq!(Ok(RawDataInterpretation::Value(39)), result);\n\n        let data: [u8; 3] = [1, 0, 40];\n        let result = RawDataInterpretation::from(\u0026data);\n        assert_eq!(Ok(RawDataInterpretation::Enter), result);\n\n        let data: [u8; 3] = [1, 0, 124];\n        let result = RawDataInterpretation::from(\u0026data);\n        assert_eq!(Err(Error::InvalidData(124)), result);\n    }\n\n    #[test]\n    fn test_raw_data_interpreter() {\n        let mut interpreter = RawDataInterpreter::default();\n        let test_data = [1, 0, 39];\n        for _ in 0..=9 {\n            assert_eq!(Ok(()), interpreter.process(\u0026test_data));\n            assert!(!interpreter.finished_processing());\n        }\n        assert_eq!(10, interpreter.index);\n        let enter_data = [1, 0, 40];\n        interpreter.process(\u0026enter_data).unwrap();\n        assert_eq!(interpreter.last, Some(RawDataInterpretation::Enter));\n        assert!(!interpreter.finished_processing());\n\n        let ignore_data = [1, 0, 0];\n        interpreter.process(\u0026ignore_data).unwrap();\n        assert!(interpreter.finished_processing());\n    }\n\n    #[test]\n    fn test_usb_reader_read_error() {\n        let mut dummy_device = ReadErrorHumbleUsbDevice {\n            deinitialized: false,\n        };\n        let mut usb_reader = new(dummy_device).unwrap();\n        let result = usb_reader.read();\n        assert_eq!(Err(Error::InvalidData(0)), result);\n        usb_reader.deinitialize().unwrap();\n    }\n\n    #[test]\n    fn test_debug() {\n        let mut dummy_device = ReadErrorHumbleUsbDevice {\n            deinitialized: false,\n        };\n        dummy_device.initialize().unwrap();\n        let mut usb_reader = NeuftechUsbReader::new(dummy_device).unwrap();\n        assert_eq!(\"NeuftechUsbReader\", format!(\"{:?}\", usb_reader));\n        usb_reader.deinitialize().unwrap();\n    }\n\n    struct DummyHumbleUsbDevice {\n        index: std::cell::Cell\u003cusize\u003e,\n        enter_happened: std::cell::Cell\u003cbool\u003e,\n        deinitialized: bool,\n    }\n\n    impl HumbleUsbDevice for DummyHumbleUsbDevice {\n        fn has_attached_kernel_driver(\u0026self) -\u003e Result\u003cbool, Error\u003e {\n            Ok(true)\n        }\n        fn detach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn attach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn read(\u0026self, buffer: \u0026mut [u8]) -\u003e Result\u003c(), Error\u003e {\n            let index = self.index.get();\n\n            if index \u003c 10 {\n                buffer[2] = 30;\n                self.index.set(index + 1);\n            } else {\n                let enter_happened = self.enter_happened.get();\n                if enter_happened {\n                    buffer[2] = 0;\n                } else {\n                    buffer[2] = 40;\n                    self.enter_happened.set(true);\n                }\n            }\n\n            Ok(())\n        }\n        fn claim_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn release_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_active_configuration(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_alternate_setting(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_deinitialized(\u0026mut self) {\n            self.deinitialized = false;\n        }\n        fn deinitialized(\u0026self) -\u003e bool {\n            self.deinitialized\n        }\n    }\n\n    #[test]\n    fn test_usb_reader_successful_read() {\n        let dummy_device = DummyHumbleUsbDevice {\n            index: 0.into(),\n            enter_happened: false.into(),\n            deinitialized: false,\n        };\n        let usb_reader = NeuftechUsbReader::new(dummy_device).unwrap();\n        let result = usb_reader.read();\n\n        let expected_data: Vec\u003cu8\u003e = vec![30; 10];\n        assert_eq!(expected_data, result.unwrap().into_vec());\n    }\n}\n","traces":[{"line":18,"address":[4282240],"length":1,"stats":{"Line":1},"fn_name":"fmt\u003crfid_reader::neuftech::usbreader::tests::ReadErrorHumbleUsbDevice\u003e"},{"line":19,"address":[4282254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4282432,4282352],"length":1,"stats":{"Line":1},"fn_name":"new\u003crfid_reader::rusb::rusbhumbleusbdevice::RusbHumbleUsbDevice\u003crusb::context::Context\u003e\u003e"},{"line":24,"address":[4282449,4282359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[4282480,4283192,4283248,4283537,4282784,4282719],"length":1,"stats":{"Line":2},"fn_name":"new\u003crfid_reader::neuftech::usbreader::tests::ReadErrorHumbleUsbDevice\u003e"},{"line":29,"address":[4283258,4282502,4282794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4283281,4283207,4282856,4282522,4283428,4282734,4282609,4283048,4283552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4282574,4283332,4282920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[4283600,4284288,4284400,4285091],"length":1,"stats":{"Line":2},"fn_name":"read\u003crfid_reader::neuftech::usbreader::tests::ReadErrorHumbleUsbDevice\u003e"},{"line":37,"address":[4284418,4283618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4284461,4283661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[4284471,4284231,4285034,4283671],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[4284577,4283772],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[4283813,4284616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[4283986,4284727,4284327,4283924,4284789,4285130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[4284637,4283834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[4284900,4284097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[4283695,4284495,4285049,4284567,4283767,4284246],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[4285200],"length":1,"stats":{"Line":1},"fn_name":"deinitialize\u003crfid_reader::neuftech::usbreader::tests::ReadErrorHumbleUsbDevice\u003e"},{"line":51,"address":[4285217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[4318608],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":64,"address":[4318639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[4318708,4319100,4319072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4318855,4318883,4318926],"length":1,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[4318749,4318857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[4318889,4318773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[4318928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4318795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4318959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4318692,4318987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[4319104],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":90,"address":[4319123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4319216],"length":1,"stats":{"Line":1},"fn_name":"process"},{"line":98,"address":[4319390,4319250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4319572,4319731,4319783,4319874],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[4319345,4319574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4319590,4319897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4319639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4319955,4319689,4319925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4319736],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[4319557,4319785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[4319870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[4319881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[4319968],"length":1,"stats":{"Line":1},"fn_name":"finished_processing"},{"line":117,"address":[4319973],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":45,"coverable":47},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","rfidreader.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::keymap::{Key, KeyMap};\nuse crate::usbreader::UsbReader;\n\n/// Trait defining an [RfidReader](crate::RfidReader).\n///\n/// An [RfidReader](crate::RfidReader) will read from an USB Rfid Reader device and convert the raw data into a string but may fail reading.\n///\n/// It also makes sense to call [`deinitialize`](crate::RfidReader::deinitialize) when the RfidReader is not used anymore in order to de-initialize the\n/// used USB device. This makes sense since de-initialize may fail. However, Drop is implemented to de-initialize as well.\npub trait RfidReader: std::fmt::Debug {\n    /// Tries to read from the RfidReader.\n    ///\n    /// A String of the processed raw data is returned on success. Otherwise an error is returned.\n    /// Method is blocking, this means it will try to read data, until a valid RFID was read or an error has occurred.\n    ///\n    /// The error [`Timeout`](crate::Error::Timeout) will occur after the defined timeout expired.\n    /// One can simply call this method again, since it is not a fatal error. However as mentioned above, the call to this method\n    /// is blocking. This means when the [`Timeout`](crate::Error::Timeout) occurs, one can do something different like checking\n    /// for OS signals that may signal that the application has to be terminated.\n    fn read(\u0026self) -\u003e Result\u003cString, Error\u003e;\n    /// Tries to de-initialize the USB device of the RfidReader, which may fail.\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n}\n\nstruct GenericRfidReader\u003cK: KeyMap, U: UsbReader\u003e {\n    key_map: K,\n    usb_reader: U,\n}\n\nimpl\u003cK: KeyMap, U: UsbReader\u003e GenericRfidReader\u003cK, U\u003e {\n    fn from(key_map: K, usb_reader: U) -\u003e GenericRfidReader\u003cK, U\u003e {\n        GenericRfidReader {\n            key_map: key_map,\n            usb_reader: usb_reader,\n        }\n    }\n}\n\nimpl\u003cK: KeyMap, U: UsbReader\u003e std::fmt::Debug for GenericRfidReader\u003cK, U\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"GenericRfidReader\")\n            .field(\"keymap\", \u0026self.key_map)\n            .field(\"usbreader\", \u0026self.usb_reader)\n            .finish()\n    }\n}\n\nimpl\u003cK: KeyMap, U: UsbReader\u003e RfidReader for GenericRfidReader\u003cK, U\u003e {\n    fn read(\u0026self) -\u003e Result\u003cString, Error\u003e {\n        let raw_data = self.usb_reader.read()?;\n        let mut rfid_value = String::with_capacity(10);\n        for raw_value in raw_data.iter() {\n            let key = self.key_map.map(*raw_value);\n            if key.is_ok() {\n                let key = key.unwrap();\n                if let Key::Digit(c) = key {\n                    rfid_value.push(c)\n                }\n            }\n        }\n        Ok(rfid_value)\n    }\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.usb_reader.deinitialize()\n    }\n}\n\npub(crate) fn from\u003cK: KeyMap, U: UsbReader\u003e(key_map: K, usb_reader: U) -\u003e impl RfidReader {\n    GenericRfidReader::from(key_map, usb_reader)\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n    use crate::keymap::Key;\n\n    struct MockUsbReader;\n\n    impl UsbReader for MockUsbReader {\n        fn read(\u0026self) -\u003e Result\u003cBox\u003c[u8]\u003e, Error\u003e {\n            let data = (0..10).collect::\u003cVec\u003cu8\u003e\u003e().into_boxed_slice();\n            Ok(data)\n        }\n        fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n    }\n\n    impl std::fmt::Debug for MockUsbReader {\n        fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n            f.debug_struct(\"MockUsbReader\").finish()\n        }\n    }\n\n    struct MockKeyMap;\n    impl KeyMap for MockKeyMap {\n        fn map(\u0026self, key: u8) -\u003e Result\u003cKey, Error\u003e {\n            Ok(Key::Digit(\n                std::char::from_digit(u8::into(key), 10).unwrap(),\n            ))\n        }\n    }\n\n    impl std::fmt::Debug for MockKeyMap {\n        fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n            f.debug_struct(\"MockKeyMap\").finish()\n        }\n    }\n\n    #[test]\n    fn test_read() {\n        let usb_reader = MockUsbReader;\n        let key_map = MockKeyMap;\n        let mut rfid_reader = from(key_map, usb_reader);\n        let rfid = rfid_reader.read().unwrap();\n        assert_eq!(\"0123456789\", rfid);\n        assert_eq!(Ok(()), rfid_reader.deinitialize());\n    }\n\n    #[test]\n    fn test_debug() {\n        let usb_reader = MockUsbReader;\n        let key_map = MockKeyMap;\n        let rfid_reader = GenericRfidReader::from(key_map, usb_reader);\n        assert_eq!(\"MockKeyMap\", format!(\"{:?}\", rfid_reader.key_map));\n        assert_eq!(\n            \"GenericRfidReader { keymap: MockKeyMap, usbreader: MockUsbReader }\",\n            format!(\"{:?}\", rfid_reader)\n        );\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4261362,4260464],"length":1,"stats":{"Line":1},"fn_name":"read\u003crfid_reader::neuftech::keymap::NeuftechKeyMap,rfid_reader::neuftech::usbreader::NeuftechUsbReader\u003crfid_reader::rusb::rusbhumbleusbdevice::RusbHumbleUsbDevice\u003crusb::context::Context\u003e\u003e\u003e"},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4271936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[4272108,4272369,4272639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4261077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4261120,4261307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[4272468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4261305,4261241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4272258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4272816],"length":1,"stats":{"Line":1},"fn_name":"deinitialize\u003crfid_reader::rfidreader::tests::MockKeyMap,rfid_reader::rfidreader::tests::MockUsbReader\u003e"},{"line":69,"address":[4272833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4272848,4272864],"length":1,"stats":{"Line":1},"fn_name":"from\u003crfid_reader::rfidreader::tests::MockKeyMap,rfid_reader::rfidreader::tests::MockUsbReader\u003e"},{"line":74,"address":[4272852,4272871],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":17,"coverable":19},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","rusb","mod.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nmod rusbhumbleusbdevice;\nmod utils;\n\npub(crate) use rusbhumbleusbdevice::open;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","rusb","rusbhumbleusbdevice.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::humbleusbdevice::HumbleUsbDevice;\nuse crate::id::{ProductId, VendorId};\nuse crate::rusb::utils::{get_device, get_readable_endpoint, EndPoint};\nuse crate::Error;\n\nuse std::time::Duration;\n\nuse rusb::{Context, DeviceHandle, UsbContext};\n\nstruct RusbHumbleUsbDevice\u003cT: UsbContext\u003e {\n    device_handle: DeviceHandle\u003cT\u003e,\n    endpoint: EndPoint,\n    timeout: Duration,\n    deinitialized: bool,\n}\n\nimpl\u003cT: UsbContext\u003e HumbleUsbDevice for RusbHumbleUsbDevice\u003cT\u003e {\n    #[cfg(not(tarpaulin_include))]\n    fn has_attached_kernel_driver(\u0026self) -\u003e Result\u003cbool, Error\u003e {\n        let result = self\n            .device_handle\n            .kernel_driver_active(self.endpoint.get_interface());\n        if result.is_ok() {\n            Ok(result.unwrap())\n        } else {\n            Err(result.unwrap_err().into())\n        }\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn detach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .detach_kernel_driver(self.endpoint.get_interface())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn attach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .attach_kernel_driver(self.endpoint.get_interface())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn read(\u0026self, buffer: \u0026mut [u8]) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .read_interrupt(self.endpoint.get_address(), buffer, self.timeout)?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn claim_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .claim_interface(self.endpoint.get_interface())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn release_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .release_interface(self.endpoint.get_interface())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn set_active_configuration(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .set_active_configuration(self.endpoint.get_config())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn set_alternate_setting(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .set_alternate_setting(self.endpoint.get_interface(), self.endpoint.get_setting())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn set_deinitialized(\u0026mut self) {\n        self.deinitialized = false;\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn deinitialized(\u0026self) -\u003e bool {\n        self.deinitialized\n    }\n}\n\nimpl\u003cT: UsbContext\u003e Drop for RusbHumbleUsbDevice\u003cT\u003e {\n    #[cfg(not(tarpaulin_include))]\n    fn drop(\u0026mut self) {\n        if !self.deinitialized() {\n            self.set_deinitialized();\n            self.deinitialize().unwrap();\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\npub(crate) fn open(\n    vendor_id: VendorId,\n    product_id: ProductId,\n    timeout: Duration,\n) -\u003e Result\u003cimpl HumbleUsbDevice, Error\u003e {\n    let context = Context::new()?;\n    let (device, device_descriptor) = get_device(\u0026context, vendor_id, product_id)?;\n    let endpoint =\n        get_readable_endpoint(\u0026device, \u0026device_descriptor, rusb::TransferType::Interrupt)?;\n    let device_handle = device.open()?;\n    Ok(RusbHumbleUsbDevice {\n        device_handle,\n        endpoint,\n        timeout,\n        deinitialized: false,\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","rusb","utils.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::id::{ProductId, VendorId};\nuse rusb::{Device, DeviceDescriptor, Direction, TransferType, UsbContext};\n\n#[derive(Debug, PartialEq)]\npub(crate) struct EndPoint {\n    config: u8,\n    interface: u8,\n    setting: u8,\n    address: u8,\n}\n\nimpl EndPoint {\n    pub(crate) fn get_interface(\u0026self) -\u003e u8 {\n        self.interface\n    }\n    pub(crate) fn get_address(\u0026self) -\u003e u8 {\n        self.address\n    }\n    pub(crate) fn get_config(\u0026self) -\u003e u8 {\n        self.config\n    }\n    pub(crate) fn get_setting(\u0026self) -\u003e u8 {\n        self.setting\n    }\n}\n\npub(crate) fn get_device\u003cT: UsbContext\u003e(\n    context: \u0026T,\n    vendor_id: VendorId,\n    product_id: ProductId,\n) -\u003e Result\u003c(Device\u003cT\u003e, DeviceDescriptor), Error\u003e {\n    let devices = context.devices()?;\n    for device in devices.iter() {\n        let device_descriptor = device.device_descriptor()?;\n        if device_descriptor.vendor_id() == vendor_id.into()\n            \u0026\u0026 device_descriptor.product_id() == product_id.into()\n        {\n            return Ok((device, device_descriptor));\n        }\n    }\n    Err(Error::DeviceNotFound(vendor_id, product_id))\n}\n\npub(crate) fn get_readable_endpoint\u003cT: UsbContext\u003e(\n    device: \u0026Device\u003cT\u003e,\n    device_descriptor: \u0026DeviceDescriptor,\n    transfer_type: TransferType,\n) -\u003e Result\u003cEndPoint, Error\u003e {\n    for n in 0..device_descriptor.num_configurations() {\n        let config_description = match device.config_descriptor(n) {\n            Ok(c) =\u003e c,\n            Err(_) =\u003e continue,\n        };\n        for interface in config_description.interfaces() {\n            for interface_description in interface.descriptors() {\n                for endpoint_descriptor in interface_description.endpoint_descriptors() {\n                    if endpoint_descriptor.direction() == Direction::In\n                        \u0026\u0026 endpoint_descriptor.transfer_type() == transfer_type\n                    {\n                        return Ok(EndPoint {\n                            config: config_description.number(),\n                            interface: interface_description.interface_number(),\n                            setting: interface_description.setting_number(),\n                            address: endpoint_descriptor.address(),\n                        });\n                    }\n                }\n            }\n        }\n    }\n    Err(Error::ReadableEndPointNotFound(\n        device_descriptor.vendor_id().into(),\n        device_descriptor.product_id().into(),\n    ))\n}\n\nimpl From\u003crusb::Error\u003e for Error {\n    fn from(error: rusb::Error) -\u003e Self {\n        match error {\n            rusb::Error::Timeout =\u003e Error::Timeout,\n            rusb::Error::Access =\u003e Error::Access,\n            _ =\u003e Error::OtherUsbError(error.to_string()),\n        }\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_get_device_not_found() {\n        let context = rusb::Context::new().unwrap();\n        let device = get_device(\u0026context, VendorId::from(0), ProductId::from(0));\n        assert!(device.is_err());\n    }\n\n    #[test]\n    fn test_get_device() {\n        // readable device in my system, change these two values in your system\n        let vendor_id = VendorId::from(0x0cf3);\n        let product_id = ProductId::from(0x3005);\n\n        let context = rusb::Context::new().unwrap();\n        let device = get_device(\u0026context, vendor_id, product_id);\n\n        assert!(device.is_ok());\n    }\n\n    #[test]\n    fn test_get_readable_endpoint() {\n        let context = rusb::Context::new().unwrap();\n\n        // readable device in my system, change these two values in your system\n        let vendor_id = VendorId::from(0x0cf3);\n        let product_id = ProductId::from(0x3005);\n        let result = get_device(\u0026context, vendor_id, product_id);\n        assert!(result.is_ok());\n        let (device, device_descriptor) = result.unwrap();\n        let endpoint = get_readable_endpoint(\u0026device, \u0026device_descriptor, TransferType::Interrupt);\n        assert!(endpoint.is_ok());\n        assert_eq!(\n            EndPoint {\n                config: 1,\n                interface: 0,\n                setting: 0,\n                address: 129\n            },\n            endpoint.unwrap()\n        );\n    }\n\n    #[test]\n    fn test_get_no_readable_endpoint() {\n        let context = rusb::Context::new().unwrap();\n\n        // device in my system without readable bulk endpoint, change these two values in your system\n        let vendor_id = VendorId::from(0x058f);\n        let product_id = ProductId::from(0xa004);\n        let result = get_device(\u0026context, vendor_id, product_id);\n        assert!(result.is_ok());\n        let (device, device_descriptor) = result.unwrap();\n        let endpoint = get_readable_endpoint(\u0026device, \u0026device_descriptor, TransferType::Bulk);\n        assert_eq!(\n            Err(Error::ReadableEndPointNotFound(vendor_id, product_id)),\n            endpoint\n        );\n    }\n\n    #[test]\n    fn test_endpoint() {\n        let endpoint = EndPoint {\n            config: 0,\n            interface: 1,\n            setting: 2,\n            address: 3,\n        };\n        assert_eq!(0, endpoint.get_config());\n        assert_eq!(1, endpoint.get_interface());\n        assert_eq!(2, endpoint.get_setting());\n        assert_eq!(3, endpoint.get_address());\n    }\n\n    #[test]\n    fn test_from_rusb_error() {\n        let rusb_error = rusb::Error::Io;\n        let error = Error::from(rusb_error);\n        assert_eq!(\n            Error::OtherUsbError(String::from(\"Input/Output Error\")),\n            error\n        );\n        let rusb_error = rusb::Error::Timeout;\n        let error = Error::from(rusb_error);\n        assert_eq!(Error::Timeout, error);\n        let rusb_error = rusb::Error::Access;\n        let error = Error::from(rusb_error);\n        assert_eq!(Error::Access, error);\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[4270245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[4270256],"length":1,"stats":{"Line":1},"fn_name":"get_address"},{"line":22,"address":[4270261],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[4270272],"length":1,"stats":{"Line":1},"fn_name":"get_config"},{"line":25,"address":[4270277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[4270288],"length":1,"stats":{"Line":1},"fn_name":"get_setting"},{"line":28,"address":[4270293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4257968,4259293],"length":1,"stats":{"Line":4},"fn_name":"get_device\u003crusb::context::Context\u003e"},{"line":37,"address":[4258155,4258002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4258223,4258148,4258398,4259077],"length":1,"stats":{"Line":12},"fn_name":null},{"line":39,"address":[4258520,4258657],"length":1,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[4258762,4258846,4258718,4258633],"length":1,"stats":{"Line":14},"fn_name":null},{"line":41,"address":[4258738,4258818],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[4258876],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[4259087],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4259424,4260999],"length":1,"stats":{"Line":2},"fn_name":"get_readable_endpoint\u003crusb::context::Context\u003e"},{"line":54,"address":[4259665,4259465,4259675,4260809],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[4259783,4259706,4259667],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[4259785,4259761],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[4260010,4259809,4260220],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[4260403,4260076,4260225],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[4260408,4260624,4260259],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[4260508,4260442,4260611],"length":1,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[4260573,4260485],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[4260725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4260629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4260652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4260675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4260698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4260877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4259646,4260822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[4260843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[4262112],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":84,"address":[4262193,4262203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[4262190,4262124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[4262200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4262168,4262205],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":38,"coverable":38},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","usbreader.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\npub(crate) trait UsbReader: std::fmt::Debug {\n    fn read(\u0026self) -\u003e Result\u003cBox\u003c[u8]\u003e, Error\u003e;\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","error.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\n/// Track store errors.\n///\n/// Defines all runtime errors.\n#[derive(Debug, PartialEq)]\npub enum Error {\n    /// Load error.\n    ///\n    /// Returned when [`load`](crate::load)ing the [`TrackStore`](crate::TrackStore) did not work,\n    /// e.g. when the parsed yaml string is invalid.\n    LoadError(String),\n}\n\nimpl std::error::Error for Error {}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_display() {\n        let error = Error::LoadError(String::from(\"test\"));\n        let formatted_string = format!(\"{}\", error);\n        assert_eq!(\"LoadError(\\\"test\\\")\", formatted_string);\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","id.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse serde::{Deserialize, Serialize};\n/// The Id of a track.\n///\n/// In order to receive a [`TrackPath`](crate::TrackPath) from the [`TrackStore`](crate::TrackStore),\n/// one must must create an Id from a [`String`](std::string::String).\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Hash)]\npub struct Id(String);\n\nimpl From\u003cString\u003e for Id {\n    fn from(s: String) -\u003e Self {\n        Id(s)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for Id {\n    fn from(path: \u0026str) -\u003e Self {\n        Id(path.into())\n    }\n}\n\nimpl std::fmt::Display for Id {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let id = Id::from(\"01234\");\n        let formatted_id = format!(\"{}\", id);\n        assert_eq!(String::from(\"01234\"), formatted_id);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[6458224],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","lib.rs"],"content":"//! Crate that stores paths to tracks and enables access to these paths by using ids.\n//!\n//! The [`TrackStore`](crate::TrackStore) can be [`load`](crate::load)ed from a yaml string that is a list\n//! of key value pairs.\n//! Each key is an [`Id`](crate::Id) defined by a [`String`](std::string::String).\n//! Each value is a [`TrackPath`](crate::TrackPath) defined by a [`String`](std::string::String).\n//!\n//! # Example\n//! ```rust\n//! // use crate\n//! use track_store::{load, TrackStore, Id, TrackPath};\n//!\n//! // simple key value list in the yaml string\n//! let yaml_string = \"01234: path/to/track\";\n//!\n//! // load the TrackStore from the yaml string.\n//! let track_store = load(yaml_string).unwrap();\n//!\n//! // Create an Id from a string\n//! let id = Id::from(String::from(\"01234\"));\n//!\n//! // get the track path as an Option\n//! let track_path = track_store.get_path(\u0026id);\n//! assert!(track_path.is_some());\n//! let expected_path = String::from(\"path/to/track\").into();\n//! assert_eq!(Some(\u0026expected_path), track_path);\n//!\n//! // If the Id does not exist, the returned track path is None.\n//! let id = Id::from(String::from(\"0\"));\n//! let track_path = track_store.get_path(\u0026id);\n//! assert!(track_path.is_none());\n//! ```\n#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nmod error;\nmod id;\nmod trackpath;\nmod trackstore;\n\npub use error::Error;\npub use id::Id;\npub use trackpath::TrackPath;\npub use trackstore::{load, TrackStore};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","trackpath.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse std::fmt::Display;\n\nuse serde::{Deserialize, Serialize};\n\n/// The path of a track.\n///\n/// The [`TrackPath`](crate::TrackPath) is created from a [`String`](std::string::String) or a [`\u0026str`](std::str) and contains the path to the track.\n#[derive(Serialize, Deserialize, Debug, PartialEq)]\npub struct TrackPath(String);\n\nimpl From\u003cString\u003e for TrackPath {\n    fn from(s: String) -\u003e Self {\n        TrackPath(s)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for TrackPath {\n    fn from(path: \u0026str) -\u003e Self {\n        TrackPath(path.into())\n    }\n}\n\nimpl AsRef\u003cstr\u003e for TrackPath {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        self.0.as_ref()\n    }\n}\n\nimpl Display for TrackPath {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let track_path = TrackPath::from(\"path\");\n        let formatted_track_path = format!(\"{}\", track_path);\n        assert_eq!(String::from(\"path\"), formatted_track_path);\n    }\n}\n","traces":[{"line":16,"address":[10940384],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","trackstore.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::id::Id;\nuse crate::trackpath::TrackPath;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// The [`TrackStore`](crate::TrackStore) trait.\n///\n/// Enables to get the [`TrackPath`](crate::TrackPath) of a track if there is a path found for the\n/// given [`Id`](crate::Id).\npub trait TrackStore {\n    /// Get the [`TrackPath`](crate::TrackPath) for the supplied [`Id`](crate::Id) or [`None`](std::option::Option::None)\n    /// if there is no path for the supplied id.\n    fn get_path(\u0026self, id: \u0026Id) -\u003e Option\u003c\u0026TrackPath\u003e;\n}\n\n/// Load a [`TrackStore`](crate::TrackStore) from the supplied yaml [String](std::string::String).\n///\n/// Returns a [`LoadError`](crate::Error::LoadError) if the store cannot be loaded. Most likely the yaml string is\n/// ill-formed.\npub fn load(yaml_string: \u0026str) -\u003e Result\u003cimpl TrackStore, Error\u003e {\n    let track_store_result: serde_yaml::Result\u003cTrackStoreImplementation\u003e =\n        serde_yaml::from_str(yaml_string);\n    match track_store_result {\n        Err(error) =\u003e Err(Error::LoadError(error.to_string())),\n        Ok(track_store) =\u003e Ok(track_store),\n    }\n}\n\n#[derive(Serialize, Deserialize)]\nstruct TrackStoreImplementation(HashMap\u003cId, TrackPath\u003e);\n\nimpl TrackStore for TrackStoreImplementation {\n    fn get_path(\u0026self, id: \u0026Id) -\u003e Option\u003c\u0026TrackPath\u003e {\n        self.0.get(id)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_serialize() {\n        let mut map = HashMap::new();\n        let id = Id::from(\"1234\");\n        let path = TrackPath::from(\"path/to/track\");\n        map.insert(id, path);\n\n        let track_store = TrackStoreImplementation(map);\n        let yaml = serde_yaml::to_string(\u0026track_store).unwrap();\n        let expected_string = \"---\n\\\"1234\\\": path/to/track\";\n        assert_eq!(expected_string, yaml);\n    }\n\n    #[test]\n    fn test_deserialize() {\n        let yaml = \"1234: path/to/track\n4321: path/to/track_2\";\n        let track_store = load(yaml).unwrap();\n        let id = \"1234\".into();\n        let track_path = track_store.get_path(\u0026id);\n        assert!(track_path.is_some());\n        let expected_path = \"path/to/track\".into();\n        assert_eq!(Some(\u0026expected_path), track_path);\n\n        let id = String::from(\"4321\").into();\n        let track_path = track_store.get_path(\u0026id);\n        assert!(track_path.is_some());\n        let expected_path = String::from(\"path/to/track_2\").into();\n        assert_eq!(Some(\u0026expected_path), track_path);\n\n        let id = String::from(\"4\").into();\n        let track_path = track_store.get_path(\u0026id);\n        assert!(track_path.is_none());\n    }\n\n    #[test]\n    fn test_load_error() {\n        let yaml = \"error\";\n        let load_result = load(yaml);\n        assert!(load_result.is_err());\n        match load_result {\n            Err(error) =\u003e assert_eq!(\n                Error::LoadError(String::from(\n                    \"invalid type: string \\\"error\\\", expected a map at line 1 column 1\"\n                )),\n                error\n            ),\n            Ok(value) =\u003e assert!(false, \"Expected error found value\"),\n        }\n    }\n}\n","traces":[{"line":25,"address":[4263166,4262816],"length":1,"stats":{"Line":2},"fn_name":"load"},{"line":26,"address":[4262842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[4263012,4263138],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[4262865,4263019,4263140],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[4262882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","usb_reader_test","src","main.rs"],"content":"extern crate rusb;\nuse std::time::Duration;\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    for device in rusb::devices().unwrap().iter() {\n        let device_desc = device.device_descriptor().unwrap();\n\n        println!(\n            \"Bus {:03} Device {:03} ID {:04x}:{:04x}\",\n            device.bus_number(),\n            device.address(),\n            device_desc.vendor_id(),\n            device_desc.product_id()\n        );\n    }\n\n    let mut device_handle =\n        rusb::open_device_with_vid_pid(0x16c0, 0x27db).expect(\"device not found\");\n    let active_configuration = device_handle.active_configuration();\n    println!(\"Active configuraton: {:?}\", active_configuration);\n    //device_handle.reset().unwrap();\n    let mut buffer: [u8; 3] = [0; 3];\n    println!(\n        \"Has kernel driver: {:?}\",\n        device_handle.kernel_driver_active(0)\n    );\n    println!(\n        \"Detach kernel driver? {:?}\",\n        device_handle.detach_kernel_driver(0)\n    );\n    device_handle.claim_interface(0).unwrap();\n    for _ in 0..15 {\n        let read_result = device_handle.read_interrupt(0x81, \u0026mut buffer, Duration::from_secs(10));\n        if read_result.is_ok() {\n            println!(\"Read result: {:?}\", read_result);\n            println!(\"Buffer: {:?}\", buffer);\n            let value = String::from_utf8(Vec::from(buffer));\n            if value.is_ok() {\n                let value = value.unwrap();\n                println!(\"Value: {}\", value);\n            } else {\n                let error = value.unwrap_err();\n                println!(\"{:?}\", error);\n            }\n        } else {\n            println!(\n                \"Could not read from the device: {:?}\",\n                read_result.unwrap_err()\n            );\n        }\n    }\n    device_handle.attach_kernel_driver(0).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","usr","lib","gcc","x86_64-pc-linux-gnu","10.2.0","include","emmintrin.h"],"content":"/* Copyright (C) 2003-2020 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   Under Section 7 of GPL version 3, you are granted additional\n   permissions described in the GCC Runtime Library Exception, version\n   3.1, as published by the Free Software Foundation.\n\n   You should have received a copy of the GNU General Public License and\n   a copy of the GCC Runtime Library Exception along with this program;\n   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   \u003chttp://www.gnu.org/licenses/\u003e.  */\n\n/* Implemented from the specification included in the Intel C++ Compiler\n   User Guide and Reference, version 9.0.  */\n\n#ifndef _EMMINTRIN_H_INCLUDED\n#define _EMMINTRIN_H_INCLUDED\n\n/* We need definitions from the SSE header files*/\n#include \u003cxmmintrin.h\u003e\n\n#ifndef __SSE2__\n#pragma GCC push_options\n#pragma GCC target(\"sse2\")\n#define __DISABLE_SSE2__\n#endif /* __SSE2__ */\n\n/* SSE2 */\ntypedef double __v2df __attribute__ ((__vector_size__ (16)));\ntypedef long long __v2di __attribute__ ((__vector_size__ (16)));\ntypedef unsigned long long __v2du __attribute__ ((__vector_size__ (16)));\ntypedef int __v4si __attribute__ ((__vector_size__ (16)));\ntypedef unsigned int __v4su __attribute__ ((__vector_size__ (16)));\ntypedef short __v8hi __attribute__ ((__vector_size__ (16)));\ntypedef unsigned short __v8hu __attribute__ ((__vector_size__ (16)));\ntypedef char __v16qi __attribute__ ((__vector_size__ (16)));\ntypedef signed char __v16qs __attribute__ ((__vector_size__ (16)));\ntypedef unsigned char __v16qu __attribute__ ((__vector_size__ (16)));\n\n/* The Intel API is flexible enough that we must allow aliasing with other\n   vector types, and their scalar components.  */\ntypedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));\ntypedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));\n\n/* Unaligned version of the same types.  */\ntypedef long long __m128i_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));\ntypedef double __m128d_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));\n\n/* Create a selector for use with the SHUFPD instruction.  */\n#define _MM_SHUFFLE2(fp1,fp0) \\\n (((fp1) \u003c\u003c 1) | (fp0))\n\n/* Create a vector with element 0 as F and the rest zero.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_sd (double __F)\n{\n  return __extension__ (__m128d){ __F, 0.0 };\n}\n\n/* Create a vector with both elements equal to F.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_pd (double __F)\n{\n  return __extension__ (__m128d){ __F, __F };\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_pd1 (double __F)\n{\n  return _mm_set1_pd (__F);\n}\n\n/* Create a vector with the lower value X and upper value W.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_pd (double __W, double __X)\n{\n  return __extension__ (__m128d){ __X, __W };\n}\n\n/* Create a vector with the lower value W and upper value X.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_pd (double __W, double __X)\n{\n  return __extension__ (__m128d){ __W, __X };\n}\n\n/* Create an undefined vector.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_undefined_pd (void)\n{\n  __m128d __Y = __Y;\n  return __Y;\n}\n\n/* Create a vector of zeros.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setzero_pd (void)\n{\n  return __extension__ (__m128d){ 0.0, 0.0 };\n}\n\n/* Sets the low DPFP value of A from the low value of B.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_move_sd (__m128d __A, __m128d __B)\n{\n  return __extension__ (__m128d) __builtin_shuffle ((__v2df)__A, (__v2df)__B, (__v2di){2, 1});\n}\n\n/* Load two DPFP values from P.  The address must be 16-byte aligned.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_pd (double const *__P)\n{\n  return *(__m128d *)__P;\n}\n\n/* Load two DPFP values from P.  The address need not be 16-byte aligned.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadu_pd (double const *__P)\n{\n  return *(__m128d_u *)__P;\n}\n\n/* Create a vector with all two elements equal to *P.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load1_pd (double const *__P)\n{\n  return _mm_set1_pd (*__P);\n}\n\n/* Create a vector with element 0 as *P and the rest zero.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_sd (double const *__P)\n{\n  return _mm_set_sd (*__P);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_pd1 (double const *__P)\n{\n  return _mm_load1_pd (__P);\n}\n\n/* Load two DPFP values in reverse order.  The address must be aligned.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadr_pd (double const *__P)\n{\n  __m128d __tmp = _mm_load_pd (__P);\n  return __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,1));\n}\n\n/* Store two DPFP values.  The address must be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_pd (double *__P, __m128d __A)\n{\n  *(__m128d *)__P = __A;\n}\n\n/* Store two DPFP values.  The address need not be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeu_pd (double *__P, __m128d __A)\n{\n  *(__m128d_u *)__P = __A;\n}\n\n/* Stores the lower DPFP value.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_sd (double *__P, __m128d __A)\n{\n  *__P = ((__v2df)__A)[0];\n}\n\nextern __inline double __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_f64 (__m128d __A)\n{\n  return ((__v2df)__A)[0];\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storel_pd (double *__P, __m128d __A)\n{\n  _mm_store_sd (__P, __A);\n}\n\n/* Stores the upper DPFP value.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeh_pd (double *__P, __m128d __A)\n{\n  *__P = ((__v2df)__A)[1];\n}\n\n/* Store the lower DPFP value across two words.\n   The address must be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store1_pd (double *__P, __m128d __A)\n{\n  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, _MM_SHUFFLE2 (0,0)));\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_pd1 (double *__P, __m128d __A)\n{\n  _mm_store1_pd (__P, __A);\n}\n\n/* Store two DPFP values in reverse order.  The address must be aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storer_pd (double *__P, __m128d __A)\n{\n  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, _MM_SHUFFLE2 (0,1)));\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi128_si32 (__m128i __A)\n{\n  return __builtin_ia32_vec_ext_v4si ((__v4si)__A, 0);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi128_si64 (__m128i __A)\n{\n  return ((__v2di)__A)[0];\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi128_si64x (__m128i __A)\n{\n  return ((__v2di)__A)[0];\n}\n#endif\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d) ((__v2df)__A + (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_addsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d) ((__v2df)__A - (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_subsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d) ((__v2df)__A * (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_mulsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_div_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d) ((__v2df)__A / (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_div_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_divsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sqrt_pd (__m128d __A)\n{\n  return (__m128d)__builtin_ia32_sqrtpd ((__v2df)__A);\n}\n\n/* Return pair {sqrt (B[0]), A[1]}.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sqrt_sd (__m128d __A, __m128d __B)\n{\n  __v2df __tmp = __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);\n  return (__m128d)__builtin_ia32_sqrtsd ((__v2df)__tmp);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_minpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_minsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_maxpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_maxsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_and_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_andpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_andnot_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_andnpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_or_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_orpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_xor_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_xorpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpeqpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpltpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmple_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmplepd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpgtpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpge_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpgepd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpneq_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpneqpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnlt_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpnltpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnle_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpnlepd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpngt_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpngtpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnge_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpngepd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpord_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpordpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpunord_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpunordpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpeqsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpltsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmple_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmplesd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n\t\t\t\t\t (__v2df)\n\t\t\t\t\t __builtin_ia32_cmpltsd ((__v2df) __B,\n\t\t\t\t\t\t\t\t (__v2df)\n\t\t\t\t\t\t\t\t __A));\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpge_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n\t\t\t\t\t (__v2df)\n\t\t\t\t\t __builtin_ia32_cmplesd ((__v2df) __B,\n\t\t\t\t\t\t\t\t (__v2df)\n\t\t\t\t\t\t\t\t __A));\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpneq_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpneqsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnlt_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpnltsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnle_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpnlesd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpngt_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n\t\t\t\t\t (__v2df)\n\t\t\t\t\t __builtin_ia32_cmpnltsd ((__v2df) __B,\n\t\t\t\t\t\t\t\t  (__v2df)\n\t\t\t\t\t\t\t\t  __A));\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnge_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n\t\t\t\t\t (__v2df)\n\t\t\t\t\t __builtin_ia32_cmpnlesd ((__v2df) __B,\n\t\t\t\t\t\t\t\t  (__v2df)\n\t\t\t\t\t\t\t\t  __A));\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpord_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpordsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpunord_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpunordsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comieq_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdeq ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comilt_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdlt ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comile_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdle ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comigt_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdgt ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comige_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdge ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comineq_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdneq ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomieq_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdeq ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomilt_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdlt ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomile_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdle ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomigt_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdgt ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomige_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdge ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomineq_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdneq ((__v2df)__A, (__v2df)__B);\n}\n\n/* Create a vector of Qi, where i is the element number.  */\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi64x (long long __q1, long long __q0)\n{\n  return __extension__ (__m128i)(__v2di){ __q0, __q1 };\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi64 (__m64 __q1,  __m64 __q0)\n{\n  return _mm_set_epi64x ((long long)__q1, (long long)__q0);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n{\n  return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,\n\t       short __q3, short __q2, short __q1, short __q0)\n{\n  return __extension__ (__m128i)(__v8hi){\n    __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n\t      char __q11, char __q10, char __q09, char __q08,\n\t      char __q07, char __q06, char __q05, char __q04,\n\t      char __q03, char __q02, char __q01, char __q00)\n{\n  return __extension__ (__m128i)(__v16qi){\n    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,\n    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15\n  };\n}\n\n/* Set all of the elements of the vector to A.  */\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi64x (long long __A)\n{\n  return _mm_set_epi64x (__A, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi64 (__m64 __A)\n{\n  return _mm_set_epi64 (__A, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi32 (int __A)\n{\n  return _mm_set_epi32 (__A, __A, __A, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi16 (short __A)\n{\n  return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi8 (char __A)\n{\n  return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,\n\t\t       __A, __A, __A, __A, __A, __A, __A, __A);\n}\n\n/* Create a vector of Qi, where i is the element number.\n   The parameter order is reversed from the _mm_set_epi* functions.  */\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_epi64 (__m64 __q0, __m64 __q1)\n{\n  return _mm_set_epi64 (__q1, __q0);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)\n{\n  return _mm_set_epi32 (__q3, __q2, __q1, __q0);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,\n\t        short __q4, short __q5, short __q6, short __q7)\n{\n  return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,\n\t       char __q04, char __q05, char __q06, char __q07,\n\t       char __q08, char __q09, char __q10, char __q11,\n\t       char __q12, char __q13, char __q14, char __q15)\n{\n  return _mm_set_epi8 (__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,\n\t\t       __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);\n}\n\n/* Create a vector with element 0 as *P and the rest zero.  */\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_si128 (__m128i const *__P)\n{\n  return *__P;\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadu_si128 (__m128i_u const *__P)\n{\n  return *__P;\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadl_epi64 (__m128i_u const *__P)\n{\n  return _mm_set_epi64 ((__m64)0LL, *(__m64_u *)__P);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadu_si64 (void const *__P)\n{\n  return _mm_loadl_epi64 ((__m128i_u *)__P);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_si128 (__m128i *__P, __m128i __B)\n{\n  *__P = __B;\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n{\n  *__P = __B;\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storel_epi64 (__m128i_u *__P, __m128i __B)\n{\n  *(__m64_u *)__P = (__m64) ((__v2di)__B)[0];\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeu_si64 (void *__P, __m128i __B)\n{\n  _mm_storel_epi64 ((__m128i_u *)__P, __B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movepi64_pi64 (__m128i __B)\n{\n  return (__m64) ((__v2di)__B)[0];\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movpi64_epi64 (__m64 __A)\n{\n  return _mm_set_epi64 ((__m64)0LL, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_move_epi64 (__m128i __A)\n{\n  return (__m128i)__builtin_ia32_movq128 ((__v2di) __A);\n}\n\n/* Create an undefined vector.  */\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_undefined_si128 (void)\n{\n  __m128i __Y = __Y;\n  return __Y;\n}\n\n/* Create a vector of zeros.  */\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setzero_si128 (void)\n{\n  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtepi32_pd (__m128i __A)\n{\n  return (__m128d)__builtin_ia32_cvtdq2pd ((__v4si) __A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtepi32_ps (__m128i __A)\n{\n  return (__m128)__builtin_ia32_cvtdq2ps ((__v4si) __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpd_epi32 (__m128d __A)\n{\n  return (__m128i)__builtin_ia32_cvtpd2dq ((__v2df) __A);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpd_pi32 (__m128d __A)\n{\n  return (__m64)__builtin_ia32_cvtpd2pi ((__v2df) __A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpd_ps (__m128d __A)\n{\n  return (__m128)__builtin_ia32_cvtpd2ps ((__v2df) __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttpd_epi32 (__m128d __A)\n{\n  return (__m128i)__builtin_ia32_cvttpd2dq ((__v2df) __A);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttpd_pi32 (__m128d __A)\n{\n  return (__m64)__builtin_ia32_cvttpd2pi ((__v2df) __A);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi32_pd (__m64 __A)\n{\n  return (__m128d)__builtin_ia32_cvtpi2pd ((__v2si) __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_epi32 (__m128 __A)\n{\n  return (__m128i)__builtin_ia32_cvtps2dq ((__v4sf) __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttps_epi32 (__m128 __A)\n{\n  return (__m128i)__builtin_ia32_cvttps2dq ((__v4sf) __A);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_pd (__m128 __A)\n{\n  return (__m128d)__builtin_ia32_cvtps2pd ((__v4sf) __A);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_si32 (__m128d __A)\n{\n  return __builtin_ia32_cvtsd2si ((__v2df) __A);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_si64 (__m128d __A)\n{\n  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_si64x (__m128d __A)\n{\n  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);\n}\n#endif\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttsd_si32 (__m128d __A)\n{\n  return __builtin_ia32_cvttsd2si ((__v2df) __A);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttsd_si64 (__m128d __A)\n{\n  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttsd_si64x (__m128d __A)\n{\n  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);\n}\n#endif\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_ss (__m128 __A, __m128d __B)\n{\n  return (__m128)__builtin_ia32_cvtsd2ss ((__v4sf) __A, (__v2df) __B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi32_sd (__m128d __A, int __B)\n{\n  return (__m128d)__builtin_ia32_cvtsi2sd ((__v2df) __A, __B);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64_sd (__m128d __A, long long __B)\n{\n  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64x_sd (__m128d __A, long long __B)\n{\n  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);\n}\n#endif\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_sd (__m128d __A, __m128 __B)\n{\n  return (__m128d)__builtin_ia32_cvtss2sd ((__v2df) __A, (__v4sf)__B);\n}\n\n#ifdef __OPTIMIZE__\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_pd(__m128d __A, __m128d __B, const int __mask)\n{\n  return (__m128d)__builtin_ia32_shufpd ((__v2df)__A, (__v2df)__B, __mask);\n}\n#else\n#define _mm_shuffle_pd(A, B, N)\t\t\t\t\t\t\\\n  ((__m128d)__builtin_ia32_shufpd ((__v2df)(__m128d)(A),\t\t\\\n\t\t\t\t   (__v2df)(__m128d)(B), (int)(N)))\n#endif\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_unpckhpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_unpcklpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadh_pd (__m128d __A, double const *__B)\n{\n  return (__m128d)__builtin_ia32_loadhpd ((__v2df)__A, __B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadl_pd (__m128d __A, double const *__B)\n{\n  return (__m128d)__builtin_ia32_loadlpd ((__v2df)__A, __B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movemask_pd (__m128d __A)\n{\n  return __builtin_ia32_movmskpd ((__v2df)__A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_packs_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_packsswb128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_packs_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_packssdw128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_packus_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_packuswb128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckhbw128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckhwd128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckhdq128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckhqdq128 ((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpcklbw128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpcklwd128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckldq128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpcklqdq128 ((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qu)__A + (__v16qu)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hu)__A + (__v8hu)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4su)__A + (__v4su)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A + (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_adds_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_paddsb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_adds_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_paddsw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_adds_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_paddusb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_adds_epu16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_paddusw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qu)__A - (__v16qu)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hu)__A - (__v8hu)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4su)__A - (__v4su)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A - (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_subs_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psubsb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_subs_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psubsw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_subs_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psubusb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_subs_epu16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psubusw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_madd_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmaddwd128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mulhi_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmulhw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mullo_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hu)__A * (__v8hu)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_su32 (__m64 __A, __m64 __B)\n{\n  return (__m64)__builtin_ia32_pmuludq ((__v2si)__A, (__v2si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_epu32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmuludq128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_slli_epi16 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psllwi128 ((__v8hi)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_slli_epi32 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_pslldi128 ((__v4si)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_slli_epi64 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psllqi128 ((__v2di)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srai_epi16 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psrawi128 ((__v8hi)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srai_epi32 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psradi128 ((__v4si)__A, __B);\n}\n\n#ifdef __OPTIMIZE__\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_bsrli_si128 (__m128i __A, const int __N)\n{\n  return (__m128i)__builtin_ia32_psrldqi128 (__A, __N * 8);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_bslli_si128 (__m128i __A, const int __N)\n{\n  return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srli_si128 (__m128i __A, const int __N)\n{\n  return (__m128i)__builtin_ia32_psrldqi128 (__A, __N * 8);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_slli_si128 (__m128i __A, const int __N)\n{\n  return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);\n}\n#else\n#define _mm_bsrli_si128(A, N) \\\n  ((__m128i)__builtin_ia32_psrldqi128 ((__m128i)(A), (int)(N) * 8))\n#define _mm_bslli_si128(A, N) \\\n  ((__m128i)__builtin_ia32_pslldqi128 ((__m128i)(A), (int)(N) * 8))\n#define _mm_srli_si128(A, N) \\\n  ((__m128i)__builtin_ia32_psrldqi128 ((__m128i)(A), (int)(N) * 8))\n#define _mm_slli_si128(A, N) \\\n  ((__m128i)__builtin_ia32_pslldqi128 ((__m128i)(A), (int)(N) * 8))\n#endif\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srli_epi16 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psrlwi128 ((__v8hi)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srli_epi32 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psrldi128 ((__v4si)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srli_epi64 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psrlqi128 ((__v2di)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sll_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psllw128((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sll_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pslld128((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sll_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psllq128((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sra_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psraw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sra_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psrad128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srl_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psrlw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srl_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psrld128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srl_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psrlq128 ((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_and_si128 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A \u0026 (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_andnot_si128 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pandn128 ((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_or_si128 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A | (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_xor_si128 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A ^ (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qi)__A == (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hi)__A == (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4si)__A == (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qs)__A \u003c (__v16qs)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hi)__A \u003c (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4si)__A \u003c (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qs)__A \u003e (__v16qs)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hi)__A \u003e (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4si)__A \u003e (__v4si)__B);\n}\n\n#ifdef __OPTIMIZE__\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_extract_epi16 (__m128i const __A, int const __N)\n{\n  return (unsigned short) __builtin_ia32_vec_ext_v8hi ((__v8hi)__A, __N);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_insert_epi16 (__m128i const __A, int const __D, int const __N)\n{\n  return (__m128i) __builtin_ia32_vec_set_v8hi ((__v8hi)__A, __D, __N);\n}\n#else\n#define _mm_extract_epi16(A, N) \\\n  ((int) (unsigned short) __builtin_ia32_vec_ext_v8hi ((__v8hi)(__m128i)(A), (int)(N)))\n#define _mm_insert_epi16(A, D, N)\t\t\t\t\\\n  ((__m128i) __builtin_ia32_vec_set_v8hi ((__v8hi)(__m128i)(A),\t\\\n\t\t\t\t\t  (int)(D), (int)(N)))\n#endif\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmaxsw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmaxub128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pminsw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pminub128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movemask_epi8 (__m128i __A)\n{\n  return __builtin_ia32_pmovmskb128 ((__v16qi)__A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mulhi_epu16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmulhuw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\n#ifdef __OPTIMIZE__\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shufflehi_epi16 (__m128i __A, const int __mask)\n{\n  return (__m128i)__builtin_ia32_pshufhw ((__v8hi)__A, __mask);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shufflelo_epi16 (__m128i __A, const int __mask)\n{\n  return (__m128i)__builtin_ia32_pshuflw ((__v8hi)__A, __mask);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_epi32 (__m128i __A, const int __mask)\n{\n  return (__m128i)__builtin_ia32_pshufd ((__v4si)__A, __mask);\n}\n#else\n#define _mm_shufflehi_epi16(A, N) \\\n  ((__m128i)__builtin_ia32_pshufhw ((__v8hi)(__m128i)(A), (int)(N)))\n#define _mm_shufflelo_epi16(A, N) \\\n  ((__m128i)__builtin_ia32_pshuflw ((__v8hi)(__m128i)(A), (int)(N)))\n#define _mm_shuffle_epi32(A, N) \\\n  ((__m128i)__builtin_ia32_pshufd ((__v4si)(__m128i)(A), (int)(N)))\n#endif\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)\n{\n  __builtin_ia32_maskmovdqu ((__v16qi)__A, (__v16qi)__B, __C);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_avg_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pavgb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_avg_epu16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pavgw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sad_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psadbw128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_si32 (int *__A, int __B)\n{\n  __builtin_ia32_movnti (__A, __B);\n}\n\n#ifdef __x86_64__\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_si64 (long long int *__A, long long int __B)\n{\n  __builtin_ia32_movnti64 (__A, __B);\n}\n#endif\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_si128 (__m128i *__A, __m128i __B)\n{\n  __builtin_ia32_movntdq ((__v2di *)__A, (__v2di)__B);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_pd (double *__A, __m128d __B)\n{\n  __builtin_ia32_movntpd (__A, (__v2df)__B);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_clflush (void const *__A)\n{\n  __builtin_ia32_clflush (__A);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_lfence (void)\n{\n  __builtin_ia32_lfence ();\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mfence (void)\n{\n  __builtin_ia32_mfence ();\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi32_si128 (int __A)\n{\n  return _mm_set_epi32 (0, 0, 0, __A);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64_si128 (long long __A)\n{\n  return _mm_set_epi64x (0, __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64x_si128 (long long __A)\n{\n  return _mm_set_epi64x (0, __A);\n}\n#endif\n\n/* Casts between various SP, DP, INT vector types.  Note that these do no\n   conversion of values, they just change the type.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castpd_ps(__m128d __A)\n{\n  return (__m128) __A;\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castpd_si128(__m128d __A)\n{\n  return (__m128i) __A;\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castps_pd(__m128 __A)\n{\n  return (__m128d) __A;\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castps_si128(__m128 __A)\n{\n  return (__m128i) __A;\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castsi128_ps(__m128i __A)\n{\n  return (__m128) __A;\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castsi128_pd(__m128i __A)\n{\n  return (__m128d) __A;\n}\n\n#ifdef __DISABLE_SSE2__\n#undef __DISABLE_SSE2__\n#pragma GCC pop_options\n#endif /* __DISABLE_SSE2__ */\n\n#endif /* _EMMINTRIN_H_INCLUDED */\n","traces":[{"line":826,"address":[6106230,6106238,6106328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":970,"address":[6106350,6106370],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","usr","lib","gcc","x86_64-pc-linux-gnu","10.2.0","include","xmmintrin.h"],"content":"/* Copyright (C) 2002-2020 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   Under Section 7 of GPL version 3, you are granted additional\n   permissions described in the GCC Runtime Library Exception, version\n   3.1, as published by the Free Software Foundation.\n\n   You should have received a copy of the GNU General Public License and\n   a copy of the GCC Runtime Library Exception along with this program;\n   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   \u003chttp://www.gnu.org/licenses/\u003e.  */\n\n/* Implemented from the specification included in the Intel C++ Compiler\n   User Guide and Reference, version 9.0.  */\n\n#ifndef _XMMINTRIN_H_INCLUDED\n#define _XMMINTRIN_H_INCLUDED\n\n/* We need type definitions from the MMX header file.  */\n#include \u003cmmintrin.h\u003e\n\n/* Get _mm_malloc () and _mm_free ().  */\n#include \u003cmm_malloc.h\u003e\n\n/* Constants for use with _mm_prefetch.  */\nenum _mm_hint\n{\n  /* _MM_HINT_ET is _MM_HINT_T with set 3rd bit.  */\n  _MM_HINT_ET0 = 7,\n  _MM_HINT_ET1 = 6,\n  _MM_HINT_T0 = 3,\n  _MM_HINT_T1 = 2,\n  _MM_HINT_T2 = 1,\n  _MM_HINT_NTA = 0\n};\n\n/* Loads one cache line from address P to a location \"closer\" to the\n   processor.  The selector I specifies the type of prefetch operation.  */\n#ifdef __OPTIMIZE__\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_prefetch (const void *__P, enum _mm_hint __I)\n{\n  __builtin_prefetch (__P, (__I \u0026 0x4) \u003e\u003e 2, __I \u0026 0x3);\n}\n#else\n#define _mm_prefetch(P, I) \\\n  __builtin_prefetch ((P), ((I \u0026 0x4) \u003e\u003e 2), (I \u0026 0x3))\n#endif\n\n#ifndef __SSE__\n#pragma GCC push_options\n#pragma GCC target(\"sse\")\n#define __DISABLE_SSE__\n#endif /* __SSE__ */\n\n/* The Intel API is flexible enough that we must allow aliasing with other\n   vector types, and their scalar components.  */\ntypedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));\n\n/* Unaligned version of the same type.  */\ntypedef float __m128_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));\n\n/* Internal data types for implementing the intrinsics.  */\ntypedef float __v4sf __attribute__ ((__vector_size__ (16)));\n\n/* Create a selector for use with the SHUFPS instruction.  */\n#define _MM_SHUFFLE(fp3,fp2,fp1,fp0) \\\n (((fp3) \u003c\u003c 6) | ((fp2) \u003c\u003c 4) | ((fp1) \u003c\u003c 2) | (fp0))\n\n/* Bits in the MXCSR.  */\n#define _MM_EXCEPT_MASK       0x003f\n#define _MM_EXCEPT_INVALID    0x0001\n#define _MM_EXCEPT_DENORM     0x0002\n#define _MM_EXCEPT_DIV_ZERO   0x0004\n#define _MM_EXCEPT_OVERFLOW   0x0008\n#define _MM_EXCEPT_UNDERFLOW  0x0010\n#define _MM_EXCEPT_INEXACT    0x0020\n\n#define _MM_MASK_MASK         0x1f80\n#define _MM_MASK_INVALID      0x0080\n#define _MM_MASK_DENORM       0x0100\n#define _MM_MASK_DIV_ZERO     0x0200\n#define _MM_MASK_OVERFLOW     0x0400\n#define _MM_MASK_UNDERFLOW    0x0800\n#define _MM_MASK_INEXACT      0x1000\n\n#define _MM_ROUND_MASK        0x6000\n#define _MM_ROUND_NEAREST     0x0000\n#define _MM_ROUND_DOWN        0x2000\n#define _MM_ROUND_UP          0x4000\n#define _MM_ROUND_TOWARD_ZERO 0x6000\n\n#define _MM_FLUSH_ZERO_MASK   0x8000\n#define _MM_FLUSH_ZERO_ON     0x8000\n#define _MM_FLUSH_ZERO_OFF    0x0000\n\n/* Create an undefined vector.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_undefined_ps (void)\n{\n  __m128 __Y = __Y;\n  return __Y;\n}\n\n/* Create a vector of zeros.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setzero_ps (void)\n{\n  return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };\n}\n\n/* Perform the respective operation on the lower SPFP (single-precision\n   floating-point) values of A and B; the upper three SPFP values are\n   passed through from A.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_addss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_subss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_mulss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_div_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_divss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sqrt_ss (__m128 __A)\n{\n  return (__m128) __builtin_ia32_sqrtss ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_rcp_ss (__m128 __A)\n{\n  return (__m128) __builtin_ia32_rcpss ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_rsqrt_ss (__m128 __A)\n{\n  return (__m128) __builtin_ia32_rsqrtss ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_minss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_maxss ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Perform the respective operation on the four SPFP values in A and B.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) ((__v4sf)__A + (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) ((__v4sf)__A - (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) ((__v4sf)__A * (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_div_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) ((__v4sf)__A / (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sqrt_ps (__m128 __A)\n{\n  return (__m128) __builtin_ia32_sqrtps ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_rcp_ps (__m128 __A)\n{\n  return (__m128) __builtin_ia32_rcpps ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_rsqrt_ps (__m128 __A)\n{\n  return (__m128) __builtin_ia32_rsqrtps ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_minps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_maxps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Perform logical bit-wise operations on 128-bit values.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_and_ps (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_andps (__A, __B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_andnot_ps (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_andnps (__A, __B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_or_ps (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_orps (__A, __B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_xor_ps (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_xorps (__A, __B);\n}\n\n/* Perform a comparison on the lower SPFP values of A and B.  If the\n   comparison is true, place a mask of all ones in the result, otherwise a\n   mask of zeros.  The upper three SPFP values are passed through from A.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpeqss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpltss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmple_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpless ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n\t\t\t\t\t(__v4sf)\n\t\t\t\t\t__builtin_ia32_cmpltss ((__v4sf) __B,\n\t\t\t\t\t\t\t\t(__v4sf)\n\t\t\t\t\t\t\t\t__A));\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpge_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n\t\t\t\t\t(__v4sf)\n\t\t\t\t\t__builtin_ia32_cmpless ((__v4sf) __B,\n\t\t\t\t\t\t\t\t(__v4sf)\n\t\t\t\t\t\t\t\t__A));\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpneq_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpneqss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnlt_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpnltss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnle_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpnless ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpngt_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n\t\t\t\t\t(__v4sf)\n\t\t\t\t\t__builtin_ia32_cmpnltss ((__v4sf) __B,\n\t\t\t\t\t\t\t\t (__v4sf)\n\t\t\t\t\t\t\t\t __A));\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnge_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n\t\t\t\t\t(__v4sf)\n\t\t\t\t\t__builtin_ia32_cmpnless ((__v4sf) __B,\n\t\t\t\t\t\t\t\t (__v4sf)\n\t\t\t\t\t\t\t\t __A));\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpord_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpordss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpunord_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpunordss ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Perform a comparison on the four SPFP values of A and B.  For each\n   element, if the comparison is true, place a mask of all ones in the\n   result, otherwise a mask of zeros.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpeqps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpltps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmple_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpleps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpgtps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpge_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpgeps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpneq_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpneqps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnlt_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpnltps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnle_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpnleps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpngt_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpngtps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnge_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpngeps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpord_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpordps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpunord_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpunordps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Compare the lower SPFP values of A and B and return 1 if true\n   and 0 if false.  */\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comieq_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comieq ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comilt_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comilt ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comile_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comile ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comigt_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comigt ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comige_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comige ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comineq_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comineq ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomieq_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomieq ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomilt_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomilt ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomile_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomile ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomigt_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomigt ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomige_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomige ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomineq_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomineq ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Convert the lower SPFP value to a 32-bit integer according to the current\n   rounding mode.  */\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_si32 (__m128 __A)\n{\n  return __builtin_ia32_cvtss2si ((__v4sf) __A);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvt_ss2si (__m128 __A)\n{\n  return _mm_cvtss_si32 (__A);\n}\n\n#ifdef __x86_64__\n/* Convert the lower SPFP value to a 32-bit integer according to the\n   current rounding mode.  */\n\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_si64 (__m128 __A)\n{\n  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_si64x (__m128 __A)\n{\n  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);\n}\n#endif\n\n/* Convert the two lower SPFP values to 32-bit integers according to the\n   current rounding mode.  Return the integers in packed form.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_pi32 (__m128 __A)\n{\n  return (__m64) __builtin_ia32_cvtps2pi ((__v4sf) __A);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvt_ps2pi (__m128 __A)\n{\n  return _mm_cvtps_pi32 (__A);\n}\n\n/* Truncate the lower SPFP value to a 32-bit integer.  */\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttss_si32 (__m128 __A)\n{\n  return __builtin_ia32_cvttss2si ((__v4sf) __A);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtt_ss2si (__m128 __A)\n{\n  return _mm_cvttss_si32 (__A);\n}\n\n#ifdef __x86_64__\n/* Truncate the lower SPFP value to a 32-bit integer.  */\n\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttss_si64 (__m128 __A)\n{\n  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttss_si64x (__m128 __A)\n{\n  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);\n}\n#endif\n\n/* Truncate the two lower SPFP values to 32-bit integers.  Return the\n   integers in packed form.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttps_pi32 (__m128 __A)\n{\n  return (__m64) __builtin_ia32_cvttps2pi ((__v4sf) __A);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtt_ps2pi (__m128 __A)\n{\n  return _mm_cvttps_pi32 (__A);\n}\n\n/* Convert B to a SPFP value and insert it as element zero in A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi32_ss (__m128 __A, int __B)\n{\n  return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvt_si2ss (__m128 __A, int __B)\n{\n  return _mm_cvtsi32_ss (__A, __B);\n}\n\n#ifdef __x86_64__\n/* Convert B to a SPFP value and insert it as element zero in A.  */\n\n/* Intel intrinsic.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64_ss (__m128 __A, long long __B)\n{\n  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64x_ss (__m128 __A, long long __B)\n{\n  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);\n}\n#endif\n\n/* Convert the two 32-bit values in B to SPFP form and insert them\n   as the two lower elements in A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi32_ps (__m128 __A, __m64 __B)\n{\n  return (__m128) __builtin_ia32_cvtpi2ps ((__v4sf) __A, (__v2si)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvt_pi2ps (__m128 __A, __m64 __B)\n{\n  return _mm_cvtpi32_ps (__A, __B);\n}\n\n/* Convert the four signed 16-bit values in A to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi16_ps (__m64 __A)\n{\n  __v4hi __sign;\n  __v2si __hisi, __losi;\n  __v4sf __zero, __ra, __rb;\n\n  /* This comparison against zero gives us a mask that can be used to\n     fill in the missing sign bits in the unpack operations below, so\n     that we get signed values after unpacking.  */\n  __sign = __builtin_ia32_pcmpgtw ((__v4hi)0LL, (__v4hi)__A);\n\n  /* Convert the four words to doublewords.  */\n  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);\n  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);\n\n  /* Convert the doublewords to floating point two at a time.  */\n  __zero = (__v4sf) _mm_setzero_ps ();\n  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);\n  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);\n\n  return (__m128) __builtin_ia32_movlhps (__ra, __rb);\n}\n\n/* Convert the four unsigned 16-bit values in A to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpu16_ps (__m64 __A)\n{\n  __v2si __hisi, __losi;\n  __v4sf __zero, __ra, __rb;\n\n  /* Convert the four words to doublewords.  */\n  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);\n  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, (__v4hi)0LL);\n\n  /* Convert the doublewords to floating point two at a time.  */\n  __zero = (__v4sf) _mm_setzero_ps ();\n  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);\n  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);\n\n  return (__m128) __builtin_ia32_movlhps (__ra, __rb);\n}\n\n/* Convert the low four signed 8-bit values in A to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi8_ps (__m64 __A)\n{\n  __v8qi __sign;\n\n  /* This comparison against zero gives us a mask that can be used to\n     fill in the missing sign bits in the unpack operations below, so\n     that we get signed values after unpacking.  */\n  __sign = __builtin_ia32_pcmpgtb ((__v8qi)0LL, (__v8qi)__A);\n\n  /* Convert the four low bytes to words.  */\n  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __sign);\n\n  return _mm_cvtpi16_ps(__A);\n}\n\n/* Convert the low four unsigned 8-bit values in A to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpu8_ps(__m64 __A)\n{\n  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, (__v8qi)0LL);\n  return _mm_cvtpu16_ps(__A);\n}\n\n/* Convert the four signed 32-bit values in A and B to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi32x2_ps(__m64 __A, __m64 __B)\n{\n  __v4sf __zero = (__v4sf) _mm_setzero_ps ();\n  __v4sf __sfa = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__A);\n  __v4sf __sfb = __builtin_ia32_cvtpi2ps (__sfa, (__v2si)__B);\n  return (__m128) __builtin_ia32_movlhps (__sfa, __sfb);\n}\n\n/* Convert the four SPFP values in A to four signed 16-bit integers.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_pi16(__m128 __A)\n{\n  __v4sf __hisf = (__v4sf)__A;\n  __v4sf __losf = __builtin_ia32_movhlps (__hisf, __hisf);\n  __v2si __hisi = __builtin_ia32_cvtps2pi (__hisf);\n  __v2si __losi = __builtin_ia32_cvtps2pi (__losf);\n  return (__m64) __builtin_ia32_packssdw (__hisi, __losi);\n}\n\n/* Convert the four SPFP values in A to four signed 8-bit integers.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_pi8(__m128 __A)\n{\n  __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);\n  return (__m64) __builtin_ia32_packsswb (__tmp, (__v4hi)0LL);\n}\n\n/* Selects four specific SPFP values from A and B based on MASK.  */\n#ifdef __OPTIMIZE__\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_ps (__m128 __A, __m128 __B, int const __mask)\n{\n  return (__m128) __builtin_ia32_shufps ((__v4sf)__A, (__v4sf)__B, __mask);\n}\n#else\n#define _mm_shuffle_ps(A, B, MASK)\t\t\t\t\t\\\n  ((__m128) __builtin_ia32_shufps ((__v4sf)(__m128)(A),\t\t\t\\\n\t\t\t\t   (__v4sf)(__m128)(B), (int)(MASK)))\n#endif\n\n/* Selects and interleaves the upper two SPFP values from A and B.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_unpckhps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Selects and interleaves the lower two SPFP values from A and B.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_unpcklps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Sets the upper two SPFP values with 64-bits of data loaded from P;\n   the lower two values are passed through from A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadh_pi (__m128 __A, __m64 const *__P)\n{\n  return (__m128) __builtin_ia32_loadhps ((__v4sf)__A, (const __v2sf *)__P);\n}\n\n/* Stores the upper two SPFP values of A into P.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeh_pi (__m64 *__P, __m128 __A)\n{\n  __builtin_ia32_storehps ((__v2sf *)__P, (__v4sf)__A);\n}\n\n/* Moves the upper two values of B into the lower two values of A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movehl_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movhlps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Moves the lower two values of B into the upper two values of A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movelh_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movlhps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Sets the lower two SPFP values with 64-bits of data loaded from P;\n   the upper two values are passed through from A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadl_pi (__m128 __A, __m64 const *__P)\n{\n  return (__m128) __builtin_ia32_loadlps ((__v4sf)__A, (const __v2sf *)__P);\n}\n\n/* Stores the lower two SPFP values of A into P.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storel_pi (__m64 *__P, __m128 __A)\n{\n  __builtin_ia32_storelps ((__v2sf *)__P, (__v4sf)__A);\n}\n\n/* Creates a 4-bit mask from the most significant bits of the SPFP values.  */\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movemask_ps (__m128 __A)\n{\n  return __builtin_ia32_movmskps ((__v4sf)__A);\n}\n\n/* Return the contents of the control register.  */\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_getcsr (void)\n{\n  return __builtin_ia32_stmxcsr ();\n}\n\n/* Read exception bits from the control register.  */\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_GET_EXCEPTION_STATE (void)\n{\n  return _mm_getcsr() \u0026 _MM_EXCEPT_MASK;\n}\n\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_GET_EXCEPTION_MASK (void)\n{\n  return _mm_getcsr() \u0026 _MM_MASK_MASK;\n}\n\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_GET_ROUNDING_MODE (void)\n{\n  return _mm_getcsr() \u0026 _MM_ROUND_MASK;\n}\n\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_GET_FLUSH_ZERO_MODE (void)\n{\n  return _mm_getcsr() \u0026 _MM_FLUSH_ZERO_MASK;\n}\n\n/* Set the control register to I.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setcsr (unsigned int __I)\n{\n  __builtin_ia32_ldmxcsr (__I);\n}\n\n/* Set exception bits in the control register.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_SET_EXCEPTION_STATE(unsigned int __mask)\n{\n  _mm_setcsr((_mm_getcsr() \u0026 ~_MM_EXCEPT_MASK) | __mask);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_SET_EXCEPTION_MASK (unsigned int __mask)\n{\n  _mm_setcsr((_mm_getcsr() \u0026 ~_MM_MASK_MASK) | __mask);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_SET_ROUNDING_MODE (unsigned int __mode)\n{\n  _mm_setcsr((_mm_getcsr() \u0026 ~_MM_ROUND_MASK) | __mode);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)\n{\n  _mm_setcsr((_mm_getcsr() \u0026 ~_MM_FLUSH_ZERO_MASK) | __mode);\n}\n\n/* Create a vector with element 0 as F and the rest zero.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_ss (float __F)\n{\n  return __extension__ (__m128)(__v4sf){ __F, 0.0f, 0.0f, 0.0f };\n}\n\n/* Create a vector with all four elements equal to F.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_ps (float __F)\n{\n  return __extension__ (__m128)(__v4sf){ __F, __F, __F, __F };\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_ps1 (float __F)\n{\n  return _mm_set1_ps (__F);\n}\n\n/* Create a vector with element 0 as *P and the rest zero.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_ss (float const *__P)\n{\n  return _mm_set_ss (*__P);\n}\n\n/* Create a vector with all four elements equal to *P.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load1_ps (float const *__P)\n{\n  return _mm_set1_ps (*__P);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_ps1 (float const *__P)\n{\n  return _mm_load1_ps (__P);\n}\n\n/* Load four SPFP values from P.  The address must be 16-byte aligned.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_ps (float const *__P)\n{\n  return *(__m128 *)__P;\n}\n\n/* Load four SPFP values from P.  The address need not be 16-byte aligned.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadu_ps (float const *__P)\n{\n  return *(__m128_u *)__P;\n}\n\n/* Load four SPFP values in reverse order.  The address must be aligned.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadr_ps (float const *__P)\n{\n  __v4sf __tmp = *(__v4sf *)__P;\n  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, _MM_SHUFFLE (0,1,2,3));\n}\n\n/* Create the vector [Z Y X W].  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)\n{\n  return __extension__ (__m128)(__v4sf){ __W, __X, __Y, __Z };\n}\n\n/* Create the vector [W X Y Z].  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_ps (float __Z, float __Y, float __X, float __W)\n{\n  return __extension__ (__m128)(__v4sf){ __Z, __Y, __X, __W };\n}\n\n/* Stores the lower SPFP value.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_ss (float *__P, __m128 __A)\n{\n  *__P = ((__v4sf)__A)[0];\n}\n\nextern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_f32 (__m128 __A)\n{\n  return ((__v4sf)__A)[0];\n}\n\n/* Store four SPFP values.  The address must be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_ps (float *__P, __m128 __A)\n{\n  *(__m128 *)__P = __A;\n}\n\n/* Store four SPFP values.  The address need not be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeu_ps (float *__P, __m128 __A)\n{\n  *(__m128_u *)__P = __A;\n}\n\n/* Store the lower SPFP value across four words.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store1_ps (float *__P, __m128 __A)\n{\n  __v4sf __va = (__v4sf)__A;\n  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,0,0,0));\n  _mm_storeu_ps (__P, __tmp);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_ps1 (float *__P, __m128 __A)\n{\n  _mm_store1_ps (__P, __A);\n}\n\n/* Store four SPFP values in reverse order.  The address must be aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storer_ps (float *__P, __m128 __A)\n{\n  __v4sf __va = (__v4sf)__A;\n  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,1,2,3));\n  _mm_store_ps (__P, __tmp);\n}\n\n/* Sets the low SPFP value of A from the low value of B.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_move_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_shuffle ((__v4sf)__A, (__v4sf)__B,\n                                     __extension__\n                                     (__attribute__((__vector_size__ (16))) int)\n                                     {4,1,2,3});\n}\n\n/* Extracts one of the four words of A.  The selector N must be immediate.  */\n#ifdef __OPTIMIZE__\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_extract_pi16 (__m64 const __A, int const __N)\n{\n  return __builtin_ia32_vec_ext_v4hi ((__v4hi)__A, __N);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pextrw (__m64 const __A, int const __N)\n{\n  return _mm_extract_pi16 (__A, __N);\n}\n#else\n#define _mm_extract_pi16(A, N)\t\\\n  ((int) __builtin_ia32_vec_ext_v4hi ((__v4hi)(__m64)(A), (int)(N)))\n\n#define _m_pextrw(A, N) _mm_extract_pi16(A, N)\n#endif\n\n/* Inserts word D into one of four words of A.  The selector N must be\n   immediate.  */\n#ifdef __OPTIMIZE__\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_insert_pi16 (__m64 const __A, int const __D, int const __N)\n{\n  return (__m64) __builtin_ia32_vec_set_v4hi ((__v4hi)__A, __D, __N);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pinsrw (__m64 const __A, int const __D, int const __N)\n{\n  return _mm_insert_pi16 (__A, __D, __N);\n}\n#else\n#define _mm_insert_pi16(A, D, N)\t\t\t\t\\\n  ((__m64) __builtin_ia32_vec_set_v4hi ((__v4hi)(__m64)(A),\t\\\n\t\t\t\t\t(int)(D), (int)(N)))\n\n#define _m_pinsrw(A, D, N) _mm_insert_pi16(A, D, N)\n#endif\n\n/* Compute the element-wise maximum of signed 16-bit values.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_pi16 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pmaxsw ((__v4hi)__A, (__v4hi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pmaxsw (__m64 __A, __m64 __B)\n{\n  return _mm_max_pi16 (__A, __B);\n}\n\n/* Compute the element-wise maximum of unsigned 8-bit values.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_pu8 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pmaxub ((__v8qi)__A, (__v8qi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pmaxub (__m64 __A, __m64 __B)\n{\n  return _mm_max_pu8 (__A, __B);\n}\n\n/* Compute the element-wise minimum of signed 16-bit values.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_pi16 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pminsw ((__v4hi)__A, (__v4hi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pminsw (__m64 __A, __m64 __B)\n{\n  return _mm_min_pi16 (__A, __B);\n}\n\n/* Compute the element-wise minimum of unsigned 8-bit values.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_pu8 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pminub ((__v8qi)__A, (__v8qi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pminub (__m64 __A, __m64 __B)\n{\n  return _mm_min_pu8 (__A, __B);\n}\n\n/* Create an 8-bit mask of the signs of 8-bit values.  */\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movemask_pi8 (__m64 __A)\n{\n  return __builtin_ia32_pmovmskb ((__v8qi)__A);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pmovmskb (__m64 __A)\n{\n  return _mm_movemask_pi8 (__A);\n}\n\n/* Multiply four unsigned 16-bit values in A by four unsigned 16-bit values\n   in B and produce the high 16 bits of the 32-bit results.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mulhi_pu16 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pmulhuw ((__v4hi)__A, (__v4hi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pmulhuw (__m64 __A, __m64 __B)\n{\n  return _mm_mulhi_pu16 (__A, __B);\n}\n\n/* Return a combination of the four 16-bit values in A.  The selector\n   must be an immediate.  */\n#ifdef __OPTIMIZE__\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_pi16 (__m64 __A, int const __N)\n{\n  return (__m64) __builtin_ia32_pshufw ((__v4hi)__A, __N);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pshufw (__m64 __A, int const __N)\n{\n  return _mm_shuffle_pi16 (__A, __N);\n}\n#else\n#define _mm_shuffle_pi16(A, N) \\\n  ((__m64) __builtin_ia32_pshufw ((__v4hi)(__m64)(A), (int)(N)))\n\n#define _m_pshufw(A, N) _mm_shuffle_pi16 (A, N)\n#endif\n\n/* Conditionally store byte elements of A into P.  The high bit of each\n   byte in the selector N determines whether the corresponding byte from\n   A is stored.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)\n{\n#ifdef __MMX_WITH_SSE__\n  /* Emulate MMX maskmovq with SSE2 maskmovdqu and handle unmapped bits\n     64:127 at address __P.  */\n  typedef long long __v2di __attribute__ ((__vector_size__ (16)));\n  typedef char __v16qi __attribute__ ((__vector_size__ (16)));\n  /* Zero-extend __A and __N to 128 bits.  */\n  __v2di __A128 = __extension__ (__v2di) { ((__v1di) __A)[0], 0 };\n  __v2di __N128 = __extension__ (__v2di) { ((__v1di) __N)[0], 0 };\n\n  /* Check the alignment of __P.  */\n  __SIZE_TYPE__ offset = ((__SIZE_TYPE__) __P) \u0026 0xf;\n  if (offset)\n    {\n      /* If the misalignment of __P \u003e 8, subtract __P by 8 bytes.\n\t Otherwise, subtract __P by the misalignment.  */\n      if (offset \u003e 8)\n\toffset = 8;\n      __P = (char *) (((__SIZE_TYPE__) __P) - offset);\n\n      /* Shift __A128 and __N128 to the left by the adjustment.  */\n      switch (offset)\n\t{\n\tcase 1:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 8);\n\t  break;\n\tcase 2:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 2 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 2 * 8);\n\t  break;\n\tcase 3:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 3 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 3 * 8);\n\t  break;\n\tcase 4:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 4 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 4 * 8);\n\t  break;\n\tcase 5:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 5 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 5 * 8);\n\t  break;\n\tcase 6:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 6 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 6 * 8);\n\t  break;\n\tcase 7:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 7 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 7 * 8);\n\t  break;\n\tcase 8:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 8 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 8 * 8);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n  __builtin_ia32_maskmovdqu ((__v16qi)__A128, (__v16qi)__N128, __P);\n#else\n  __builtin_ia32_maskmovq ((__v8qi)__A, (__v8qi)__N, __P);\n#endif\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_maskmovq (__m64 __A, __m64 __N, char *__P)\n{\n  _mm_maskmove_si64 (__A, __N, __P);\n}\n\n/* Compute the rounded averages of the unsigned 8-bit values in A and B.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_avg_pu8 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pavgb ((__v8qi)__A, (__v8qi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pavgb (__m64 __A, __m64 __B)\n{\n  return _mm_avg_pu8 (__A, __B);\n}\n\n/* Compute the rounded averages of the unsigned 16-bit values in A and B.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_avg_pu16 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pavgw ((__v4hi)__A, (__v4hi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pavgw (__m64 __A, __m64 __B)\n{\n  return _mm_avg_pu16 (__A, __B);\n}\n\n/* Compute the sum of the absolute differences of the unsigned 8-bit\n   values in A and B.  Return the value in the lower 16-bit word; the\n   upper words are cleared.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sad_pu8 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_psadbw ((__v8qi)__A, (__v8qi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_psadbw (__m64 __A, __m64 __B)\n{\n  return _mm_sad_pu8 (__A, __B);\n}\n\n/* Stores the data in A to the address P without polluting the caches.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_pi (__m64 *__P, __m64 __A)\n{\n  __builtin_ia32_movntq ((unsigned long long *)__P, (unsigned long long)__A);\n}\n\n/* Likewise.  The address must be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_ps (float *__P, __m128 __A)\n{\n  __builtin_ia32_movntps (__P, (__v4sf)__A);\n}\n\n/* Guarantees that every preceding store is globally visible before\n   any subsequent store.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sfence (void)\n{\n  __builtin_ia32_sfence ();\n}\n\n/* Transpose the 4x4 matrix composed of row[0-3].  */\n#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  __v4sf __r0 = (row0), __r1 = (row1), __r2 = (row2), __r3 = (row3);\t\\\n  __v4sf __t0 = __builtin_ia32_unpcklps (__r0, __r1);\t\t\t\\\n  __v4sf __t1 = __builtin_ia32_unpcklps (__r2, __r3);\t\t\t\\\n  __v4sf __t2 = __builtin_ia32_unpckhps (__r0, __r1);\t\t\t\\\n  __v4sf __t3 = __builtin_ia32_unpckhps (__r2, __r3);\t\t\t\\\n  (row0) = __builtin_ia32_movlhps (__t0, __t1);\t\t\t\t\\\n  (row1) = __builtin_ia32_movhlps (__t1, __t0);\t\t\t\t\\\n  (row2) = __builtin_ia32_movlhps (__t2, __t3);\t\t\t\t\\\n  (row3) = __builtin_ia32_movhlps (__t3, __t2);\t\t\t\t\\\n} while (0)\n\n/* For backward source compatibility.  */\n# include \u003cemmintrin.h\u003e\n\n#ifdef __DISABLE_SSE__\n#undef __DISABLE_SSE__\n#pragma GCC pop_options\n#endif /* __DISABLE_SSE__ */\n\n/* The execution of the next instruction is delayed by an implementation\n   specific amount of time.  The instruction does not modify the\n   architectural state.  This is after the pop_options pragma because\n   it does not require SSE support in the processor--the encoding is a\n   nop on processors that do not support it.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_pause (void)\n{\n  __builtin_ia32_pause ();\n}\n\n#endif /* _XMMINTRIN_H_INCLUDED */\n","traces":[{"line":186,"address":[6123380,6121094,6128520,6121143,6121390,6119565,6130074,6121791,6120996,6115742,6120143,6123630,6123893,6121997,6127295,6127813,6129556,6124004,6126865,6120702,6123108,6129038,6129885,6120604,6124165,6130592,6128849,6122422,6120898,6122845,6123219,6121547,6128331,6113197,6121310,6120800,6119614,6121467,6115283,6122192,6123763,6127484,6128002,6129367,6110650,6122077,6130403,6122978,6119934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[9004428,8995462,8995155,8985633,8995756,8995658,8997214,8996133,8995560,9003910,8997444,8987948,8994764,9002356,8996855,8997559,8994953,8990309,8990479,8996590,8996806,9004946,8995854,9003392,9005464,8995952,9001873,8994627,9002874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[6097877,6102350,6104828,6103946,6105346,6097647,6102910,6096796,6103428,6102433,6104464,6097287,6088661,6090750,6103792,6096949,6104982,6095616,6095279,6097395,6097992,6088526,6102756,6091203,6097106,6104310,6095416,6098107,6098222,6103274,6090863,6097179,6106018,6097762,6091033,6105864,6105500,6095820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[9005667,9005555,9005569,9005653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[13492928,13493040,13492942,13493026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[6123017,6122911,6123260,6123337,6123471,6123520,6123419,6123149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[6098808,6099019,6098967,6098885,6099068,6098697,6098459,6098565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[6114264,6120053,6122174,6119535,6111814,6113347,6121138,6114609,6119066,6112205,6120571,6114149,6114034,6118620,6119584,6121656,6113504,6121607,6114494,6119017,6113612,6113183,6113720,6122125,6120102,6120620,6118669,6111677,6114379,6112003,6121089,6113828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[6105245,6090711,6094985,6095051,6088362,6090503,6094923,6090456,6102255,6102311,6090657,6105763,6102711,6103173,6104783,6102655,6086151,6090607,6104209,6104265,6090553,6104727,6103747,6090409,6088303,6094857,6103691,6088412,6103229,6105301,6105819,6086104,6088462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[6088621,6099465,6086302,6099333,6099836,6099735,6086226,6099653,6091361,6088816,6090987,6099227,6091157,6099576,6099787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[6099853,6086316,6088635,6099670,6091174,6099804,6099350,6088833,6099244,6086240,6099482,6091004,6099593,6091378,6099752],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11}]};
        var previousData = {"files":[{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","audiolib.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::track::Track;\n\npub(crate) trait AudioLib {\n    fn play(\u0026self, track: \u0026Track) -\u003e Result\u003c(), Error\u003e;\n    fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn is_playing(\u0026self) -\u003e bool;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","error.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\n/// Media player errors.\n///\n/// Defines all runtime errors.\n#[derive(Debug, PartialEq)]\npub enum Error {\n    /// Audio library  error.\n    ///\n    /// Returned whenever there was an error raised by the underlying audio library.\n    AudioLibError(String),\n    /// IO error.\n    ///\n    /// Returned whenever there was a file access error.\n    IoError(String),\n}\n\nimpl From\u003cstd::io::Error\u003e for Error {\n    fn from(error: std::io::Error) -\u003e Self {\n        Error::IoError(format!(\"{}\", error))\n    }\n}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\nimpl std::error::Error for Error {}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let error = Error::AudioLibError(String::from(\"test\"));\n        let formatted_string = format!(\"{}\", error);\n        assert_eq!(\"AudioLibError(\\\"test\\\")\", formatted_string);\n    }\n\n    #[test]\n    fn test_from_io_error() {\n        let result = std::fs::File::open(\"non_existing_file\");\n        let io_error = result.unwrap_err();\n        let error = Error::from(io_error);\n        assert_eq!(\n            Error::IoError(String::from(\"No such file or directory (os error 2)\")),\n            error\n        );\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","lib.rs"],"content":"//! Crate for playing audio files.\n//!\n//! The [`MediaPlayer`](crate::MediaPlayer) can simply be\n//! [`open`](crate::open)ed but may result in an error.\n//!\n//! # Example\n//!\n//! ```rust\n//! use media_player::{open, MediaPlayer, Track};\n//!\n//! // get media_player trait object\n//! let mut media_player = open().unwrap();\n//!\n//! // create Track from String or \u0026str\n//! let track = Track::from(\"tests/rand1.wav\");\n//!\n//! // play the track\n//! media_player.play(\u0026track).unwrap();\n//!\n//! // ...\n//!\n//! // if you play a new track, the old one is stopped\n//! let track2 = Track::from(\"tests/rand2.wav\");\n//! media_player.play(\u0026track2).unwrap();\n//!\n//! // ...\n//!\n//! // you can also stop the playing of the track\n//! media_player.stop().unwrap();\n//! ```\n#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nmod audiolib;\nmod error;\nmod mediaplayer;\nmod track;\n\nmod rodiolib;\n\npub use error::Error;\npub use mediaplayer::MediaPlayer;\npub use track::Track;\n\n/// Opens the [`MediaPlayer`](crate::MediaPlayer), can result in an Error.\n///\n/// Returns an [`AudioLibError`](crate::Error::AudioLibError) if there was\n/// an error raised in the underlying audio library.\npub fn open() -\u003e Result\u003cimpl MediaPlayer, Error\u003e {\n    let audiolib = rodiolib::open()?;\n    mediaplayer::open(audiolib)\n}\n","traces":[{"line":50,"address":[4629808,4630472],"length":1,"stats":{"Line":1},"fn_name":"open"},{"line":51,"address":[4630273,4629818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[4630135],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","mediaplayer.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::audiolib::AudioLib;\nuse crate::error::Error;\nuse crate::track::Track;\n/// The [`MediaPlayer`](crate::MediaPlayer) trait.\n///\n/// Enables playing tracks and stopping the playback.\n/// When a new track is played, the playback of the old one is stopped (if still playing).\npub trait MediaPlayer {\n    /// Plays the [`Track`].\n    ///\n    /// Results in an [`IoError`](crate::Error::IoError) if the file does not exist (or any other possible file access error).\n    /// Results in an [`AudioLibError`](crate::Error::AudioLibError) if there was an error raised by the underlying audio library.\n    fn play(\u0026mut self, track: \u0026Track) -\u003e Result\u003c(), Error\u003e;\n\n    /// Stops the playback.\n    ///\n    /// Results in an [`AudioLibError`](crate::Error::AudioLibError) if there was an error raised by the underlying audio library.\n    fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n}\n\nstruct MediaPlayerImplementation\u003cT: AudioLib\u003e {\n    last_track: Option\u003cTrack\u003e,\n    audio_lib: T,\n}\n\nimpl\u003cT: AudioLib\u003e MediaPlayer for MediaPlayerImplementation\u003cT\u003e {\n    fn play(\u0026mut self, track: \u0026Track) -\u003e Result\u003c(), Error\u003e {\n        if let Some(last_track) = \u0026self.last_track {\n            if last_track != track {\n                self.audio_lib.stop()?;\n                self.audio_lib.play(\u0026track)?;\n                self.last_track = Some(track.clone());\n            } else {\n                if !self.audio_lib.is_playing() {\n                    self.audio_lib.play(\u0026track)?;\n                }\n            }\n        } else {\n            self.audio_lib.play(\u0026track)?;\n            self.last_track = Some(track.clone());\n        }\n        Ok(())\n    }\n\n    fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.last_track = None;\n        self.audio_lib.stop()\n    }\n}\n\nimpl\u003cT: AudioLib\u003e MediaPlayerImplementation\u003cT\u003e {\n    fn from(audio_lib: T) -\u003e Result\u003cSelf, Error\u003e {\n        Ok(MediaPlayerImplementation {\n            last_track: None,\n            audio_lib: audio_lib,\n        })\n    }\n}\n\npub(crate) fn open\u003cT: AudioLib\u003e(audio_lib: T) -\u003e Result\u003cimpl MediaPlayer, Error\u003e {\n    MediaPlayerImplementation::from(audio_lib)\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    struct DummyAudioLib;\n    impl AudioLib for DummyAudioLib {\n        fn play(\u0026self, _track: \u0026Track) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn is_playing(\u0026self) -\u003e bool {\n            false\n        }\n    }\n\n    #[test]\n    fn test_play() {\n        let mut media_player = MediaPlayerImplementation::from(DummyAudioLib).unwrap();\n        let result = media_player.play(\u0026\"/path/to/track\".into());\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_new_song_interrupts_old() {\n        let mut media_player = MediaPlayerImplementation::from(DummyAudioLib).unwrap();\n        media_player.play(\u0026\"/path/to/track/1\".into()).unwrap();\n        media_player.play(\u0026\"song2\".into()).unwrap();\n        assert_eq!(media_player.last_track, Some(Track::from(\"song2\")));\n    }\n\n    #[test]\n    fn test_old_song_is_played_again() {\n        let mut media_player = MediaPlayerImplementation::from(DummyAudioLib).unwrap();\n        media_player\n            .play(\u0026String::from(\"/path/to/track/1\").into())\n            .unwrap();\n        media_player.play(\u0026\"/path/to/track/1\".into()).unwrap();\n        assert_eq!(\n            media_player.last_track,\n            Some(Track::from(\"/path/to/track/1\"))\n        );\n    }\n}\n","traces":[{"line":31,"address":[4599200,4600496],"length":1,"stats":{"Line":3},"fn_name":"play\u003cmedia_player::mediaplayer::tests::DummyAudioLib\u003e"},{"line":32,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":33,"address":[4252563,4251671,4252988],"length":1,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[4251734,4251830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[4251994,4251797,4252064],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[4599856,4599659,4600511],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[4599991,4599907,4599346],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[4251628,4252570,4252640],"length":1,"stats":{"Line":6},"fn_name":null},{"line":44,"address":[4252617,4252813,4252993],"length":1,"stats":{"Line":6},"fn_name":null},{"line":46,"address":[4252865],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[4253120,4253196],"length":1,"stats":{"Line":1},"fn_name":"stop\u003cmedia_player::rodiolib::RodioLib\u003e"},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[4600832,4600736],"length":1,"stats":{"Line":3},"fn_name":"from\u003cmedia_player::mediaplayer::tests::DummyAudioLib\u003e"},{"line":57,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[4601040],"length":1,"stats":{"Line":1},"fn_name":"open\u003cmedia_player::rodiolib::RodioLib\u003e"},{"line":65,"address":[4601050],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","rodiolib","mod.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse rodio::{OutputStream, OutputStreamHandle, Sink};\n\nuse std::fs::File;\nuse std::io::BufReader;\n\nuse crate::audiolib::AudioLib;\nuse crate::error::Error;\nuse crate::track::Track;\n\nstruct RodioLib {\n    sink: Sink,\n    stream: OutputStream,\n    stream_handle: OutputStreamHandle,\n}\n\nfn create_new_triple() -\u003e Result\u003c(Sink, OutputStream, OutputStreamHandle), Error\u003e {\n    let (stream, stream_handle) = OutputStream::try_default().unwrap();\n    let sink = Sink::try_new(\u0026stream_handle)?;\n    Ok((sink, stream, stream_handle))\n}\n\nimpl RodioLib {\n    fn new() -\u003e Result\u003cSelf, Error\u003e {\n        let (sink, stream, stream_handle) = create_new_triple()?;\n\n        Ok(RodioLib {\n            sink: sink,\n            stream: stream,\n            stream_handle: stream_handle,\n        })\n    }\n}\n\nimpl AudioLib for RodioLib {\n    fn play(\u0026self, track: \u0026Track) -\u003e Result\u003c(), Error\u003e {\n        let file = File::open(track)?;\n        let source = rodio::Decoder::new(BufReader::new(file))?;\n        self.sink.append(source);\n        self.sink.play();\n        Ok(())\n    }\n    fn stop(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.sink.stop();\n        let (sink, stream, stream_handle) = create_new_triple()?;\n        self.sink = sink;\n        self.stream = stream;\n        self.stream_handle = stream_handle;\n        Ok(())\n    }\n    fn is_playing(\u0026self) -\u003e bool {\n        !self.sink.empty()\n    }\n}\n\npub(crate) fn open() -\u003e Result\u003cimpl AudioLib, Error\u003e {\n    RodioLib::new()\n}\n\nimpl From\u003crodio::PlayError\u003e for Error {\n    fn from(error: rodio::PlayError) -\u003e Self {\n        Error::AudioLibError(format!(\"{}\", error))\n    }\n}\n\nimpl From\u003crodio::StreamError\u003e for Error {\n    fn from(error: rodio::StreamError) -\u003e Self {\n        Error::AudioLibError(format!(\"{}\", error))\n    }\n}\n\nimpl From\u003crodio::DevicesError\u003e for Error {\n    fn from(error: rodio::DevicesError) -\u003e Self {\n        Error::AudioLibError(format!(\"{}\", error))\n    }\n}\n\nimpl From\u003crodio::decoder::DecoderError\u003e for Error {\n    fn from(error: rodio::decoder::DecoderError) -\u003e Self {\n        Error::AudioLibError(format!(\"{}\", error))\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use std::time::Duration;\n\n    use super::*;\n\n    #[test]\n    fn test_create_triple() {\n        let result = create_new_triple();\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_is_playing() {\n        let mut rodio_lib = open().unwrap();\n        let is_playing = rodio_lib.is_playing();\n        assert_eq!(false, is_playing);\n\n        let track = Track::from(\"tests/rand1.wav\");\n        rodio_lib.play(\u0026track).unwrap();\n        assert_eq!(true, rodio_lib.is_playing());\n\n        rodio_lib.stop().unwrap();\n        assert_eq!(false, rodio_lib.is_playing());\n    }\n\n    #[test]\n    #[ignore = \"Test of correct usage of rodio\"]\n    fn test_is_playing_to_the_end() {\n        let mut rodio_lib = open().unwrap();\n        let is_playing = rodio_lib.is_playing();\n        assert_eq!(false, is_playing);\n\n        let track = Track::from(\"tests/rand1.wav\");\n        rodio_lib.play(\u0026track).unwrap();\n        assert_eq!(true, rodio_lib.is_playing());\n\n        for i in 0..32 {\n            std::thread::sleep(Duration::from_secs(1));\n            println!(\"Time elapsed: {} s\", i + 1);\n            assert_eq!(true, rodio_lib.is_playing());\n        }\n        std::thread::sleep(Duration::from_secs(3));\n        assert_eq!(false, rodio_lib.is_playing());\n    }\n\n    #[test]\n    fn test_from_play_error() {\n        let rodio_error = rodio::PlayError::NoDevice;\n        let error = Error::from(rodio_error);\n        assert_eq!(Error::AudioLibError(String::from(\"NoDevice\")), error);\n    }\n\n    #[test]\n    fn test_from_stream_error() {\n        let rodio_error = rodio::StreamError::NoDevice;\n        let error = Error::from(rodio_error);\n        assert_eq!(Error::AudioLibError(String::from(\"NoDevice\")), error);\n    }\n\n    #[test]\n    fn test_from_devices_error() {\n        extern crate cpal;\n\n        let rodio_error = rodio::DevicesError::BackendSpecific {\n            err: cpal::BackendSpecificError {\n                description: String::from(\"\"),\n            },\n        };\n        let error = Error::from(rodio_error);\n        assert_eq!(\n            Error::AudioLibError(String::from(\"A backend-specific error has occurred: \")),\n            error\n        );\n    }\n\n    #[test]\n    fn test_from_decoder_error() {\n        let rodio_error = rodio::decoder::DecoderError::UnrecognizedFormat;\n        let error = Error::from(rodio_error);\n        assert_eq!(\n            Error::AudioLibError(String::from(\"Unrecognized format\")),\n            error\n        );\n    }\n}\n","traces":[{"line":20,"address":[4635072,4635720],"length":1,"stats":{"Line":2},"fn_name":"create_new_triple"},{"line":21,"address":[4635082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[4635735,4635591,4635227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[4635374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[4635792],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":28,"address":[4635802,4636277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[4636145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[4636069],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[4636108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4636464,4637078],"length":1,"stats":{"Line":2},"fn_name":"play"},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[4636900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4637020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[4637032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[4638019,4637200],"length":1,"stats":{"Line":2},"fn_name":"stop"},{"line":47,"address":[4637218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[4637807,4637268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4638039,4637728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[4638120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4638592],"length":1,"stats":{"Line":2},"fn_name":"open"},{"line":60,"address":[4638600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":34,"coverable":35},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","src","track.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse std::path::Path;\n\n/// The track (i.e. its path)\n///\n/// The [`Track`](crate::Track) is created from a [`String`](std::string::String) or a [`\u0026str`](std::str) and contains the path to the track.\n#[derive(Debug, PartialEq, Clone)]\npub struct Track(String);\n\nimpl From\u003cString\u003e for Track {\n    fn from(path: String) -\u003e Self {\n        Track(path)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for Track {\n    fn from(path: \u0026str) -\u003e Self {\n        Track(path.into())\n    }\n}\n\nimpl AsRef\u003cstr\u003e for Track {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        self.0.as_ref()\n    }\n}\n\nimpl AsRef\u003cPath\u003e for Track {\n    fn as_ref(\u0026self) -\u003e \u0026Path {\n        self.0.as_ref()\n    }\n}\n\nimpl std::fmt::Display for Track {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_as_ref() {\n        let track = Track::from(\"track\");\n        let as_ref: \u0026str = track.as_ref();\n        assert_eq!(\"track\", as_ref);\n    }\n\n    #[test]\n    fn test_display() {\n        let track = Track::from(\"track\");\n        let formatted_track = format!(\"{}\", track);\n        assert_eq!(\"track\".to_string(), formatted_track);\n    }\n}\n","traces":[{"line":14,"address":[11947312],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":15,"address":[7461095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[4625824],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":21,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[7461232],"length":1,"stats":{"Line":1},"fn_name":"as_ref"},{"line":27,"address":[11947465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[4625961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player","tests","integration_tests.rs"],"content":"#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod media_player_integration_tests {\n    use media_player::{open, MediaPlayer, Track};\n    use std::thread::sleep;\n    use std::time::Duration;\n\n    #[test]\n    fn test_double_play() {\n        let mut media_player = open().unwrap();\n        let track = Track::from(\"tests/rand1.wav\");\n        media_player.play(\u0026track).unwrap();\n        assert!(true);\n\n        sleep(Duration::from_millis(200));\n\n        let track2 = Track::from(\"tests/rand2.wav\");\n        media_player.play(\u0026track2).unwrap();\n        assert!(true);\n        sleep(Duration::from_millis(200));\n\n        media_player.stop().unwrap();\n        assert!(true);\n    }\n\n    #[test]\n    #[ignore = \"Test of correct usage of rodio\"]\n    fn test_play_until_the_end() {\n        let mut media_player = open().unwrap();\n        let track = Track::from(\"tests/rand1.wav\");\n        media_player.play(\u0026track).unwrap();\n        for i in 0..33 {\n            std::thread::sleep(Duration::from_secs(1));\n            println!(\"Time elapsed: {} s\", i + 1);\n        }\n        assert!(true);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","media_player_test","src","main.rs"],"content":"extern crate rodio;\nuse rodio::Decoder;\nuse rodio::OutputStream;\nuse rodio::OutputStreamHandle;\nuse rodio::Sink;\nuse rodio::Source;\nuse std::fs::File;\nuse std::io::BufReader;\nuse std::thread::sleep;\nuse std::time::Duration;\n\n#[cfg(not(tarpaulin_include))]\nfn do_play() {\n    let (stream, stream_handle) = rodio::OutputStream::try_default().unwrap();\n    //let sink = Sink::try_new(\u0026stream_handle).unwrap();\n    let file = File::open(\"sound.flac\").unwrap();\n    let source = rodio::Decoder::new(BufReader::new(file)).unwrap();\n    let sink = Sink::try_new(\u0026stream_handle).unwrap();\n    //let (sink, output_queue) = Sink::new_idle();\n    sink.set_volume(0.1);\n    //let sink = stream_handle.play_raw(source.convert_samples()).unwrap();\n    //let source = rodio::source::SineWave::new(440);\n    //sink.append(source);\n    sink.append(source);\n    let is_playing = !sink.empty();\n    println!(\"Still playing? {}\", is_playing);\n    println!(\"Is paused? {}\", sink.is_paused());\n    sink.play();\n    let mut counter = 0;\n    loop {\n        sleep(Duration::from_secs(2));\n        let is_playing = !sink.empty();\n        println!(\"Still playing? {}\", is_playing);\n        println!(\"Is paused? {}\", sink.is_paused());\n        if counter == 5 {\n            sink.stop();\n            let is_playing = !sink.empty();\n            println!(\"Still playing? {}\", is_playing);\n        }\n        if counter == 7 {\n            println!(\"Restart\");\n            let file2 = File::open(\"sound2.wav\").unwrap();\n            let source2 = rodio::Decoder::new(BufReader::new(file2)).unwrap();\n            sink.append(source2);\n            sink.play();\n        }\n        counter += 1;\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\nfn play(path: \u0026str) -\u003e (Sink, OutputStream, OutputStreamHandle) {\n    let (stream, stream_handle) = rodio::OutputStream::try_default().unwrap();\n\n    let file = File::open(path).unwrap();\n    let source = rodio::Decoder::new(BufReader::new(file)).unwrap();\n\n    let sink = Sink::try_new(\u0026stream_handle).unwrap();\n    sink.set_volume(0.1);\n    sink.append(source);\n    sink.play();\n    (sink, stream, stream_handle)\n}\n\n#[cfg(not(tarpaulin_include))]\nfn do_play2() {\n    let (mut sink, mut stream, mut stream_handle) = play(\"sound.flac\");\n\n    let mut counter = 1;\n\n    loop {\n        let is_playing = !sink.empty();\n        println!(\"Still playing? {}\", is_playing);\n        if counter == 5 {\n            sink.stop();\n            println!(\"Stopped\");\n        }\n        if counter == 7 {\n            let (sink_new, stream_new, stream_handle_new) = play(\"sound2.wav\");\n            sink = sink_new;\n            stream = stream_new;\n            stream_handle = stream_handle_new;\n            println!(\"Started new sound\");\n        }\n        if counter == 25 {\n            println!(\"Should have stopped playing\");\n            println!(\"Still playing? {}\", is_playing);\n            break;\n        }\n        sleep(Duration::from_secs(2));\n        counter += 1;\n    }\n\n    println!(\"sound over\");\n}\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    do_play2();\n    //let (sink, stream, stream_handle) = play(\"sound.flac\");\n    // let path =\"sound.flac\";\n    // let (stream, stream_handle) = rodio::OutputStream::try_default().unwrap();\n\n    // let file = File::open(path).unwrap();\n    // let source = rodio::Decoder::new(BufReader::new(file)).unwrap();\n\n    // let sink = Sink::try_new(\u0026stream_handle).unwrap();\n    // sink.set_volume(0.1);\n    // sink.append(source);\n    //loop {}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","cli_app.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse clap::{App, Arg};\nuse std::num::ParseIntError;\n\n/// Name of the Vendor ID command line option.\npub const VENDOR_ID_ARGUMENT_NAME: \u0026str = \"Vendor ID\";\n/// Name of the Product ID command line option.\npub const PRODUCT_ID_ARGUMENT_NAME: \u0026str = \"Product ID\";\n/// Name of the Tracks File command line option.\npub const TRACKS_FILE_ARGUMENT_NAME: \u0026str = \"Tracks File\";\n/// Name of the Timeout command line option.\npub const TIMEOUT_ARGUMENT_NAME: \u0026str = \"Timeout\";\n/// Name of the Log Level command line option.\npub const LOG_LEVEL_ARGUMENT_NAME: \u0026str = \"Log Level\";\n/// Name of the Console Log command line flag.\npub const CONSOLE_LOG_ARGUMENT_NAME: \u0026str = \"Console Log\";\n\n/// Creates the [`clap::App`](https://docs.rs/clap/2.33.3/clap/struct.App.html) of the rfid_media_player application.\npub fn create_app\u003c'a, 'b\u003e() -\u003e App\u003c'a, 'b\u003e {\n    App::new(\"RFID Media Player\")\n        .version(\"1.0.0\")\n        .author(\"rusty-octopus \u003coctopus@posteo.net\u003e\")\n        .about(\"Reads RFID cards and plays the tracks that are associated to the RFID values of these cards.\")\n        .arg(\n            Arg::with_name(VENDOR_ID_ARGUMENT_NAME)\n                .short(\"v\")\n                .long(\"vendor_id\")\n                .value_name(\"VENDOR_ID\")\n                .help(\"The Vendor ID of the RFID card reader.\\\n                Must be a valid unsigned integer with at most 16 bits.\")\n                .required(true).validator(validate_id),\n        )\n        .arg(\n          Arg::with_name(PRODUCT_ID_ARGUMENT_NAME)\n              .short(\"p\")\n              .long(\"product_id\")\n              .value_name(\"PRODUCT_ID\")\n              .help(\"The Product ID of the RFID card reader.\\\n              Must be a valid unsigned integer with at most 16 bits.\")\n              .required(true).validator(validate_id),\n      )\n      .arg(\n        Arg::with_name(TRACKS_FILE_ARGUMENT_NAME)\n            .short(\"t\")\n            .long(\"tracks\")\n            .value_name(\"TRACKS_FILE\")\n            .help(\"The YAML file that contains the mapping from RFID value to the path of the associated track.\\\n            Mapping must be defined like:\\n\\\n            \\\"\u003crfid value as string incl. leading zeros\u003e: \u003cpath to track\u003e\\\"\")\n            .required(true),\n\n      )\n      .arg(\n        Arg::with_name(TIMEOUT_ARGUMENT_NAME)\n            .short(\"o\")\n            .long(\"timeout\")\n            .value_name(\"TIMEOUT\")\n            .help(\"The timeout in milliseconds (ms) for the USB device interrupt read.\\\n            This means the time the read of the USB device should be blocking.\\\n            Aborting the application (e.g. via Ctrl+c) may be delayed up by this timeout value.\\\n            Do not use this value unless you know what you are doing.\\\n            Must be a valid unsigned integer with at most 64 bits in decimal radix.\")\n            .required(false).validator(validate_timeout)\n            .default_value(\"1000\"))\n      .arg(\n        Arg::with_name(LOG_LEVEL_ARGUMENT_NAME)\n          .short(\"l\")\n          .long(\"log_level\")\n          .value_name(\"LOG_LEVEL\")\n          .help(\"The log level for the logger.\")\n          .possible_value(\"error\")\n          .possible_value(\"warn\")\n          .possible_value(\"info\")\n          .possible_value(\"debug\")\n          .possible_value(\"trace\")\n          .required(false).default_value(\"info\"))\n      .arg(Arg::with_name(CONSOLE_LOG_ARGUMENT_NAME).long(\"console_log\").short(\"c\").help(\"Log will be duplicated to the console (stdout).\"))\n}\n\n/// Tries to convert a [`String`](std::string::String) into an [`u16`](std::u16).\n///\n/// Returns a [`ParseIntError`](std::num::ParseIntError) whenever the given [`String`](std::string::String) contains an invalid decimal or hexidecimal digit.\npub fn convert_to_id(id_string: String) -\u003e Result\u003cu16, ParseIntError\u003e {\n    let mut conversion_result = u16::from_str_radix(\u0026id_string, 16);\n    if conversion_result.is_err() {\n        conversion_result = u16::from_str_radix(\u0026id_string, 10);\n    }\n    conversion_result\n}\n\nfn validate_id(id_string: String) -\u003e Result\u003c(), String\u003e {\n    let conversion_result = convert_to_id(id_string);\n\n    if conversion_result.is_err() {\n        return Err(\"ID value must be a valid hexadecimal or decimal unsigned integer number with at least 16 bits.\".to_string());\n    }\n    Ok(())\n}\n\nfn validate_timeout(timeout_string: String) -\u003e Result\u003c(), String\u003e {\n    let conversion_result = u64::from_str_radix(\u0026timeout_string, 10);\n\n    if conversion_result.is_err() {\n        return Err(\n            \"Timeout value must be a valid decimal unsigned integer with at least 16 bits.\"\n                .to_string(),\n        );\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_convert_to_id() {\n        let result = convert_to_id(\"FF\".to_string());\n        assert_eq!(Ok(255), result);\n        let result = convert_to_id(\"G\".to_string());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_validate_id() {\n        let result = validate_id(\"FF\".to_string());\n        assert_eq!(Ok(()), result);\n        let result = validate_id(\"G\".to_string());\n        assert_eq!(Err(\"ID value must be a valid hexadecimal or decimal unsigned integer number with at least 16 bits.\".to_string()), result);\n    }\n\n    #[test]\n    fn test_validate_timeout() {\n        let result = validate_timeout(\"1000\".to_string());\n        assert_eq!(Ok(()), result);\n        let result = validate_timeout(\"G\".to_string());\n        assert_eq!(\n            Err(\n                \"Timeout value must be a valid decimal unsigned integer with at least 16 bits.\"\n                    .to_string()\n            ),\n            result\n        );\n    }\n\n    #[test]\n    fn test_create_app() {\n        let app = create_app();\n        let matches = app.get_matches_from(vec![\n            \"rfid_media_player\",\n            \"--vendor_id\",\n            \"1\",\n            \"--product_id\",\n            \"2\",\n            \"--tracks\",\n            \"path/to/tracks\",\n        ]);\n        assert_eq!(Some(\"1\"), matches.value_of(VENDOR_ID_ARGUMENT_NAME));\n        assert_eq!(Some(\"2\"), matches.value_of(PRODUCT_ID_ARGUMENT_NAME));\n        assert_eq!(\n            Some(\"path/to/tracks\"),\n            matches.value_of(TRACKS_FILE_ARGUMENT_NAME)\n        );\n    }\n}\n","traces":[{"line":22,"address":[4371280,4373384],"length":1,"stats":{"Line":1},"fn_name":"create_app"},{"line":28,"address":[9170577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[9170882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[9171187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[9171465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[9172586,9171790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[9171806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[9172296,9172558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[4373186,4373399,4373363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[4373903,4373696],"length":1,"stats":{"Line":1},"fn_name":"convert_to_id"},{"line":87,"address":[4373705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[4373773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[4373801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[4373936],"length":1,"stats":{"Line":1},"fn_name":"validate_id"},{"line":95,"address":[4373943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[4374004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[9173187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[9173171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[4374367,4374112],"length":1,"stats":{"Line":1},"fn_name":"validate_timeout"},{"line":104,"address":[4374127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4374231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4374301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4374277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[4374257],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","error.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse media_player;\nuse rfid_reader;\nuse track_store;\n\n/// RFID Media Player Errors\n///\n/// Defines all runtime errors.\n#[derive(Debug, PartialEq)]\npub enum Error {\n    /// Media player error.\n    ///\n    /// Returned whenever an error with the media player occurred.\n    MediaPlayerError(String),\n    /// RFID reader error.\n    ///\n    /// Returned whenever an error with the RFID reader occurred.\n    RfidReaderError(String),\n    /// Track store error.\n    ///\n    /// Returned whenever an error with the track store occurred.\n    TrackStoreError(String),\n}\n\nmacro_rules! implement_from_error_trait {\n    ($error_type:tt, $other_error_type:ty, $error_variant:ident) =\u003e {\n        impl From\u003c$other_error_type\u003e for $error_type {\n            fn from(error: $other_error_type) -\u003e Self {\n                $error_type::$error_variant(format!(\"{}\", error))\n            }\n        }\n    };\n}\n\nimplement_from_error_trait!(Error, media_player::Error, MediaPlayerError);\nimplement_from_error_trait!(Error, rfid_reader::Error, RfidReaderError);\nimplement_from_error_trait!(Error, track_store::Error, TrackStoreError);\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\nimpl std::error::Error for Error {}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_from_media_player_error() {\n        let media_player_error = media_player::Error::IoError(\"Test\".to_string());\n        let error = Error::from(media_player_error);\n        assert_eq!(\n            Error::MediaPlayerError(\"IoError(\\\"Test\\\")\".to_string()),\n            error\n        );\n    }\n\n    #[test]\n    fn test_from_rfid_reader_error() {\n        let other_error = rfid_reader::Error::Timeout;\n        let error = Error::from(other_error);\n        assert_eq!(Error::RfidReaderError(\"Timeout\".to_string()), error);\n    }\n\n    #[test]\n    fn test_from_track_store_error() {\n        let other_error = track_store::Error::LoadError(\"Test\".to_string());\n        let error = Error::from(other_error);\n        assert_eq!(\n            Error::TrackStoreError(\"LoadError(\\\"Test\\\")\".to_string()),\n            error\n        );\n    }\n\n    #[test]\n    fn test_display() {\n        let other_error = rfid_reader::Error::Timeout;\n        let error = Error::from(other_error);\n        let formatted_error = format!(\"{:}\", error);\n        assert_eq!(\"RfidReaderError(\\\"Timeout\\\")\", formatted_error);\n    }\n}\n","traces":[{"line":31,"address":[4275296,4275600,4275568,4275872,4276176,4275904],"length":1,"stats":{"Line":3},"fn_name":"from"},{"line":32,"address":[4275914,4275306,4275610],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","lib.rs"],"content":"//! The library of the rfid_media_player application.\n//!\n//! The [`RfidMediaPlayer`](crate::RfidMediaPlayer) can be [`open`](crate::open)ed in order to run it in the `main.rs`.\n//! It also helps creating an app with [crate::create_app](crate::create_app) to be used for the command line application.\n//! Finally it defines [`Error`](crate::Error)s that can happen during open or running the application.\n//!\n//! This library is used internally by the rfid_media_player application.\n//! It is implemented in order to test most of the logic of the main application.\n//!\n//! Example usage can be found in `main.rs`.\n#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse media_player;\nuse rfid_reader::{ProductId, VendorId};\nuse track_store;\n\nuse std::time::Duration;\n\nuse log::error;\n\nmod cli_app;\nmod error;\nmod rfidmediaplayer;\n\npub use cli_app::{\n    convert_to_id, create_app, CONSOLE_LOG_ARGUMENT_NAME, LOG_LEVEL_ARGUMENT_NAME,\n    PRODUCT_ID_ARGUMENT_NAME, TIMEOUT_ARGUMENT_NAME, TRACKS_FILE_ARGUMENT_NAME,\n    VENDOR_ID_ARGUMENT_NAME,\n};\npub use error::Error;\npub use rfidmediaplayer::RfidMediaPlayer;\n\n/// Tries to open the [`RfidMediaPlayer`](crate::RfidMediaPlayer).\n///\n/// Returns an [`RfidMediaPlayer`](crate::RfidMediaPlayer) trait object.\n///\n/// Returns an [`Error`](crate::Error) whenever there is a problem with the rfid_reader, track_store or media_player.\npub fn open(\n    vendor_id: VendorId,\n    product_id: ProductId,\n    timeout: Duration,\n    yaml_string: \u0026str,\n) -\u003e Result\u003cimpl RfidMediaPlayer, crate::Error\u003e {\n    let mut result = Err(Error::TrackStoreError(\n        \"Track store not loaded yet\".to_string(),\n    ));\n    let result_track_store = track_store::load(yaml_string);\n    if let Ok(track_store) = result_track_store {\n        let result_rfid_reader = rfid_reader::open(vendor_id, product_id, timeout);\n        if let Ok(rfid_reader) = result_rfid_reader {\n            let result_media_player = media_player::open();\n            if let Ok(media_player) = result_media_player {\n                result = Ok(rfidmediaplayer::open(\n                    media_player,\n                    rfid_reader,\n                    track_store,\n                ));\n            } else if let Err(media_player_error) = result_media_player {\n                error!(\n                    \"Opening media player resulted in error: {}\",\n                    media_player_error\n                );\n                result = Err(crate::Error::from(media_player_error))\n            }\n        } else if let Err(rfid_reader_error) = result_rfid_reader {\n            error!(\n                \"Opening rfid reader resulted in error: {}\",\n                rfid_reader_error\n            );\n            result = Err(crate::Error::from(rfid_reader_error))\n        }\n    } else if let Err(result_track_store_error) = result_track_store {\n        error!(\n            \"Loading track store resulted in error: {}\",\n            result_track_store_error\n        );\n        result = Err(crate::Error::from(result_track_store_error))\n    }\n\n    result\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_invalid_yaml() {\n        let result = open(\n            VendorId::from(1),\n            ProductId::from(1),\n            Duration::from_millis(1000),\n            \"test\",\n        );\n        if let Err(error) = result {\n            assert_eq!(Error::TrackStoreError(\"LoadError(\\\"invalid type: string \\\\\\\"test\\\\\\\", expected a map at line 1 column 1\\\")\".to_string()), error);\n        } else {\n            assert!(false);\n        }\n    }\n\n    #[test]\n    fn test_wrong_device() {\n        let result = open(\n            VendorId::from(1),\n            ProductId::from(1),\n            Duration::from_millis(1000),\n            \"1234: path\",\n        );\n        if let Err(error) = result {\n            assert_eq!(\n                Error::RfidReaderError(\"DeviceNotFound(VendorId(1), ProductId(1))\".to_string()),\n                error\n            );\n        } else {\n            assert!(false);\n        }\n    }\n}\n","traces":[{"line":40,"address":[9173536,9176553],"length":1,"stats":{"Line":2},"fn_name":"open"},{"line":46,"address":[9173798,9173610],"length":1,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[9173706],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[9173894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[9173976,9173945,9175906],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[9174048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[9175332,9174140,9174171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[4280363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4280382,4280429,4282709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4280744,4282624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4280514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4280560],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4280648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4282807,4280409,4280819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4281005,4280872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4281279,4282714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4280247,4282809,4281404,4283431,4281417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4281470,4281591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[4282925,4281841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4283466,4282588,4283233,4281966,4283018,4280052,4281979],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[4282032,4282153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[4282403,4283140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[4282528],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":23},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","main.rs"],"content":"use rfid_media_player::{\n    convert_to_id, create_app, open, RfidMediaPlayer, CONSOLE_LOG_ARGUMENT_NAME,\n    LOG_LEVEL_ARGUMENT_NAME, PRODUCT_ID_ARGUMENT_NAME, TIMEOUT_ARGUMENT_NAME,\n    TRACKS_FILE_ARGUMENT_NAME, VENDOR_ID_ARGUMENT_NAME,\n};\n\nuse rfid_reader::{ProductId, VendorId};\n\nuse flexi_logger::{Duplicate, LogTarget, Logger};\nuse log::info;\n\nuse signal_hook::consts::TERM_SIGNALS;\nuse signal_hook::iterator::Signals;\n\nuse std::sync::Arc;\nuse std::thread;\nuse std::{\n    sync::atomic::{AtomicBool, Ordering},\n    time::Duration,\n};\n\n#[cfg(not(tarpaulin_include))]\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let matches = create_app().get_matches();\n\n    // default is set, therefore unwrapping is safe.\n    let log_spec = matches.value_of(LOG_LEVEL_ARGUMENT_NAME).unwrap();\n\n    let mut logger = Logger::with_str(log_spec).log_target(LogTarget::File);\n\n    let stdout = matches.is_present(CONSOLE_LOG_ARGUMENT_NAME);\n    if stdout {\n        logger = logger.duplicate_to_stdout(Duplicate::All);\n    }\n    logger.start()?;\n\n    info!(\"Started rfid_media_player\");\n\n    let vendor_id = VendorId::from(convert_to_id(\n        matches\n            .value_of(VENDOR_ID_ARGUMENT_NAME)\n            .unwrap()\n            .to_string(),\n    )?);\n    let product_id = ProductId::from(convert_to_id(\n        matches\n            .value_of(PRODUCT_ID_ARGUMENT_NAME)\n            .unwrap()\n            .to_string(),\n    )?);\n\n    let timeout = Duration::from_millis(u64::from_str_radix(\n        matches.value_of(TIMEOUT_ARGUMENT_NAME).unwrap(),\n        10,\n    )?);\n\n    let yaml_string =\n        std::fs::read_to_string(matches.value_of(TRACKS_FILE_ARGUMENT_NAME).unwrap())?;\n\n    let mut rfid_media_player = open(vendor_id, product_id, timeout, \u0026yaml_string)?;\n\n    info!(\"Application opened successfully\");\n\n    // Shared atomic bool to signal that the program is aborted\n    let running = Arc::new(AtomicBool::new(true));\n    let r = running.clone();\n\n    // all terminating signals\n    let mut signals = Signals::new(TERM_SIGNALS)?;\n\n    // spawn a thread to react to all terminating signals\n    thread::spawn(move || {\n        for sig in signals.forever() {\n            info!(\"Received signal {:?}\", sig);\n            r.store(false, Ordering::SeqCst);\n        }\n    });\n\n    while running.load(Ordering::SeqCst) {\n        rfid_media_player.run()?;\n    }\n    info!(\"Shutting down ...\");\n    rfid_media_player.shutdown()?;\n    info!(\"Shutting complete.\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_media_player","src","rfidmediaplayer.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\n\nuse log::{debug, error, info, warn};\n\nuse media_player::MediaPlayer;\nuse rfid_reader::RfidReader;\nuse track_store::TrackStore;\n\n/// The `RfidMediaPlayer` trait.\npub trait RfidMediaPlayer {\n    /// `run`s the `RfidMediaPlayer`.\n    ///\n    /// Returns either a success or an [`Error`](crate::Error).\n    /// Implementors must implement run non-blocking in order to allow the callee\n    /// to stop the application on terminated signals etc.\n    fn run(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    /// `shutdown`s the `RfidMediaPlayer`.\n    ///\n    /// Returns either a success or an [`Error`](crate::Error).\n    /// Must be called before the application is stopped.\n    fn shutdown(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n}\n\nstruct RfidMediaPlayerImplementation\u003cM, R, T\u003e\nwhere\n    M: MediaPlayer,\n    R: RfidReader,\n    T: TrackStore,\n{\n    media_player: M,\n    rfid_reader: R,\n    track_store: T,\n}\n\n/// Opens the `RfidMediaPlayer`.\npub(crate) fn open\u003cM, R, T\u003e(media_player: M, rfid_reader: R, track_store: T) -\u003e impl RfidMediaPlayer\nwhere\n    M: MediaPlayer,\n    R: RfidReader,\n    T: TrackStore,\n{\n    RfidMediaPlayerImplementation::open(media_player, rfid_reader, track_store)\n}\n\nimpl\u003cM, R, T\u003e RfidMediaPlayer for RfidMediaPlayerImplementation\u003cM, R, T\u003e\nwhere\n    M: MediaPlayer,\n    R: RfidReader,\n    T: TrackStore,\n{\n    fn run(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let mut result = Ok(());\n        let read_result = self.rfid_reader.read();\n        match read_result {\n            Ok(rfid_value) =\u003e {\n                info!(\"Received RFID value: {}\", rfid_value);\n                let option_track_path = get_track(\u0026self.track_store, rfid_value);\n                if let Some(track_path) = option_track_path {\n                    result = play_track(\u0026mut self.media_player, track_path);\n                }\n            }\n            Err(error) =\u003e match error {\n                rfid_reader::Error::Timeout =\u003e result = Ok(()),\n                _ =\u003e {\n                    error!(\"Reading RFID resolved in error: {}\", error);\n                    result = Err(Error::from(error));\n                }\n            },\n        }\n        result\n    }\n\n    fn shutdown(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        let mut result = Ok(());\n        let rfid_reader_deinit_result = self.rfid_reader.deinitialize();\n        if let Err(error) = rfid_reader_deinit_result {\n            error!(\n                \"RFID reader could not be deinitialized without error: {}\",\n                error\n            );\n            result = Err(Error::from(error))\n        }\n        let media_player_stop_result = self.media_player.stop();\n        if let Err(error) = media_player_stop_result {\n            error!(\"Stopping media player resulted in error: {}\", error);\n            result = Err(Error::from(error))\n        }\n        result\n    }\n}\n\nimpl\u003cM, R, T\u003e RfidMediaPlayerImplementation\u003cM, R, T\u003e\nwhere\n    M: MediaPlayer,\n    R: RfidReader,\n    T: TrackStore,\n{\n    fn open(media_player: M, rfid_reader: R, track_store: T) -\u003e Self {\n        RfidMediaPlayerImplementation {\n            media_player: media_player,\n            rfid_reader: rfid_reader,\n            track_store: track_store,\n        }\n    }\n}\n\nfn get_track\u003c'a\u003e(\n    track_store: \u0026'a impl TrackStore,\n    rfid_value: String,\n) -\u003e Option\u003c\u0026'a track_store::TrackPath\u003e {\n    debug!(\"Get track for rfid {}\", rfid_value);\n    let id = track_store::Id::from(rfid_value);\n    debug!(\"Converted to id {}\", id);\n    let option = track_store.get_path(\u0026id);\n    debug!(\"Optional path to id {:?}\", option);\n    match option {\n        Some(track_path) =\u003e {\n            info!(\"Found track {} for RFID {}.\", track_path, id);\n            Some(track_path)\n        }\n        None =\u003e {\n            warn!(\"found no track for RFID {}.\", id);\n            None\n        }\n    }\n}\n\nfn play_track(\n    media_player: \u0026mut impl MediaPlayer,\n    track_path: \u0026track_store::TrackPath,\n) -\u003e Result\u003c(), Error\u003e {\n    let track: media_player::Track = media_player::Track::from(track_path.as_ref());\n    let play_result = media_player.play(\u0026track);\n    match play_result {\n        Ok(()) =\u003e {\n            info!(\"Start playing track {}\", track);\n            Ok(())\n        }\n        Err(error) =\u003e {\n            error!(\n                \"Track {} could not be played, received error: {}\",\n                track, error\n            );\n            Err(Error::from(error))\n        }\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    struct OkMediaPlayer;\n    impl MediaPlayer for OkMediaPlayer {\n        fn play(\u0026mut self, _track: \u0026media_player::Track) -\u003e Result\u003c(), media_player::Error\u003e {\n            Ok(())\n        }\n        fn stop(\u0026mut self) -\u003e Result\u003c(), media_player::Error\u003e {\n            Ok(())\n        }\n    }\n\n    struct ErrMediaPlayer;\n    impl MediaPlayer for ErrMediaPlayer {\n        fn play(\u0026mut self, _track: \u0026media_player::Track) -\u003e Result\u003c(), media_player::Error\u003e {\n            Err(media_player::Error::AudioLibError(\"play\".to_string()))\n        }\n        fn stop(\u0026mut self) -\u003e Result\u003c(), media_player::Error\u003e {\n            Err(media_player::Error::AudioLibError(\"stop\".to_string()))\n        }\n    }\n\n    struct SomeTrackStore(track_store::TrackPath);\n    impl TrackStore for SomeTrackStore {\n        fn get_path(\u0026self, _id: \u0026track_store::Id) -\u003e Option\u003c\u0026track_store::TrackPath\u003e {\n            Some(\u0026self.0)\n        }\n    }\n\n    struct NoneTrackStore;\n    impl TrackStore for NoneTrackStore {\n        fn get_path(\u0026self, _id: \u0026track_store::Id) -\u003e Option\u003c\u0026track_store::TrackPath\u003e {\n            None\n        }\n    }\n\n    #[derive(Debug)]\n    struct OkRfidReader;\n    impl RfidReader for OkRfidReader {\n        fn read(\u0026self) -\u003e Result\u003cString, rfid_reader::Error\u003e {\n            Ok(\"1234\".to_string())\n        }\n        fn deinitialize(\u0026mut self) -\u003e Result\u003c(), rfid_reader::Error\u003e {\n            Ok(())\n        }\n    }\n\n    #[derive(Debug)]\n    struct ErrRfidReader;\n    impl RfidReader for ErrRfidReader {\n        fn read(\u0026self) -\u003e Result\u003cString, rfid_reader::Error\u003e {\n            Err(rfid_reader::Error::OtherUsbError(\"read\".to_string()))\n        }\n        fn deinitialize(\u0026mut self) -\u003e Result\u003c(), rfid_reader::Error\u003e {\n            Err(rfid_reader::Error::OtherUsbError(\n                \"deinitialize\".to_string(),\n            ))\n        }\n    }\n\n    #[derive(Debug)]\n    struct TimeoutRfidReader;\n    impl RfidReader for TimeoutRfidReader {\n        fn read(\u0026self) -\u003e Result\u003cString, rfid_reader::Error\u003e {\n            Err(rfid_reader::Error::Timeout)\n        }\n        fn deinitialize(\u0026mut self) -\u003e Result\u003c(), rfid_reader::Error\u003e {\n            Ok(())\n        }\n    }\n\n    #[test]\n    fn test_play_track() {\n        let mut ok = OkMediaPlayer;\n        let result = play_track(\u0026mut ok, \u0026track_store::TrackPath::from(\"\"));\n        assert_eq!(Ok(()), result);\n\n        let mut err = ErrMediaPlayer;\n        let result = play_track(\u0026mut err, \u0026track_store::TrackPath::from(\"\"));\n        assert_eq!(\n            Err(Error::MediaPlayerError(\n                \"AudioLibError(\\\"play\\\")\".to_string()\n            )),\n            result\n        );\n    }\n    #[test]\n    fn test_get_track() {\n        let some = SomeTrackStore(track_store::TrackPath::from(\"path\"));\n        let option = get_track(\u0026some, \"\".to_string());\n        assert_eq!(Some(\u0026track_store::TrackPath::from(\"path\")), option);\n\n        let none = NoneTrackStore;\n        let option = get_track(\u0026none, \"\".to_string());\n        assert_eq!(None, option);\n    }\n\n    #[test]\n    fn test_ok_run_and_shutdown() {\n        let mut rfid_media_player = open(\n            OkMediaPlayer,\n            OkRfidReader,\n            SomeTrackStore(track_store::TrackPath::from(\"path\")),\n        );\n\n        let result = rfid_media_player.run();\n\n        assert_eq!(Ok(()), result);\n\n        let result = rfid_media_player.shutdown();\n\n        assert_eq!(Ok(()), result);\n    }\n\n    #[test]\n    fn test_err_run_and_shutdown() {\n        let mut rfid_media_player = open(\n            OkMediaPlayer,\n            ErrRfidReader,\n            SomeTrackStore(track_store::TrackPath::from(\"path\")),\n        );\n\n        let result = rfid_media_player.run();\n\n        assert_eq!(\n            Err(Error::RfidReaderError(\n                \"OtherUsbError(\\\"read\\\")\".to_string()\n            )),\n            result\n        );\n\n        let result = rfid_media_player.shutdown();\n\n        assert_eq!(\n            Err(Error::RfidReaderError(\n                \"OtherUsbError(\\\"deinitialize\\\")\".to_string()\n            )),\n            result\n        );\n    }\n\n    #[test]\n    fn test_err_media_player_shutdown() {\n        let mut rfid_media_player = open(\n            ErrMediaPlayer,\n            OkRfidReader,\n            SomeTrackStore(track_store::TrackPath::from(\"path\")),\n        );\n\n        let result = rfid_media_player.shutdown();\n\n        assert_eq!(\n            Err(Error::MediaPlayerError(\n                \"AudioLibError(\\\"stop\\\")\".to_string()\n            )),\n            result\n        );\n    }\n\n    #[test]\n    fn test_timeout_run() {\n        let mut rfid_media_player = open(\n            OkMediaPlayer,\n            TimeoutRfidReader,\n            SomeTrackStore(track_store::TrackPath::from(\"path\")),\n        );\n\n        let result = rfid_media_player.run();\n\n        assert_eq!(Ok(()), result);\n    }\n}\n","traces":[{"line":40,"address":[4286016,4285776,4285648,4285952,4285712],"length":1,"stats":{"Line":4},"fn_name":"open\u003crfid_media_player::rfidmediaplayer::tests::OkMediaPlayer,rfid_media_player::rfidmediaplayer::tests::OkRfidReader,rfid_media_player::rfidmediaplayer::tests::SomeTrackStore\u003e"},{"line":46,"address":[4285786,4285655,4286023,4285959,4285719],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[4288144,4291585,4289521,4287457,4286080,4290208],"length":1,"stats":{"Line":3},"fn_name":"run\u003crfid_media_player::rfidmediaplayer::tests::OkMediaPlayer,rfid_media_player::rfidmediaplayer::tests::TimeoutRfidReader,rfid_media_player::rfidmediaplayer::tests::SomeTrackStore\u003e"},{"line":56,"address":[4288162,4286098,4290226],"length":1,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[4286153,4288217,4290281],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[4288352,4286288,4291012,4290416,4288948,4286884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4288354,4290304,4286176,4290418,4286290,4288240],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[4286451,4288394,4290579,4290458,4286330,4288515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[4288769,4286705,4290833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[4288854,4291731,4286790,4287603,4289667,4290918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[4291168,4289021,4289104,4291085,4288953,4286957,4287040,4286889,4291017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[4287744,4291872,4289808,4287288,4291416,4289352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[4289487,4291551,4287423],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[4294432,4297999,4292272,4293679,4296592,4295839],"length":1,"stats":{"Line":3},"fn_name":"shutdown\u003crfid_media_player::rfidmediaplayer::tests::ErrMediaPlayer,rfid_media_player::rfidmediaplayer::tests::OkRfidReader,rfid_media_player::rfidmediaplayer::tests::SomeTrackStore\u003e"},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[4304127,4301663,4301744,4299280],"length":1,"stats":{"Line":2},"fn_name":"get_track\u003crfid_media_player::rfidmediaplayer::tests::SomeTrackStore\u003e"},{"line":115,"address":[4299295,4299466,4301930,4301759],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[4299750,4302214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[4302413,4299949,4302280,4299816],"length":1,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[4300245,4302709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[4302873,4300276,4300409,4302740],"length":1,"stats":{"Line":4},"fn_name":null},{"line":120,"address":[4303732,4301268,4300755,4303219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[4303153,4303221,4300689,4300757],"length":1,"stats":{"Line":5},"fn_name":null},{"line":122,"address":[4300773,4303358,4300894,4303237],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[4301252,4303716],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[4300714,4303178,4301273,4301356,4303737,4303820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[4304064,4301600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[4304208,4306841,4305465,4305584],"length":1,"stats":{"Line":2},"fn_name":"play_track\u003crfid_media_player::rfidmediaplayer::tests::ErrMediaPlayer\u003e"},{"line":136,"address":[4305610,4304234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[4305721,4304345],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[4306236,4304860,4305836,4304460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[4304352,4305728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[4304592,4305968,4305838,4304462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[4304853,4306229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[4304376,4305752],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[4304865,4306241,4304416,4305792,4306324,4304948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[4305307,4306683],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":50,"coverable":52},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","examples","print_value.rs"],"content":"use rfid_reader::{open, Error, ProductId, RfidReader, VendorId};\nuse std::time::Duration;\n\nfn main() {\n    let vendor_id = VendorId::from(0x16c0);\n    let product_if = ProductId::from(0x27db);\n    let reader = open(vendor_id, product_if, Duration::from_secs(2));\n\n    if reader.is_ok() {\n        let mut reader = reader.unwrap();\n        let mut counter = 0;\n        while counter \u003c 5 {\n            counter += 1;\n            let read_result = reader.read();\n            match read_result {\n                Ok(value) =\u003e println!(\"Value: {}\", value),\n                Err(error) =\u003e println!(\"Read Error: {}\", error),\n            }\n        }\n        reader.deinitialize();\n    } else {\n        println!(\n            \"Reader could not be opened. Error: {:?}\",\n            reader.unwrap_err()\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","error.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::id::{ProductId, VendorId};\n/// RFID Reader errors.\n///\n/// Defines all runtime errors.\n#[derive(Debug, PartialEq)]\npub enum Error {\n    /// Device Not Found.\n    ///\n    /// Returned whenever the device defined by [VendorId](crate::VendorId) and [ProductId](crate::ProductId).\n    DeviceNotFound(VendorId, ProductId),\n    /// Timeout error.\n    ///\n    /// The read returned a timeout. Mostly used internally.\n    Timeout,\n    /// Access.\n    ///\n    /// Access to Device denied. This usually happens when the user rights are not sufficient.\n    /// Try using the RFID reader with more privileges.\n    Access,\n    /// Readable Endpoint Not Found.\n    ///\n    /// Returned whenever no readable endpoint could be found for the device defined by [VendorId](crate::VendorId) and [ProductId](crate::ProductId).\n    ReadableEndPointNotFound(VendorId, ProductId),\n    /// Invalid Data.\n    ///\n    /// Returned whenever invalid (or unexpected) data is received.\n    InvalidData(u8),\n    /// Too Few Received Data.\n    ///\n    /// Returned whenever too few bytes were received.\n    TooFewReceivedData(usize),\n    /// Key Not Existing.\n    ///\n    /// Returned whenever a byte value cannot be mapped to a key.\n    KeyNotExisting(u8),\n    /// Other Usb Error.\n    ///\n    /// Returned whenever an other error from the used USB library\n    /// that is of minor importance for the RFID reader is returned.\n    OtherUsbError(String),\n}\n\nimpl std::error::Error for Error {}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let error = Error::Timeout;\n        assert_eq!(\"Timeout\", format!(\"{}\", error));\n    }\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","humbleusbdevice.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\n\npub trait HumbleUsbDevice {\n    fn has_attached_kernel_driver(\u0026self) -\u003e Result\u003cbool, Error\u003e;\n    fn detach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn attach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn read(\u0026self, buffer: \u0026mut [u8]) -\u003e Result\u003c(), Error\u003e;\n    fn claim_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn release_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn set_active_configuration(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn set_alternate_setting(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n    fn initialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if self.has_attached_kernel_driver()? {\n            self.detach_kernel_driver()?;\n            self.set_active_configuration()?;\n            self.claim_interface()?;\n            self.set_alternate_setting()?;\n        }\n        Ok(())\n    }\n    fn set_deinitialized(\u0026mut self);\n    fn deinitialized(\u0026self) -\u003e bool;\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        if !self.deinitialized() {\n            self.set_deinitialized();\n            if self.has_attached_kernel_driver()? {\n                self.attach_kernel_driver()?;\n                self.release_interface()?;\n            }\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":16,"address":[4266640],"length":1,"stats":{"Line":2},"fn_name":"initialize\u003crfid_reader::rusb::rusbhumbleusbdevice::RusbHumbleUsbDevice\u003crusb::context::Context\u003e\u003e"},{"line":17,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[4276234,4276149,4277482,4277397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[4267160,4267227,4266963],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[7334699,7334430,7334630],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":23,"address":[4267867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[4279265,4278449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[4279270,4278679,4279803,4279495,4278454,4278987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","id.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse std::fmt;\n#[derive(Debug, PartialEq, Clone, Copy)]\n/// Describes a Vendor Id of a USB device.\npub struct VendorId(u16);\n#[derive(Debug, PartialEq, Clone, Copy)]\n/// Describes a Product Id of a USB device.\npub struct ProductId(u16);\n\nmacro_rules! implement_from_trait {\n    ($id_type:tt) =\u003e {\n        impl From\u003cu16\u003e for $id_type {\n            fn from(id: u16) -\u003e Self {\n                $id_type(id)\n            }\n        }\n    };\n}\n\nmacro_rules! implement_into_trait {\n    ($id_type:tt) =\u003e {\n        impl Into\u003cu16\u003e for $id_type {\n            fn into(self) -\u003e u16 {\n                self.0\n            }\n        }\n    };\n}\n\nmacro_rules! implement_display_trait {\n    ($id_type:tt) =\u003e {\n        impl fmt::Display for $id_type {\n            fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n                write!(f, \"{:#06x}\", self.0)\n            }\n        }\n    };\n}\n\nimplement_from_trait!(VendorId);\nimplement_from_trait!(ProductId);\nimplement_into_trait!(VendorId);\nimplement_into_trait!(ProductId);\nimplement_display_trait!(VendorId);\nimplement_display_trait!(ProductId);\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn vendor_id_from() {\n        let vendor_id = VendorId::from(16);\n        assert_eq!(16, vendor_id.0);\n    }\n\n    #[test]\n    fn product_id_from() {\n        let product_id = ProductId::from(16);\n        assert_eq!(16, product_id.0);\n    }\n\n    #[test]\n    fn vendor_id_display() {\n        let vendor_id = VendorId::from(16);\n        assert_eq!(\"0x0010\", format!(\"{}\", vendor_id));\n    }\n\n    #[test]\n    fn product_id_display() {\n        let product = ProductId::from(16);\n        assert_eq!(\"0x0010\", format!(\"{}\", product));\n    }\n}\n","traces":[{"line":16,"address":[4254480,4254448],"length":1,"stats":{"Line":6},"fn_name":"from"},{"line":17,"address":[4254457,4254489],"length":1,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[4254528,4254512],"length":1,"stats":{"Line":3},"fn_name":"into"},{"line":36,"address":[4254544,4254752],"length":1,"stats":{"Line":2},"fn_name":"fmt"},{"line":37,"address":[4254782,4254574],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","keymap.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\n\n#[derive(Debug, PartialEq)]\npub(crate) enum Key {\n    Digit(char),\n    Enter,\n}\npub(crate) trait KeyMap: std::fmt::Debug {\n    fn map(\u0026self, key: u8) -\u003e Result\u003cKey, Error\u003e;\n}\n\nimpl Into\u003cchar\u003e for Key {\n    fn into(self) -\u003e char {\n        match self {\n            Self::Digit(c) =\u003e c,\n            Self::Enter =\u003e 'Z',\n        }\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_into_char() {\n        let digit = Key::Digit('9');\n        let c = digit.into();\n        assert_eq!('9', c);\n        let digit = Key::Enter;\n        let c = digit.into();\n        assert_eq!('Z', c);\n    }\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","lib.rs"],"content":"//! A crate for a RFID Reader USB device.\n//!\n//! The RFID Reader can be opened to get a [RfidReader](crate::RfidReader).\n//! One can read the processed data as String from this device.\n//! It makes also sense to de-initialize the [RfidReader](crate::RfidReader) upon finishing.\n//!\n//! This crate is specifically implemented for a Neuftech RFID reader,\n//! but may be extended to support other manufacturers.\n//!\n//! # Example\n//! ```rust,no_run\n//! use std::time::Duration;\n//! use rfid_reader::{VendorId, ProductId, RfidReader};\n//!\n//! // set Vendor Id and Product Id\n//! let vendor_id = VendorId::from(0x16c0);\n//! let product_id = ProductId::from(0x27db);\n//!\n//! // Define a timeout (i.e. how long waits the reader for a RFID chip).\n//! // From my experience, the longer the better, however it will block this amount of time.\n//! let timeout = Duration::from_secs(60);\n//! // get the rfid device, this may fail, for example when the device does not exist\n//! let mut rfid_reader = rfid_reader::open(vendor_id, product_id, timeout).unwrap();\n//!\n//! // Read from the device. This is blocking!\n//! // It should normally return a String containing numbers, but it may also fail.\n//! // It will return Error::Timeout whenever the timeout has expired\n//! let data = rfid_reader.read().unwrap();\n//!\n//! // Ideally de-initialize the device when no longer needed.\n//! // This may fail therefore it makes sense to call it in order to get the error instead of\n//! // a panic.\n//! let result = rfid_reader.deinitialize();\n//! if result.is_err() {\n//!   println!(\"De-initialize failed: {}\", result.unwrap_err());\n//! }\n//! ```\n#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse std::time::Duration;\n\nmod error;\nmod humbleusbdevice;\nmod id;\nmod keymap;\nmod neuftech;\nmod rfidreader;\nmod rusb;\nmod usbreader;\n\npub use error::Error;\npub use id::{ProductId, VendorId};\npub use rfidreader::RfidReader;\n\n/// Tries to open an [RfidReader](crate::RfidReader).\n///\n/// Given the VendorId and the ProductId of the device, this function tries to open the device.\n/// The `timeout` is used to wait blocking for an interrupt of the USB device.\n/// From my experience: The longer the timeout the better.\n///\n/// May fail. Most important errors are [Error::DeviceNotFound](crate::error::Error::DeviceNotFound),\n/// when the device could not be found. Or [Error::Access](crate::error::Error::Access) when there is\n/// insufficient rights to open device.\n#[cfg(not(tarpaulin_include))]\npub fn open(\n    vendor_id: VendorId,\n    product_id: ProductId,\n    timeout: Duration,\n) -\u003e Result\u003cimpl RfidReader, Error\u003e {\n    let key_map = neuftech::NeuftechKeyMap;\n    let rusb_device = rusb::open(vendor_id, product_id, timeout)?;\n    let usb_reader = neuftech::new(rusb_device)?;\n    Ok(rfidreader::from(key_map, usb_reader))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","neuftech","keymap.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::keymap::{Key, KeyMap};\n\npub struct NeuftechKeyMap;\n\nimpl KeyMap for NeuftechKeyMap {\n    fn map(\u0026self, key: u8) -\u003e Result\u003cKey, Error\u003e {\n        const OFFSET_KEY_TO_UTF8: u8 = 0x13;\n        match key {\n            // Key board codes are 30-30 for keys 1-9 (utf8 hex values 0x31-0x39)\n            30..=38 =\u003e Ok(Key::Digit(char::from(key + OFFSET_KEY_TO_UTF8))),\n            // Key board code 39 is for key 0\n            39 =\u003e Ok(Key::Digit(char::from(0x30))),\n            // Key board code for 40 is Enter\n            40 =\u003e Ok(Key::Enter),\n            // Neuftech should only report numbers, enter or control codes\n            _ =\u003e Err(Error::KeyNotExisting(key)),\n        }\n    }\n}\n\nimpl std::fmt::Debug for NeuftechKeyMap {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"NeuftechKeyMap\").finish()\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n    use std::convert::TryInto;\n\n    #[test]\n    fn test_digits() {\n        let keymap = NeuftechKeyMap;\n        let digits: Vec\u003cResult\u003cKey, Error\u003e\u003e = ('1'..='9').map(|c| Ok(Key::Digit(c))).collect();\n        let mapped_keys: Vec\u003cResult\u003cKey, Error\u003e\u003e = (30..39)\n            .map(|i| keymap.map(usize::try_into(i).unwrap()))\n            .collect();\n        assert_eq!(digits, mapped_keys);\n        assert_eq!(Ok(Key::Digit('0')), keymap.map(39));\n    }\n\n    #[test]\n    fn test_enter() {\n        let keymap = NeuftechKeyMap;\n        assert_eq!(Ok(Key::Enter), keymap.map(40));\n    }\n\n    #[test]\n    fn test_error() {\n        let keymap = NeuftechKeyMap;\n        assert_eq!(Err(Error::KeyNotExisting(17)), keymap.map(17));\n    }\n\n    #[test]\n    fn test_debug() {\n        let key_map = NeuftechKeyMap;\n        assert_eq!(\"NeuftechKeyMap\", format!(\"{:?}\", key_map));\n    }\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[4317428,4317280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","neuftech","mod.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nmod keymap;\nmod usbreader;\n\npub(crate) use keymap::NeuftechKeyMap;\npub(crate) use usbreader::new;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","neuftech","usbreader.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::humbleusbdevice::HumbleUsbDevice;\n\nuse crate::usbreader::UsbReader;\n\npub(crate) struct NeuftechUsbReader\u003cT\u003e\nwhere\n    T: HumbleUsbDevice,\n{\n    usb_device: T,\n}\n\nimpl\u003cT: HumbleUsbDevice\u003e std::fmt::Debug for NeuftechUsbReader\u003cT\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"NeuftechUsbReader\").finish()\n    }\n}\n\npub(crate) fn new\u003cT: HumbleUsbDevice\u003e(humble_usb_device: T) -\u003e Result\u003cimpl UsbReader, Error\u003e {\n    NeuftechUsbReader::new(humble_usb_device)\n}\n\nimpl\u003cT: HumbleUsbDevice\u003e NeuftechUsbReader\u003cT\u003e {\n    fn new(usb_device: T) -\u003e Result\u003cSelf, Error\u003e {\n        let mut usb_device = usb_device;\n        usb_device.initialize()?;\n        Ok(NeuftechUsbReader { usb_device })\n    }\n}\n\nimpl\u003cT: HumbleUsbDevice\u003e UsbReader for NeuftechUsbReader\u003cT\u003e {\n    fn read(\u0026self) -\u003e Result\u003cBox\u003c[u8]\u003e, Error\u003e {\n        let mut raw_data_interpreter = RawDataInterpreter::default();\n        let mut buffer = [0; 3];\n        while !raw_data_interpreter.finished_processing() {\n            let result = self.usb_device.read(\u0026mut buffer);\n            if result.is_ok() {\n                raw_data_interpreter.process(\u0026buffer)?;\n            } else {\n                let error = result.unwrap_err();\n                return Err(error);\n            }\n        }\n        Ok(Box::new(raw_data_interpreter.data))\n    }\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.usb_device.deinitialize()\n    }\n}\n\n#[derive(Debug, PartialEq)]\nenum RawDataInterpretation {\n    Value(u8),\n    Repeated,\n    Enter,\n}\n\nimpl RawDataInterpretation {\n    fn from(data: \u0026[u8]) -\u003e Result\u003cRawDataInterpretation, Error\u003e {\n        if data.len() \u003e= 3 {\n            let value = data[2];\n            let return_value = match value {\n                0 =\u003e Ok(Self::Repeated),\n                30..=39 =\u003e Ok(Self::Value(value)),\n                40 =\u003e Ok(Self::Enter),\n                _ =\u003e Err(Error::InvalidData(value)),\n            };\n            return return_value;\n        }\n        Err(Error::TooFewReceivedData(data.len()))\n    }\n}\n\nstruct RawDataInterpreter {\n    finished: bool,\n    index: usize,\n    data: [u8; 10],\n    last: Option\u003cRawDataInterpretation\u003e,\n}\n\nimpl Default for RawDataInterpreter {\n    fn default() -\u003e Self {\n        RawDataInterpreter {\n            finished: false,\n            index: 0,\n            data: [0; 10],\n            last: None,\n        }\n    }\n}\n\nimpl RawDataInterpreter {\n    fn process(\u0026mut self, raw_data: \u0026[u8]) -\u003e Result\u003c(), Error\u003e {\n        let raw_data_interpretation = RawDataInterpretation::from(raw_data)?;\n        match raw_data_interpretation {\n            RawDataInterpretation::Value(value) =\u003e {\n                self.data[self.index] = value;\n                self.last = Some(raw_data_interpretation);\n                self.index += 1;\n            }\n            RawDataInterpretation::Enter =\u003e {\n                self.last = Some(raw_data_interpretation);\n            }\n            RawDataInterpretation::Repeated =\u003e {\n                if self.index == 10 \u0026\u0026 self.last == Some(RawDataInterpretation::Enter) {\n                    self.finished = true;\n                }\n            }\n        }\n        Ok(())\n    }\n    fn finished_processing(\u0026self) -\u003e bool {\n        self.finished\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    struct ReadErrorHumbleUsbDevice {\n        deinitialized: bool,\n    }\n\n    impl HumbleUsbDevice for ReadErrorHumbleUsbDevice {\n        fn has_attached_kernel_driver(\u0026self) -\u003e Result\u003cbool, Error\u003e {\n            Ok(true)\n        }\n        fn detach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn attach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn read(\u0026self, buffer: \u0026mut [u8]) -\u003e Result\u003c(), Error\u003e {\n            Err(Error::InvalidData(0))\n        }\n        fn claim_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn release_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_active_configuration(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_alternate_setting(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_deinitialized(\u0026mut self) {\n            self.deinitialized = true;\n        }\n        fn deinitialized(\u0026self) -\u003e bool {\n            self.deinitialized\n        }\n    }\n\n    #[test]\n    fn test_raw_data_interpretation() {\n        let data: [u8; 1] = [0];\n        let result = RawDataInterpretation::from(\u0026data);\n        assert_eq!(Err(Error::TooFewReceivedData(1)), result);\n\n        let data: [u8; 3] = [1, 0, 39];\n        let result = RawDataInterpretation::from(\u0026data);\n        assert_eq!(Ok(RawDataInterpretation::Value(39)), result);\n\n        let data: [u8; 3] = [1, 0, 40];\n        let result = RawDataInterpretation::from(\u0026data);\n        assert_eq!(Ok(RawDataInterpretation::Enter), result);\n\n        let data: [u8; 3] = [1, 0, 124];\n        let result = RawDataInterpretation::from(\u0026data);\n        assert_eq!(Err(Error::InvalidData(124)), result);\n    }\n\n    #[test]\n    fn test_raw_data_interpreter() {\n        let mut interpreter = RawDataInterpreter::default();\n        let test_data = [1, 0, 39];\n        for _ in 0..=9 {\n            assert_eq!(Ok(()), interpreter.process(\u0026test_data));\n            assert!(!interpreter.finished_processing());\n        }\n        assert_eq!(10, interpreter.index);\n        let enter_data = [1, 0, 40];\n        interpreter.process(\u0026enter_data).unwrap();\n        assert_eq!(interpreter.last, Some(RawDataInterpretation::Enter));\n        assert!(!interpreter.finished_processing());\n\n        let ignore_data = [1, 0, 0];\n        interpreter.process(\u0026ignore_data).unwrap();\n        assert!(interpreter.finished_processing());\n    }\n\n    #[test]\n    fn test_usb_reader_read_error() {\n        let mut dummy_device = ReadErrorHumbleUsbDevice {\n            deinitialized: false,\n        };\n        let mut usb_reader = new(dummy_device).unwrap();\n        let result = usb_reader.read();\n        assert_eq!(Err(Error::InvalidData(0)), result);\n        usb_reader.deinitialize().unwrap();\n    }\n\n    #[test]\n    fn test_debug() {\n        let mut dummy_device = ReadErrorHumbleUsbDevice {\n            deinitialized: false,\n        };\n        dummy_device.initialize().unwrap();\n        let mut usb_reader = NeuftechUsbReader::new(dummy_device).unwrap();\n        assert_eq!(\"NeuftechUsbReader\", format!(\"{:?}\", usb_reader));\n        usb_reader.deinitialize().unwrap();\n    }\n\n    struct DummyHumbleUsbDevice {\n        index: std::cell::Cell\u003cusize\u003e,\n        enter_happened: std::cell::Cell\u003cbool\u003e,\n        deinitialized: bool,\n    }\n\n    impl HumbleUsbDevice for DummyHumbleUsbDevice {\n        fn has_attached_kernel_driver(\u0026self) -\u003e Result\u003cbool, Error\u003e {\n            Ok(true)\n        }\n        fn detach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn attach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn read(\u0026self, buffer: \u0026mut [u8]) -\u003e Result\u003c(), Error\u003e {\n            let index = self.index.get();\n\n            if index \u003c 10 {\n                buffer[2] = 30;\n                self.index.set(index + 1);\n            } else {\n                let enter_happened = self.enter_happened.get();\n                if enter_happened {\n                    buffer[2] = 0;\n                } else {\n                    buffer[2] = 40;\n                    self.enter_happened.set(true);\n                }\n            }\n\n            Ok(())\n        }\n        fn claim_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn release_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_active_configuration(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_alternate_setting(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n        fn set_deinitialized(\u0026mut self) {\n            self.deinitialized = false;\n        }\n        fn deinitialized(\u0026self) -\u003e bool {\n            self.deinitialized\n        }\n    }\n\n    #[test]\n    fn test_usb_reader_successful_read() {\n        let dummy_device = DummyHumbleUsbDevice {\n            index: 0.into(),\n            enter_happened: false.into(),\n            deinitialized: false,\n        };\n        let usb_reader = NeuftechUsbReader::new(dummy_device).unwrap();\n        let result = usb_reader.read();\n\n        let expected_data: Vec\u003cu8\u003e = vec![30; 10];\n        assert_eq!(expected_data, result.unwrap().into_vec());\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[4282352,4282432],"length":1,"stats":{"Line":1},"fn_name":"new\u003crfid_reader::rusb::rusbhumbleusbdevice::RusbHumbleUsbDevice\u003crusb::context::Context\u003e\u003e"},{"line":24,"address":[4282359,4282449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":45,"coverable":47},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","rfidreader.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::keymap::{Key, KeyMap};\nuse crate::usbreader::UsbReader;\n\n/// Trait defining an [RfidReader](crate::RfidReader).\n///\n/// An [RfidReader](crate::RfidReader) will read from an USB Rfid Reader device and convert the raw data into a string but may fail reading.\n///\n/// It also makes sense to call [`deinitialize`](crate::RfidReader::deinitialize) when the RfidReader is not used anymore in order to de-initialize the\n/// used USB device. This makes sense since de-initialize may fail. However, Drop is implemented to de-initialize as well.\npub trait RfidReader: std::fmt::Debug {\n    /// Tries to read from the RfidReader.\n    ///\n    /// A String of the processed raw data is returned on success. Otherwise an error is returned.\n    /// Method is blocking, this means it will try to read data, until a valid RFID was read or an error has occurred.\n    ///\n    /// The error [`Timeout`](crate::Error::Timeout) will occur after the defined timeout expired.\n    /// One can simply call this method again, since it is not a fatal error. However as mentioned above, the call to this method\n    /// is blocking. This means when the [`Timeout`](crate::Error::Timeout) occurs, one can do something different like checking\n    /// for OS signals that may signal that the application has to be terminated.\n    fn read(\u0026self) -\u003e Result\u003cString, Error\u003e;\n    /// Tries to de-initialize the USB device of the RfidReader, which may fail.\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n}\n\nstruct GenericRfidReader\u003cK: KeyMap, U: UsbReader\u003e {\n    key_map: K,\n    usb_reader: U,\n}\n\nimpl\u003cK: KeyMap, U: UsbReader\u003e GenericRfidReader\u003cK, U\u003e {\n    fn from(key_map: K, usb_reader: U) -\u003e GenericRfidReader\u003cK, U\u003e {\n        GenericRfidReader {\n            key_map: key_map,\n            usb_reader: usb_reader,\n        }\n    }\n}\n\nimpl\u003cK: KeyMap, U: UsbReader\u003e std::fmt::Debug for GenericRfidReader\u003cK, U\u003e {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"GenericRfidReader\")\n            .field(\"keymap\", \u0026self.key_map)\n            .field(\"usbreader\", \u0026self.usb_reader)\n            .finish()\n    }\n}\n\nimpl\u003cK: KeyMap, U: UsbReader\u003e RfidReader for GenericRfidReader\u003cK, U\u003e {\n    fn read(\u0026self) -\u003e Result\u003cString, Error\u003e {\n        let raw_data = self.usb_reader.read()?;\n        let mut rfid_value = String::with_capacity(10);\n        for raw_value in raw_data.iter() {\n            let key = self.key_map.map(*raw_value);\n            if key.is_ok() {\n                let key = key.unwrap();\n                if let Key::Digit(c) = key {\n                    rfid_value.push(c)\n                }\n            }\n        }\n        Ok(rfid_value)\n    }\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.usb_reader.deinitialize()\n    }\n}\n\npub(crate) fn from\u003cK: KeyMap, U: UsbReader\u003e(key_map: K, usb_reader: U) -\u003e impl RfidReader {\n    GenericRfidReader::from(key_map, usb_reader)\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n    use crate::keymap::Key;\n\n    struct MockUsbReader;\n\n    impl UsbReader for MockUsbReader {\n        fn read(\u0026self) -\u003e Result\u003cBox\u003c[u8]\u003e, Error\u003e {\n            let data = (0..10).collect::\u003cVec\u003cu8\u003e\u003e().into_boxed_slice();\n            Ok(data)\n        }\n        fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n            Ok(())\n        }\n    }\n\n    impl std::fmt::Debug for MockUsbReader {\n        fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n            f.debug_struct(\"MockUsbReader\").finish()\n        }\n    }\n\n    struct MockKeyMap;\n    impl KeyMap for MockKeyMap {\n        fn map(\u0026self, key: u8) -\u003e Result\u003cKey, Error\u003e {\n            Ok(Key::Digit(\n                std::char::from_digit(u8::into(key), 10).unwrap(),\n            ))\n        }\n    }\n\n    impl std::fmt::Debug for MockKeyMap {\n        fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n            f.debug_struct(\"MockKeyMap\").finish()\n        }\n    }\n\n    #[test]\n    fn test_read() {\n        let usb_reader = MockUsbReader;\n        let key_map = MockKeyMap;\n        let mut rfid_reader = from(key_map, usb_reader);\n        let rfid = rfid_reader.read().unwrap();\n        assert_eq!(\"0123456789\", rfid);\n        assert_eq!(Ok(()), rfid_reader.deinitialize());\n    }\n\n    #[test]\n    fn test_debug() {\n        let usb_reader = MockUsbReader;\n        let key_map = MockKeyMap;\n        let rfid_reader = GenericRfidReader::from(key_map, usb_reader);\n        assert_eq!(\"MockKeyMap\", format!(\"{:?}\", rfid_reader.key_map));\n        assert_eq!(\n            \"GenericRfidReader { keymap: MockKeyMap, usbreader: MockUsbReader }\",\n            format!(\"{:?}\", rfid_reader)\n        );\n    }\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4261362,4260464],"length":1,"stats":{"Line":1},"fn_name":"read\u003crfid_reader::neuftech::keymap::NeuftechKeyMap,rfid_reader::neuftech::usbreader::NeuftechUsbReader\u003crfid_reader::rusb::rusbhumbleusbdevice::RusbHumbleUsbDevice\u003crusb::context::Context\u003e\u003e\u003e"},{"line":55,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4261077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[4261120,4261307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[4261305,4261241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4272618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[4272848,4272864],"length":1,"stats":{"Line":1},"fn_name":"from\u003crfid_reader::rfidreader::tests::MockKeyMap,rfid_reader::rfidreader::tests::MockUsbReader\u003e"},{"line":74,"address":[4272852,4272871],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":17,"coverable":19},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","rusb","mod.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nmod rusbhumbleusbdevice;\nmod utils;\n\npub(crate) use rusbhumbleusbdevice::open;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","rusb","rusbhumbleusbdevice.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::humbleusbdevice::HumbleUsbDevice;\nuse crate::id::{ProductId, VendorId};\nuse crate::rusb::utils::{get_device, get_readable_endpoint, EndPoint};\nuse crate::Error;\n\nuse std::time::Duration;\n\nuse rusb::{Context, DeviceHandle, UsbContext};\n\nstruct RusbHumbleUsbDevice\u003cT: UsbContext\u003e {\n    device_handle: DeviceHandle\u003cT\u003e,\n    endpoint: EndPoint,\n    timeout: Duration,\n    deinitialized: bool,\n}\n\nimpl\u003cT: UsbContext\u003e HumbleUsbDevice for RusbHumbleUsbDevice\u003cT\u003e {\n    #[cfg(not(tarpaulin_include))]\n    fn has_attached_kernel_driver(\u0026self) -\u003e Result\u003cbool, Error\u003e {\n        let result = self\n            .device_handle\n            .kernel_driver_active(self.endpoint.get_interface());\n        if result.is_ok() {\n            Ok(result.unwrap())\n        } else {\n            Err(result.unwrap_err().into())\n        }\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn detach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .detach_kernel_driver(self.endpoint.get_interface())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn attach_kernel_driver(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .attach_kernel_driver(self.endpoint.get_interface())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn read(\u0026self, buffer: \u0026mut [u8]) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .read_interrupt(self.endpoint.get_address(), buffer, self.timeout)?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn claim_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .claim_interface(self.endpoint.get_interface())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn release_interface(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .release_interface(self.endpoint.get_interface())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn set_active_configuration(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .set_active_configuration(self.endpoint.get_config())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn set_alternate_setting(\u0026mut self) -\u003e Result\u003c(), Error\u003e {\n        self.device_handle\n            .set_alternate_setting(self.endpoint.get_interface(), self.endpoint.get_setting())?;\n        Ok(())\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn set_deinitialized(\u0026mut self) {\n        self.deinitialized = false;\n    }\n    #[cfg(not(tarpaulin_include))]\n    fn deinitialized(\u0026self) -\u003e bool {\n        self.deinitialized\n    }\n}\n\nimpl\u003cT: UsbContext\u003e Drop for RusbHumbleUsbDevice\u003cT\u003e {\n    #[cfg(not(tarpaulin_include))]\n    fn drop(\u0026mut self) {\n        if !self.deinitialized() {\n            self.set_deinitialized();\n            self.deinitialize().unwrap();\n        }\n    }\n}\n\n#[cfg(not(tarpaulin_include))]\npub(crate) fn open(\n    vendor_id: VendorId,\n    product_id: ProductId,\n    timeout: Duration,\n) -\u003e Result\u003cimpl HumbleUsbDevice, Error\u003e {\n    let context = Context::new()?;\n    let (device, device_descriptor) = get_device(\u0026context, vendor_id, product_id)?;\n    let endpoint =\n        get_readable_endpoint(\u0026device, \u0026device_descriptor, rusb::TransferType::Interrupt)?;\n    let device_handle = device.open()?;\n    Ok(RusbHumbleUsbDevice {\n        device_handle,\n        endpoint,\n        timeout,\n        deinitialized: false,\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","rusb","utils.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::id::{ProductId, VendorId};\nuse rusb::{Device, DeviceDescriptor, Direction, TransferType, UsbContext};\n\n#[derive(Debug, PartialEq)]\npub(crate) struct EndPoint {\n    config: u8,\n    interface: u8,\n    setting: u8,\n    address: u8,\n}\n\nimpl EndPoint {\n    pub(crate) fn get_interface(\u0026self) -\u003e u8 {\n        self.interface\n    }\n    pub(crate) fn get_address(\u0026self) -\u003e u8 {\n        self.address\n    }\n    pub(crate) fn get_config(\u0026self) -\u003e u8 {\n        self.config\n    }\n    pub(crate) fn get_setting(\u0026self) -\u003e u8 {\n        self.setting\n    }\n}\n\npub(crate) fn get_device\u003cT: UsbContext\u003e(\n    context: \u0026T,\n    vendor_id: VendorId,\n    product_id: ProductId,\n) -\u003e Result\u003c(Device\u003cT\u003e, DeviceDescriptor), Error\u003e {\n    let devices = context.devices()?;\n    for device in devices.iter() {\n        let device_descriptor = device.device_descriptor()?;\n        if device_descriptor.vendor_id() == vendor_id.into()\n            \u0026\u0026 device_descriptor.product_id() == product_id.into()\n        {\n            return Ok((device, device_descriptor));\n        }\n    }\n    Err(Error::DeviceNotFound(vendor_id, product_id))\n}\n\npub(crate) fn get_readable_endpoint\u003cT: UsbContext\u003e(\n    device: \u0026Device\u003cT\u003e,\n    device_descriptor: \u0026DeviceDescriptor,\n    transfer_type: TransferType,\n) -\u003e Result\u003cEndPoint, Error\u003e {\n    for n in 0..device_descriptor.num_configurations() {\n        let config_description = match device.config_descriptor(n) {\n            Ok(c) =\u003e c,\n            Err(_) =\u003e continue,\n        };\n        for interface in config_description.interfaces() {\n            for interface_description in interface.descriptors() {\n                for endpoint_descriptor in interface_description.endpoint_descriptors() {\n                    if endpoint_descriptor.direction() == Direction::In\n                        \u0026\u0026 endpoint_descriptor.transfer_type() == transfer_type\n                    {\n                        return Ok(EndPoint {\n                            config: config_description.number(),\n                            interface: interface_description.interface_number(),\n                            setting: interface_description.setting_number(),\n                            address: endpoint_descriptor.address(),\n                        });\n                    }\n                }\n            }\n        }\n    }\n    Err(Error::ReadableEndPointNotFound(\n        device_descriptor.vendor_id().into(),\n        device_descriptor.product_id().into(),\n    ))\n}\n\nimpl From\u003crusb::Error\u003e for Error {\n    fn from(error: rusb::Error) -\u003e Self {\n        match error {\n            rusb::Error::Timeout =\u003e Error::Timeout,\n            rusb::Error::Access =\u003e Error::Access,\n            _ =\u003e Error::OtherUsbError(error.to_string()),\n        }\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_get_device_not_found() {\n        let context = rusb::Context::new().unwrap();\n        let device = get_device(\u0026context, VendorId::from(0), ProductId::from(0));\n        assert!(device.is_err());\n    }\n\n    #[test]\n    fn test_get_device() {\n        // readable device in my system, change these two values in your system\n        let vendor_id = VendorId::from(0x0cf3);\n        let product_id = ProductId::from(0x3005);\n\n        let context = rusb::Context::new().unwrap();\n        let device = get_device(\u0026context, vendor_id, product_id);\n\n        assert!(device.is_ok());\n    }\n\n    #[test]\n    fn test_get_readable_endpoint() {\n        let context = rusb::Context::new().unwrap();\n\n        // readable device in my system, change these two values in your system\n        let vendor_id = VendorId::from(0x0cf3);\n        let product_id = ProductId::from(0x3005);\n        let result = get_device(\u0026context, vendor_id, product_id);\n        assert!(result.is_ok());\n        let (device, device_descriptor) = result.unwrap();\n        let endpoint = get_readable_endpoint(\u0026device, \u0026device_descriptor, TransferType::Interrupt);\n        assert!(endpoint.is_ok());\n        assert_eq!(\n            EndPoint {\n                config: 1,\n                interface: 0,\n                setting: 0,\n                address: 129\n            },\n            endpoint.unwrap()\n        );\n    }\n\n    #[test]\n    fn test_get_no_readable_endpoint() {\n        let context = rusb::Context::new().unwrap();\n\n        // device in my system without readable bulk endpoint, change these two values in your system\n        let vendor_id = VendorId::from(0x058f);\n        let product_id = ProductId::from(0xa004);\n        let result = get_device(\u0026context, vendor_id, product_id);\n        assert!(result.is_ok());\n        let (device, device_descriptor) = result.unwrap();\n        let endpoint = get_readable_endpoint(\u0026device, \u0026device_descriptor, TransferType::Bulk);\n        assert_eq!(\n            Err(Error::ReadableEndPointNotFound(vendor_id, product_id)),\n            endpoint\n        );\n    }\n\n    #[test]\n    fn test_endpoint() {\n        let endpoint = EndPoint {\n            config: 0,\n            interface: 1,\n            setting: 2,\n            address: 3,\n        };\n        assert_eq!(0, endpoint.get_config());\n        assert_eq!(1, endpoint.get_interface());\n        assert_eq!(2, endpoint.get_setting());\n        assert_eq!(3, endpoint.get_address());\n    }\n\n    #[test]\n    fn test_from_rusb_error() {\n        let rusb_error = rusb::Error::Io;\n        let error = Error::from(rusb_error);\n        assert_eq!(\n            Error::OtherUsbError(String::from(\"Input/Output Error\")),\n            error\n        );\n        let rusb_error = rusb::Error::Timeout;\n        let error = Error::from(rusb_error);\n        assert_eq!(Error::Timeout, error);\n        let rusb_error = rusb::Error::Access;\n        let error = Error::from(rusb_error);\n        assert_eq!(Error::Access, error);\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[4257968,4259293],"length":1,"stats":{"Line":2},"fn_name":"get_device\u003crusb::context::Context\u003e"},{"line":37,"address":[4258002,4258155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[4258398,4259077,4258148,4258223],"length":1,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[4258657,4258520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[4258633,4258762,4258846,4258718],"length":1,"stats":{"Line":6},"fn_name":null},{"line":41,"address":[4258738,4258818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[4258876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[4259087],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[4259424,4260999],"length":1,"stats":{"Line":2},"fn_name":"get_readable_endpoint\u003crusb::context::Context\u003e"},{"line":54,"address":[4259675,4259665,4259465,4260809],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[4259667,4259783,4259706],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[4259785,4259761],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[4259809,4260220,4260010],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[4260403,4260076,4260225],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[4260408,4260624,4260259],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[4260442,4260611,4260508],"length":1,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[4260573,4260485],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[4260725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[4260629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4260652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[4260675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[4260698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[4260877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[4259646,4260822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[4260843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":38,"coverable":38},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","rfid_reader","src","usbreader.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\npub(crate) trait UsbReader: std::fmt::Debug {\n    fn read(\u0026self) -\u003e Result\u003cBox\u003c[u8]\u003e, Error\u003e;\n    fn deinitialize(\u0026mut self) -\u003e Result\u003c(), Error\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","error.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\n/// Track store errors.\n///\n/// Defines all runtime errors.\n#[derive(Debug, PartialEq)]\npub enum Error {\n    /// Load error.\n    ///\n    /// Returned when [`load`](crate::load)ing the [`TrackStore`](crate::TrackStore) did not work,\n    /// e.g. when the parsed yaml string is invalid.\n    LoadError(String),\n}\n\nimpl std::error::Error for Error {}\n\nimpl std::fmt::Display for Error {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{:?}\", self)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_display() {\n        let error = Error::LoadError(String::from(\"test\"));\n        let formatted_string = format!(\"{}\", error);\n        assert_eq!(\"LoadError(\\\"test\\\")\", formatted_string);\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","id.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse serde::{Deserialize, Serialize};\n/// The Id of a track.\n///\n/// In order to receive a [`TrackPath`](crate::TrackPath) from the [`TrackStore`](crate::TrackStore),\n/// one must must create an Id from a [`String`](std::string::String).\n#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Hash)]\npub struct Id(String);\n\nimpl From\u003cString\u003e for Id {\n    fn from(s: String) -\u003e Self {\n        Id(s)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for Id {\n    fn from(path: \u0026str) -\u003e Self {\n        Id(path.into())\n    }\n}\n\nimpl std::fmt::Display for Id {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let id = Id::from(\"01234\");\n        let formatted_id = format!(\"{}\", id);\n        assert_eq!(String::from(\"01234\"), formatted_id);\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[6458224],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":21,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":6},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","lib.rs"],"content":"//! Crate that stores paths to tracks and enables access to these paths by using ids.\n//!\n//! The [`TrackStore`](crate::TrackStore) can be [`load`](crate::load)ed from a yaml string that is a list\n//! of key value pairs.\n//! Each key is an [`Id`](crate::Id) defined by a [`String`](std::string::String).\n//! Each value is a [`TrackPath`](crate::TrackPath) defined by a [`String`](std::string::String).\n//!\n//! # Example\n//! ```rust\n//! // use crate\n//! use track_store::{load, TrackStore, Id, TrackPath};\n//!\n//! // simple key value list in the yaml string\n//! let yaml_string = \"01234: path/to/track\";\n//!\n//! // load the TrackStore from the yaml string.\n//! let track_store = load(yaml_string).unwrap();\n//!\n//! // Create an Id from a string\n//! let id = Id::from(String::from(\"01234\"));\n//!\n//! // get the track path as an Option\n//! let track_path = track_store.get_path(\u0026id);\n//! assert!(track_path.is_some());\n//! let expected_path = String::from(\"path/to/track\").into();\n//! assert_eq!(Some(\u0026expected_path), track_path);\n//!\n//! // If the Id does not exist, the returned track path is None.\n//! let id = Id::from(String::from(\"0\"));\n//! let track_path = track_store.get_path(\u0026id);\n//! assert!(track_path.is_none());\n//! ```\n#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nmod error;\nmod id;\nmod trackpath;\nmod trackstore;\n\npub use error::Error;\npub use id::Id;\npub use trackpath::TrackPath;\npub use trackstore::{load, TrackStore};\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","trackpath.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse std::fmt::Display;\n\nuse serde::{Deserialize, Serialize};\n\n/// The path of a track.\n///\n/// The [`TrackPath`](crate::TrackPath) is created from a [`String`](std::string::String) or a [`\u0026str`](std::str) and contains the path to the track.\n#[derive(Serialize, Deserialize, Debug, PartialEq)]\npub struct TrackPath(String);\n\nimpl From\u003cString\u003e for TrackPath {\n    fn from(s: String) -\u003e Self {\n        TrackPath(s)\n    }\n}\n\nimpl From\u003c\u0026str\u003e for TrackPath {\n    fn from(path: \u0026str) -\u003e Self {\n        TrackPath(path.into())\n    }\n}\n\nimpl AsRef\u003cstr\u003e for TrackPath {\n    fn as_ref(\u0026self) -\u003e \u0026str {\n        self.0.as_ref()\n    }\n}\n\nimpl Display for TrackPath {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::result::Result\u003c(), std::fmt::Error\u003e {\n        write!(f, \"{}\", self.0)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_display() {\n        let track_path = TrackPath::from(\"path\");\n        let formatted_track_path = format!(\"{}\", track_path);\n        assert_eq!(String::from(\"path\"), formatted_track_path);\n    }\n}\n","traces":[{"line":16,"address":[10940384],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":8},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","track_store","src","trackstore.rs"],"content":"#![warn(missing_docs)]\n#![warn(missing_doc_code_examples)]\n#![forbid(unsafe_code)]\n\nuse crate::error::Error;\nuse crate::id::Id;\nuse crate::trackpath::TrackPath;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// The [`TrackStore`](crate::TrackStore) trait.\n///\n/// Enables to get the [`TrackPath`](crate::TrackPath) of a track if there is a path found for the\n/// given [`Id`](crate::Id).\npub trait TrackStore {\n    /// Get the [`TrackPath`](crate::TrackPath) for the supplied [`Id`](crate::Id) or [`None`](std::option::Option::None)\n    /// if there is no path for the supplied id.\n    fn get_path(\u0026self, id: \u0026Id) -\u003e Option\u003c\u0026TrackPath\u003e;\n}\n\n/// Load a [`TrackStore`](crate::TrackStore) from the supplied yaml [String](std::string::String).\n///\n/// Returns a [`LoadError`](crate::Error::LoadError) if the store cannot be loaded. Most likely the yaml string is\n/// ill-formed.\npub fn load(yaml_string: \u0026str) -\u003e Result\u003cimpl TrackStore, Error\u003e {\n    let track_store_result: serde_yaml::Result\u003cTrackStoreImplementation\u003e =\n        serde_yaml::from_str(yaml_string);\n    match track_store_result {\n        Err(error) =\u003e Err(Error::LoadError(error.to_string())),\n        Ok(track_store) =\u003e Ok(track_store),\n    }\n}\n\n#[derive(Serialize, Deserialize)]\nstruct TrackStoreImplementation(HashMap\u003cId, TrackPath\u003e);\n\nimpl TrackStore for TrackStoreImplementation {\n    fn get_path(\u0026self, id: \u0026Id) -\u003e Option\u003c\u0026TrackPath\u003e {\n        self.0.get(id)\n    }\n}\n\n#[cfg(test)]\n#[cfg(not(tarpaulin_include))]\nmod tests {\n\n    use super::*;\n\n    #[test]\n    fn test_serialize() {\n        let mut map = HashMap::new();\n        let id = Id::from(\"1234\");\n        let path = TrackPath::from(\"path/to/track\");\n        map.insert(id, path);\n\n        let track_store = TrackStoreImplementation(map);\n        let yaml = serde_yaml::to_string(\u0026track_store).unwrap();\n        let expected_string = \"---\n\\\"1234\\\": path/to/track\";\n        assert_eq!(expected_string, yaml);\n    }\n\n    #[test]\n    fn test_deserialize() {\n        let yaml = \"1234: path/to/track\n4321: path/to/track_2\";\n        let track_store = load(yaml).unwrap();\n        let id = \"1234\".into();\n        let track_path = track_store.get_path(\u0026id);\n        assert!(track_path.is_some());\n        let expected_path = \"path/to/track\".into();\n        assert_eq!(Some(\u0026expected_path), track_path);\n\n        let id = String::from(\"4321\").into();\n        let track_path = track_store.get_path(\u0026id);\n        assert!(track_path.is_some());\n        let expected_path = String::from(\"path/to/track_2\").into();\n        assert_eq!(Some(\u0026expected_path), track_path);\n\n        let id = String::from(\"4\").into();\n        let track_path = track_store.get_path(\u0026id);\n        assert!(track_path.is_none());\n    }\n\n    #[test]\n    fn test_load_error() {\n        let yaml = \"error\";\n        let load_result = load(yaml);\n        assert!(load_result.is_err());\n        match load_result {\n            Err(error) =\u003e assert_eq!(\n                Error::LoadError(String::from(\n                    \"invalid type: string \\\"error\\\", expected a map at line 1 column 1\"\n                )),\n                error\n            ),\n            Ok(value) =\u003e assert!(false, \"Expected error found value\"),\n        }\n    }\n}\n","traces":[{"line":25,"address":[4261728,4262078],"length":1,"stats":{"Line":4},"fn_name":"load"},{"line":26,"address":[4261754],"length":1,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[4262050,4261924],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[4261931,4262052,4261777],"length":1,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[4261794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","paw","01-ED","09-Programming","10-rust","08-media-player-card-reader","usb_reader_test","src","main.rs"],"content":"extern crate rusb;\nuse std::time::Duration;\n\n#[cfg(not(tarpaulin_include))]\nfn main() {\n    for device in rusb::devices().unwrap().iter() {\n        let device_desc = device.device_descriptor().unwrap();\n\n        println!(\n            \"Bus {:03} Device {:03} ID {:04x}:{:04x}\",\n            device.bus_number(),\n            device.address(),\n            device_desc.vendor_id(),\n            device_desc.product_id()\n        );\n    }\n\n    let mut device_handle =\n        rusb::open_device_with_vid_pid(0x16c0, 0x27db).expect(\"device not found\");\n    let active_configuration = device_handle.active_configuration();\n    println!(\"Active configuraton: {:?}\", active_configuration);\n    //device_handle.reset().unwrap();\n    let mut buffer: [u8; 3] = [0; 3];\n    println!(\n        \"Has kernel driver: {:?}\",\n        device_handle.kernel_driver_active(0)\n    );\n    println!(\n        \"Detach kernel driver? {:?}\",\n        device_handle.detach_kernel_driver(0)\n    );\n    device_handle.claim_interface(0).unwrap();\n    for _ in 0..15 {\n        let read_result = device_handle.read_interrupt(0x81, \u0026mut buffer, Duration::from_secs(10));\n        if read_result.is_ok() {\n            println!(\"Read result: {:?}\", read_result);\n            println!(\"Buffer: {:?}\", buffer);\n            let value = String::from_utf8(Vec::from(buffer));\n            if value.is_ok() {\n                let value = value.unwrap();\n                println!(\"Value: {}\", value);\n            } else {\n                let error = value.unwrap_err();\n                println!(\"{:?}\", error);\n            }\n        } else {\n            println!(\n                \"Could not read from the device: {:?}\",\n                read_result.unwrap_err()\n            );\n        }\n    }\n    device_handle.attach_kernel_driver(0).unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","usr","lib","gcc","x86_64-pc-linux-gnu","10.2.0","include","emmintrin.h"],"content":"/* Copyright (C) 2003-2020 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   Under Section 7 of GPL version 3, you are granted additional\n   permissions described in the GCC Runtime Library Exception, version\n   3.1, as published by the Free Software Foundation.\n\n   You should have received a copy of the GNU General Public License and\n   a copy of the GCC Runtime Library Exception along with this program;\n   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   \u003chttp://www.gnu.org/licenses/\u003e.  */\n\n/* Implemented from the specification included in the Intel C++ Compiler\n   User Guide and Reference, version 9.0.  */\n\n#ifndef _EMMINTRIN_H_INCLUDED\n#define _EMMINTRIN_H_INCLUDED\n\n/* We need definitions from the SSE header files*/\n#include \u003cxmmintrin.h\u003e\n\n#ifndef __SSE2__\n#pragma GCC push_options\n#pragma GCC target(\"sse2\")\n#define __DISABLE_SSE2__\n#endif /* __SSE2__ */\n\n/* SSE2 */\ntypedef double __v2df __attribute__ ((__vector_size__ (16)));\ntypedef long long __v2di __attribute__ ((__vector_size__ (16)));\ntypedef unsigned long long __v2du __attribute__ ((__vector_size__ (16)));\ntypedef int __v4si __attribute__ ((__vector_size__ (16)));\ntypedef unsigned int __v4su __attribute__ ((__vector_size__ (16)));\ntypedef short __v8hi __attribute__ ((__vector_size__ (16)));\ntypedef unsigned short __v8hu __attribute__ ((__vector_size__ (16)));\ntypedef char __v16qi __attribute__ ((__vector_size__ (16)));\ntypedef signed char __v16qs __attribute__ ((__vector_size__ (16)));\ntypedef unsigned char __v16qu __attribute__ ((__vector_size__ (16)));\n\n/* The Intel API is flexible enough that we must allow aliasing with other\n   vector types, and their scalar components.  */\ntypedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));\ntypedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));\n\n/* Unaligned version of the same types.  */\ntypedef long long __m128i_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));\ntypedef double __m128d_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));\n\n/* Create a selector for use with the SHUFPD instruction.  */\n#define _MM_SHUFFLE2(fp1,fp0) \\\n (((fp1) \u003c\u003c 1) | (fp0))\n\n/* Create a vector with element 0 as F and the rest zero.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_sd (double __F)\n{\n  return __extension__ (__m128d){ __F, 0.0 };\n}\n\n/* Create a vector with both elements equal to F.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_pd (double __F)\n{\n  return __extension__ (__m128d){ __F, __F };\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_pd1 (double __F)\n{\n  return _mm_set1_pd (__F);\n}\n\n/* Create a vector with the lower value X and upper value W.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_pd (double __W, double __X)\n{\n  return __extension__ (__m128d){ __X, __W };\n}\n\n/* Create a vector with the lower value W and upper value X.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_pd (double __W, double __X)\n{\n  return __extension__ (__m128d){ __W, __X };\n}\n\n/* Create an undefined vector.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_undefined_pd (void)\n{\n  __m128d __Y = __Y;\n  return __Y;\n}\n\n/* Create a vector of zeros.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setzero_pd (void)\n{\n  return __extension__ (__m128d){ 0.0, 0.0 };\n}\n\n/* Sets the low DPFP value of A from the low value of B.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_move_sd (__m128d __A, __m128d __B)\n{\n  return __extension__ (__m128d) __builtin_shuffle ((__v2df)__A, (__v2df)__B, (__v2di){2, 1});\n}\n\n/* Load two DPFP values from P.  The address must be 16-byte aligned.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_pd (double const *__P)\n{\n  return *(__m128d *)__P;\n}\n\n/* Load two DPFP values from P.  The address need not be 16-byte aligned.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadu_pd (double const *__P)\n{\n  return *(__m128d_u *)__P;\n}\n\n/* Create a vector with all two elements equal to *P.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load1_pd (double const *__P)\n{\n  return _mm_set1_pd (*__P);\n}\n\n/* Create a vector with element 0 as *P and the rest zero.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_sd (double const *__P)\n{\n  return _mm_set_sd (*__P);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_pd1 (double const *__P)\n{\n  return _mm_load1_pd (__P);\n}\n\n/* Load two DPFP values in reverse order.  The address must be aligned.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadr_pd (double const *__P)\n{\n  __m128d __tmp = _mm_load_pd (__P);\n  return __builtin_ia32_shufpd (__tmp, __tmp, _MM_SHUFFLE2 (0,1));\n}\n\n/* Store two DPFP values.  The address must be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_pd (double *__P, __m128d __A)\n{\n  *(__m128d *)__P = __A;\n}\n\n/* Store two DPFP values.  The address need not be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeu_pd (double *__P, __m128d __A)\n{\n  *(__m128d_u *)__P = __A;\n}\n\n/* Stores the lower DPFP value.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_sd (double *__P, __m128d __A)\n{\n  *__P = ((__v2df)__A)[0];\n}\n\nextern __inline double __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_f64 (__m128d __A)\n{\n  return ((__v2df)__A)[0];\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storel_pd (double *__P, __m128d __A)\n{\n  _mm_store_sd (__P, __A);\n}\n\n/* Stores the upper DPFP value.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeh_pd (double *__P, __m128d __A)\n{\n  *__P = ((__v2df)__A)[1];\n}\n\n/* Store the lower DPFP value across two words.\n   The address must be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store1_pd (double *__P, __m128d __A)\n{\n  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, _MM_SHUFFLE2 (0,0)));\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_pd1 (double *__P, __m128d __A)\n{\n  _mm_store1_pd (__P, __A);\n}\n\n/* Store two DPFP values in reverse order.  The address must be aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storer_pd (double *__P, __m128d __A)\n{\n  _mm_store_pd (__P, __builtin_ia32_shufpd (__A, __A, _MM_SHUFFLE2 (0,1)));\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi128_si32 (__m128i __A)\n{\n  return __builtin_ia32_vec_ext_v4si ((__v4si)__A, 0);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi128_si64 (__m128i __A)\n{\n  return ((__v2di)__A)[0];\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi128_si64x (__m128i __A)\n{\n  return ((__v2di)__A)[0];\n}\n#endif\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d) ((__v2df)__A + (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_addsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d) ((__v2df)__A - (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_subsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d) ((__v2df)__A * (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_mulsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_div_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d) ((__v2df)__A / (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_div_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_divsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sqrt_pd (__m128d __A)\n{\n  return (__m128d)__builtin_ia32_sqrtpd ((__v2df)__A);\n}\n\n/* Return pair {sqrt (B[0]), A[1]}.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sqrt_sd (__m128d __A, __m128d __B)\n{\n  __v2df __tmp = __builtin_ia32_movsd ((__v2df)__A, (__v2df)__B);\n  return (__m128d)__builtin_ia32_sqrtsd ((__v2df)__tmp);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_minpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_minsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_maxpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_maxsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_and_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_andpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_andnot_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_andnpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_or_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_orpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_xor_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_xorpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpeqpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpltpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmple_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmplepd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpgtpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpge_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpgepd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpneq_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpneqpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnlt_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpnltpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnle_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpnlepd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpngt_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpngtpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnge_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpngepd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpord_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpordpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpunord_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpunordpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpeqsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpltsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmple_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmplesd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n\t\t\t\t\t (__v2df)\n\t\t\t\t\t __builtin_ia32_cmpltsd ((__v2df) __B,\n\t\t\t\t\t\t\t\t (__v2df)\n\t\t\t\t\t\t\t\t __A));\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpge_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n\t\t\t\t\t (__v2df)\n\t\t\t\t\t __builtin_ia32_cmplesd ((__v2df) __B,\n\t\t\t\t\t\t\t\t (__v2df)\n\t\t\t\t\t\t\t\t __A));\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpneq_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpneqsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnlt_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpnltsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnle_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpnlesd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpngt_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n\t\t\t\t\t (__v2df)\n\t\t\t\t\t __builtin_ia32_cmpnltsd ((__v2df) __B,\n\t\t\t\t\t\t\t\t  (__v2df)\n\t\t\t\t\t\t\t\t  __A));\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnge_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d) __builtin_ia32_movsd ((__v2df) __A,\n\t\t\t\t\t (__v2df)\n\t\t\t\t\t __builtin_ia32_cmpnlesd ((__v2df) __B,\n\t\t\t\t\t\t\t\t  (__v2df)\n\t\t\t\t\t\t\t\t  __A));\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpord_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpordsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpunord_sd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_cmpunordsd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comieq_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdeq ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comilt_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdlt ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comile_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdle ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comigt_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdgt ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comige_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdge ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comineq_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_comisdneq ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomieq_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdeq ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomilt_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdlt ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomile_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdle ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomigt_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdgt ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomige_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdge ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomineq_sd (__m128d __A, __m128d __B)\n{\n  return __builtin_ia32_ucomisdneq ((__v2df)__A, (__v2df)__B);\n}\n\n/* Create a vector of Qi, where i is the element number.  */\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi64x (long long __q1, long long __q0)\n{\n  return __extension__ (__m128i)(__v2di){ __q0, __q1 };\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi64 (__m64 __q1,  __m64 __q0)\n{\n  return _mm_set_epi64x ((long long)__q1, (long long)__q0);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi32 (int __q3, int __q2, int __q1, int __q0)\n{\n  return __extension__ (__m128i)(__v4si){ __q0, __q1, __q2, __q3 };\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi16 (short __q7, short __q6, short __q5, short __q4,\n\t       short __q3, short __q2, short __q1, short __q0)\n{\n  return __extension__ (__m128i)(__v8hi){\n    __q0, __q1, __q2, __q3, __q4, __q5, __q6, __q7 };\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_epi8 (char __q15, char __q14, char __q13, char __q12,\n\t      char __q11, char __q10, char __q09, char __q08,\n\t      char __q07, char __q06, char __q05, char __q04,\n\t      char __q03, char __q02, char __q01, char __q00)\n{\n  return __extension__ (__m128i)(__v16qi){\n    __q00, __q01, __q02, __q03, __q04, __q05, __q06, __q07,\n    __q08, __q09, __q10, __q11, __q12, __q13, __q14, __q15\n  };\n}\n\n/* Set all of the elements of the vector to A.  */\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi64x (long long __A)\n{\n  return _mm_set_epi64x (__A, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi64 (__m64 __A)\n{\n  return _mm_set_epi64 (__A, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi32 (int __A)\n{\n  return _mm_set_epi32 (__A, __A, __A, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi16 (short __A)\n{\n  return _mm_set_epi16 (__A, __A, __A, __A, __A, __A, __A, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_epi8 (char __A)\n{\n  return _mm_set_epi8 (__A, __A, __A, __A, __A, __A, __A, __A,\n\t\t       __A, __A, __A, __A, __A, __A, __A, __A);\n}\n\n/* Create a vector of Qi, where i is the element number.\n   The parameter order is reversed from the _mm_set_epi* functions.  */\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_epi64 (__m64 __q0, __m64 __q1)\n{\n  return _mm_set_epi64 (__q1, __q0);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_epi32 (int __q0, int __q1, int __q2, int __q3)\n{\n  return _mm_set_epi32 (__q3, __q2, __q1, __q0);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_epi16 (short __q0, short __q1, short __q2, short __q3,\n\t        short __q4, short __q5, short __q6, short __q7)\n{\n  return _mm_set_epi16 (__q7, __q6, __q5, __q4, __q3, __q2, __q1, __q0);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_epi8 (char __q00, char __q01, char __q02, char __q03,\n\t       char __q04, char __q05, char __q06, char __q07,\n\t       char __q08, char __q09, char __q10, char __q11,\n\t       char __q12, char __q13, char __q14, char __q15)\n{\n  return _mm_set_epi8 (__q15, __q14, __q13, __q12, __q11, __q10, __q09, __q08,\n\t\t       __q07, __q06, __q05, __q04, __q03, __q02, __q01, __q00);\n}\n\n/* Create a vector with element 0 as *P and the rest zero.  */\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_si128 (__m128i const *__P)\n{\n  return *__P;\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadu_si128 (__m128i_u const *__P)\n{\n  return *__P;\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadl_epi64 (__m128i_u const *__P)\n{\n  return _mm_set_epi64 ((__m64)0LL, *(__m64_u *)__P);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadu_si64 (void const *__P)\n{\n  return _mm_loadl_epi64 ((__m128i_u *)__P);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_si128 (__m128i *__P, __m128i __B)\n{\n  *__P = __B;\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeu_si128 (__m128i_u *__P, __m128i __B)\n{\n  *__P = __B;\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storel_epi64 (__m128i_u *__P, __m128i __B)\n{\n  *(__m64_u *)__P = (__m64) ((__v2di)__B)[0];\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeu_si64 (void *__P, __m128i __B)\n{\n  _mm_storel_epi64 ((__m128i_u *)__P, __B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movepi64_pi64 (__m128i __B)\n{\n  return (__m64) ((__v2di)__B)[0];\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movpi64_epi64 (__m64 __A)\n{\n  return _mm_set_epi64 ((__m64)0LL, __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_move_epi64 (__m128i __A)\n{\n  return (__m128i)__builtin_ia32_movq128 ((__v2di) __A);\n}\n\n/* Create an undefined vector.  */\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_undefined_si128 (void)\n{\n  __m128i __Y = __Y;\n  return __Y;\n}\n\n/* Create a vector of zeros.  */\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setzero_si128 (void)\n{\n  return __extension__ (__m128i)(__v4si){ 0, 0, 0, 0 };\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtepi32_pd (__m128i __A)\n{\n  return (__m128d)__builtin_ia32_cvtdq2pd ((__v4si) __A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtepi32_ps (__m128i __A)\n{\n  return (__m128)__builtin_ia32_cvtdq2ps ((__v4si) __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpd_epi32 (__m128d __A)\n{\n  return (__m128i)__builtin_ia32_cvtpd2dq ((__v2df) __A);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpd_pi32 (__m128d __A)\n{\n  return (__m64)__builtin_ia32_cvtpd2pi ((__v2df) __A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpd_ps (__m128d __A)\n{\n  return (__m128)__builtin_ia32_cvtpd2ps ((__v2df) __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttpd_epi32 (__m128d __A)\n{\n  return (__m128i)__builtin_ia32_cvttpd2dq ((__v2df) __A);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttpd_pi32 (__m128d __A)\n{\n  return (__m64)__builtin_ia32_cvttpd2pi ((__v2df) __A);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi32_pd (__m64 __A)\n{\n  return (__m128d)__builtin_ia32_cvtpi2pd ((__v2si) __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_epi32 (__m128 __A)\n{\n  return (__m128i)__builtin_ia32_cvtps2dq ((__v4sf) __A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttps_epi32 (__m128 __A)\n{\n  return (__m128i)__builtin_ia32_cvttps2dq ((__v4sf) __A);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_pd (__m128 __A)\n{\n  return (__m128d)__builtin_ia32_cvtps2pd ((__v4sf) __A);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_si32 (__m128d __A)\n{\n  return __builtin_ia32_cvtsd2si ((__v2df) __A);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_si64 (__m128d __A)\n{\n  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_si64x (__m128d __A)\n{\n  return __builtin_ia32_cvtsd2si64 ((__v2df) __A);\n}\n#endif\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttsd_si32 (__m128d __A)\n{\n  return __builtin_ia32_cvttsd2si ((__v2df) __A);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttsd_si64 (__m128d __A)\n{\n  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttsd_si64x (__m128d __A)\n{\n  return __builtin_ia32_cvttsd2si64 ((__v2df) __A);\n}\n#endif\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsd_ss (__m128 __A, __m128d __B)\n{\n  return (__m128)__builtin_ia32_cvtsd2ss ((__v4sf) __A, (__v2df) __B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi32_sd (__m128d __A, int __B)\n{\n  return (__m128d)__builtin_ia32_cvtsi2sd ((__v2df) __A, __B);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64_sd (__m128d __A, long long __B)\n{\n  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64x_sd (__m128d __A, long long __B)\n{\n  return (__m128d)__builtin_ia32_cvtsi642sd ((__v2df) __A, __B);\n}\n#endif\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_sd (__m128d __A, __m128 __B)\n{\n  return (__m128d)__builtin_ia32_cvtss2sd ((__v2df) __A, (__v4sf)__B);\n}\n\n#ifdef __OPTIMIZE__\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_pd(__m128d __A, __m128d __B, const int __mask)\n{\n  return (__m128d)__builtin_ia32_shufpd ((__v2df)__A, (__v2df)__B, __mask);\n}\n#else\n#define _mm_shuffle_pd(A, B, N)\t\t\t\t\t\t\\\n  ((__m128d)__builtin_ia32_shufpd ((__v2df)(__m128d)(A),\t\t\\\n\t\t\t\t   (__v2df)(__m128d)(B), (int)(N)))\n#endif\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_unpckhpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_pd (__m128d __A, __m128d __B)\n{\n  return (__m128d)__builtin_ia32_unpcklpd ((__v2df)__A, (__v2df)__B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadh_pd (__m128d __A, double const *__B)\n{\n  return (__m128d)__builtin_ia32_loadhpd ((__v2df)__A, __B);\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadl_pd (__m128d __A, double const *__B)\n{\n  return (__m128d)__builtin_ia32_loadlpd ((__v2df)__A, __B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movemask_pd (__m128d __A)\n{\n  return __builtin_ia32_movmskpd ((__v2df)__A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_packs_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_packsswb128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_packs_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_packssdw128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_packus_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_packuswb128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckhbw128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckhwd128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckhdq128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckhqdq128 ((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpcklbw128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpcklwd128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpckldq128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_punpcklqdq128 ((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qu)__A + (__v16qu)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hu)__A + (__v8hu)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4su)__A + (__v4su)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A + (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_adds_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_paddsb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_adds_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_paddsw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_adds_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_paddusb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_adds_epu16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_paddusw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qu)__A - (__v16qu)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hu)__A - (__v8hu)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4su)__A - (__v4su)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A - (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_subs_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psubsb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_subs_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psubsw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_subs_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psubusb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_subs_epu16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psubusw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_madd_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmaddwd128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mulhi_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmulhw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mullo_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hu)__A * (__v8hu)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_su32 (__m64 __A, __m64 __B)\n{\n  return (__m64)__builtin_ia32_pmuludq ((__v2si)__A, (__v2si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_epu32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmuludq128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_slli_epi16 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psllwi128 ((__v8hi)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_slli_epi32 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_pslldi128 ((__v4si)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_slli_epi64 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psllqi128 ((__v2di)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srai_epi16 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psrawi128 ((__v8hi)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srai_epi32 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psradi128 ((__v4si)__A, __B);\n}\n\n#ifdef __OPTIMIZE__\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_bsrli_si128 (__m128i __A, const int __N)\n{\n  return (__m128i)__builtin_ia32_psrldqi128 (__A, __N * 8);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_bslli_si128 (__m128i __A, const int __N)\n{\n  return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srli_si128 (__m128i __A, const int __N)\n{\n  return (__m128i)__builtin_ia32_psrldqi128 (__A, __N * 8);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_slli_si128 (__m128i __A, const int __N)\n{\n  return (__m128i)__builtin_ia32_pslldqi128 (__A, __N * 8);\n}\n#else\n#define _mm_bsrli_si128(A, N) \\\n  ((__m128i)__builtin_ia32_psrldqi128 ((__m128i)(A), (int)(N) * 8))\n#define _mm_bslli_si128(A, N) \\\n  ((__m128i)__builtin_ia32_pslldqi128 ((__m128i)(A), (int)(N) * 8))\n#define _mm_srli_si128(A, N) \\\n  ((__m128i)__builtin_ia32_psrldqi128 ((__m128i)(A), (int)(N) * 8))\n#define _mm_slli_si128(A, N) \\\n  ((__m128i)__builtin_ia32_pslldqi128 ((__m128i)(A), (int)(N) * 8))\n#endif\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srli_epi16 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psrlwi128 ((__v8hi)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srli_epi32 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psrldi128 ((__v4si)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srli_epi64 (__m128i __A, int __B)\n{\n  return (__m128i)__builtin_ia32_psrlqi128 ((__v2di)__A, __B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sll_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psllw128((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sll_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pslld128((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sll_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psllq128((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sra_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psraw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sra_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psrad128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srl_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psrlw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srl_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psrld128 ((__v4si)__A, (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_srl_epi64 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psrlq128 ((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_and_si128 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A \u0026 (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_andnot_si128 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pandn128 ((__v2di)__A, (__v2di)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_or_si128 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A | (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_xor_si128 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v2du)__A ^ (__v2du)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qi)__A == (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hi)__A == (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4si)__A == (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qs)__A \u003c (__v16qs)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hi)__A \u003c (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4si)__A \u003c (__v4si)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_epi8 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v16qs)__A \u003e (__v16qs)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v8hi)__A \u003e (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_epi32 (__m128i __A, __m128i __B)\n{\n  return (__m128i) ((__v4si)__A \u003e (__v4si)__B);\n}\n\n#ifdef __OPTIMIZE__\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_extract_epi16 (__m128i const __A, int const __N)\n{\n  return (unsigned short) __builtin_ia32_vec_ext_v8hi ((__v8hi)__A, __N);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_insert_epi16 (__m128i const __A, int const __D, int const __N)\n{\n  return (__m128i) __builtin_ia32_vec_set_v8hi ((__v8hi)__A, __D, __N);\n}\n#else\n#define _mm_extract_epi16(A, N) \\\n  ((int) (unsigned short) __builtin_ia32_vec_ext_v8hi ((__v8hi)(__m128i)(A), (int)(N)))\n#define _mm_insert_epi16(A, D, N)\t\t\t\t\\\n  ((__m128i) __builtin_ia32_vec_set_v8hi ((__v8hi)(__m128i)(A),\t\\\n\t\t\t\t\t  (int)(D), (int)(N)))\n#endif\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmaxsw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmaxub128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_epi16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pminsw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pminub128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movemask_epi8 (__m128i __A)\n{\n  return __builtin_ia32_pmovmskb128 ((__v16qi)__A);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mulhi_epu16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pmulhuw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\n#ifdef __OPTIMIZE__\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shufflehi_epi16 (__m128i __A, const int __mask)\n{\n  return (__m128i)__builtin_ia32_pshufhw ((__v8hi)__A, __mask);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shufflelo_epi16 (__m128i __A, const int __mask)\n{\n  return (__m128i)__builtin_ia32_pshuflw ((__v8hi)__A, __mask);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_epi32 (__m128i __A, const int __mask)\n{\n  return (__m128i)__builtin_ia32_pshufd ((__v4si)__A, __mask);\n}\n#else\n#define _mm_shufflehi_epi16(A, N) \\\n  ((__m128i)__builtin_ia32_pshufhw ((__v8hi)(__m128i)(A), (int)(N)))\n#define _mm_shufflelo_epi16(A, N) \\\n  ((__m128i)__builtin_ia32_pshuflw ((__v8hi)(__m128i)(A), (int)(N)))\n#define _mm_shuffle_epi32(A, N) \\\n  ((__m128i)__builtin_ia32_pshufd ((__v4si)(__m128i)(A), (int)(N)))\n#endif\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_maskmoveu_si128 (__m128i __A, __m128i __B, char *__C)\n{\n  __builtin_ia32_maskmovdqu ((__v16qi)__A, (__v16qi)__B, __C);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_avg_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pavgb128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_avg_epu16 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_pavgw128 ((__v8hi)__A, (__v8hi)__B);\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sad_epu8 (__m128i __A, __m128i __B)\n{\n  return (__m128i)__builtin_ia32_psadbw128 ((__v16qi)__A, (__v16qi)__B);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_si32 (int *__A, int __B)\n{\n  __builtin_ia32_movnti (__A, __B);\n}\n\n#ifdef __x86_64__\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_si64 (long long int *__A, long long int __B)\n{\n  __builtin_ia32_movnti64 (__A, __B);\n}\n#endif\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_si128 (__m128i *__A, __m128i __B)\n{\n  __builtin_ia32_movntdq ((__v2di *)__A, (__v2di)__B);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_pd (double *__A, __m128d __B)\n{\n  __builtin_ia32_movntpd (__A, (__v2df)__B);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_clflush (void const *__A)\n{\n  __builtin_ia32_clflush (__A);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_lfence (void)\n{\n  __builtin_ia32_lfence ();\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mfence (void)\n{\n  __builtin_ia32_mfence ();\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi32_si128 (int __A)\n{\n  return _mm_set_epi32 (0, 0, 0, __A);\n}\n\n#ifdef __x86_64__\n/* Intel intrinsic.  */\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64_si128 (long long __A)\n{\n  return _mm_set_epi64x (0, __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64x_si128 (long long __A)\n{\n  return _mm_set_epi64x (0, __A);\n}\n#endif\n\n/* Casts between various SP, DP, INT vector types.  Note that these do no\n   conversion of values, they just change the type.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castpd_ps(__m128d __A)\n{\n  return (__m128) __A;\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castpd_si128(__m128d __A)\n{\n  return (__m128i) __A;\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castps_pd(__m128 __A)\n{\n  return (__m128d) __A;\n}\n\nextern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castps_si128(__m128 __A)\n{\n  return (__m128i) __A;\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castsi128_ps(__m128i __A)\n{\n  return (__m128) __A;\n}\n\nextern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_castsi128_pd(__m128i __A)\n{\n  return (__m128d) __A;\n}\n\n#ifdef __DISABLE_SSE2__\n#undef __DISABLE_SSE2__\n#pragma GCC pop_options\n#endif /* __DISABLE_SSE2__ */\n\n#endif /* _EMMINTRIN_H_INCLUDED */\n","traces":[{"line":826,"address":[6106230,6106238,6106328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":970,"address":[6106370,6106350],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","usr","lib","gcc","x86_64-pc-linux-gnu","10.2.0","include","xmmintrin.h"],"content":"/* Copyright (C) 2002-2020 Free Software Foundation, Inc.\n\n   This file is part of GCC.\n\n   GCC is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; either version 3, or (at your option)\n   any later version.\n\n   GCC is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   Under Section 7 of GPL version 3, you are granted additional\n   permissions described in the GCC Runtime Library Exception, version\n   3.1, as published by the Free Software Foundation.\n\n   You should have received a copy of the GNU General Public License and\n   a copy of the GCC Runtime Library Exception along with this program;\n   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   \u003chttp://www.gnu.org/licenses/\u003e.  */\n\n/* Implemented from the specification included in the Intel C++ Compiler\n   User Guide and Reference, version 9.0.  */\n\n#ifndef _XMMINTRIN_H_INCLUDED\n#define _XMMINTRIN_H_INCLUDED\n\n/* We need type definitions from the MMX header file.  */\n#include \u003cmmintrin.h\u003e\n\n/* Get _mm_malloc () and _mm_free ().  */\n#include \u003cmm_malloc.h\u003e\n\n/* Constants for use with _mm_prefetch.  */\nenum _mm_hint\n{\n  /* _MM_HINT_ET is _MM_HINT_T with set 3rd bit.  */\n  _MM_HINT_ET0 = 7,\n  _MM_HINT_ET1 = 6,\n  _MM_HINT_T0 = 3,\n  _MM_HINT_T1 = 2,\n  _MM_HINT_T2 = 1,\n  _MM_HINT_NTA = 0\n};\n\n/* Loads one cache line from address P to a location \"closer\" to the\n   processor.  The selector I specifies the type of prefetch operation.  */\n#ifdef __OPTIMIZE__\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_prefetch (const void *__P, enum _mm_hint __I)\n{\n  __builtin_prefetch (__P, (__I \u0026 0x4) \u003e\u003e 2, __I \u0026 0x3);\n}\n#else\n#define _mm_prefetch(P, I) \\\n  __builtin_prefetch ((P), ((I \u0026 0x4) \u003e\u003e 2), (I \u0026 0x3))\n#endif\n\n#ifndef __SSE__\n#pragma GCC push_options\n#pragma GCC target(\"sse\")\n#define __DISABLE_SSE__\n#endif /* __SSE__ */\n\n/* The Intel API is flexible enough that we must allow aliasing with other\n   vector types, and their scalar components.  */\ntypedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));\n\n/* Unaligned version of the same type.  */\ntypedef float __m128_u __attribute__ ((__vector_size__ (16), __may_alias__, __aligned__ (1)));\n\n/* Internal data types for implementing the intrinsics.  */\ntypedef float __v4sf __attribute__ ((__vector_size__ (16)));\n\n/* Create a selector for use with the SHUFPS instruction.  */\n#define _MM_SHUFFLE(fp3,fp2,fp1,fp0) \\\n (((fp3) \u003c\u003c 6) | ((fp2) \u003c\u003c 4) | ((fp1) \u003c\u003c 2) | (fp0))\n\n/* Bits in the MXCSR.  */\n#define _MM_EXCEPT_MASK       0x003f\n#define _MM_EXCEPT_INVALID    0x0001\n#define _MM_EXCEPT_DENORM     0x0002\n#define _MM_EXCEPT_DIV_ZERO   0x0004\n#define _MM_EXCEPT_OVERFLOW   0x0008\n#define _MM_EXCEPT_UNDERFLOW  0x0010\n#define _MM_EXCEPT_INEXACT    0x0020\n\n#define _MM_MASK_MASK         0x1f80\n#define _MM_MASK_INVALID      0x0080\n#define _MM_MASK_DENORM       0x0100\n#define _MM_MASK_DIV_ZERO     0x0200\n#define _MM_MASK_OVERFLOW     0x0400\n#define _MM_MASK_UNDERFLOW    0x0800\n#define _MM_MASK_INEXACT      0x1000\n\n#define _MM_ROUND_MASK        0x6000\n#define _MM_ROUND_NEAREST     0x0000\n#define _MM_ROUND_DOWN        0x2000\n#define _MM_ROUND_UP          0x4000\n#define _MM_ROUND_TOWARD_ZERO 0x6000\n\n#define _MM_FLUSH_ZERO_MASK   0x8000\n#define _MM_FLUSH_ZERO_ON     0x8000\n#define _MM_FLUSH_ZERO_OFF    0x0000\n\n/* Create an undefined vector.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_undefined_ps (void)\n{\n  __m128 __Y = __Y;\n  return __Y;\n}\n\n/* Create a vector of zeros.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setzero_ps (void)\n{\n  return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };\n}\n\n/* Perform the respective operation on the lower SPFP (single-precision\n   floating-point) values of A and B; the upper three SPFP values are\n   passed through from A.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_addss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_subss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_mulss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_div_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_divss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sqrt_ss (__m128 __A)\n{\n  return (__m128) __builtin_ia32_sqrtss ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_rcp_ss (__m128 __A)\n{\n  return (__m128) __builtin_ia32_rcpss ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_rsqrt_ss (__m128 __A)\n{\n  return (__m128) __builtin_ia32_rsqrtss ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_minss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_maxss ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Perform the respective operation on the four SPFP values in A and B.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_add_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) ((__v4sf)__A + (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sub_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) ((__v4sf)__A - (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mul_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) ((__v4sf)__A * (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_div_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) ((__v4sf)__A / (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sqrt_ps (__m128 __A)\n{\n  return (__m128) __builtin_ia32_sqrtps ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_rcp_ps (__m128 __A)\n{\n  return (__m128) __builtin_ia32_rcpps ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_rsqrt_ps (__m128 __A)\n{\n  return (__m128) __builtin_ia32_rsqrtps ((__v4sf)__A);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_minps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_maxps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Perform logical bit-wise operations on 128-bit values.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_and_ps (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_andps (__A, __B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_andnot_ps (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_andnps (__A, __B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_or_ps (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_orps (__A, __B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_xor_ps (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_xorps (__A, __B);\n}\n\n/* Perform a comparison on the lower SPFP values of A and B.  If the\n   comparison is true, place a mask of all ones in the result, otherwise a\n   mask of zeros.  The upper three SPFP values are passed through from A.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpeqss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpltss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmple_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpless ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n\t\t\t\t\t(__v4sf)\n\t\t\t\t\t__builtin_ia32_cmpltss ((__v4sf) __B,\n\t\t\t\t\t\t\t\t(__v4sf)\n\t\t\t\t\t\t\t\t__A));\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpge_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n\t\t\t\t\t(__v4sf)\n\t\t\t\t\t__builtin_ia32_cmpless ((__v4sf) __B,\n\t\t\t\t\t\t\t\t(__v4sf)\n\t\t\t\t\t\t\t\t__A));\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpneq_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpneqss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnlt_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpnltss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnle_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpnless ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpngt_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n\t\t\t\t\t(__v4sf)\n\t\t\t\t\t__builtin_ia32_cmpnltss ((__v4sf) __B,\n\t\t\t\t\t\t\t\t (__v4sf)\n\t\t\t\t\t\t\t\t __A));\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnge_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movss ((__v4sf) __A,\n\t\t\t\t\t(__v4sf)\n\t\t\t\t\t__builtin_ia32_cmpnless ((__v4sf) __B,\n\t\t\t\t\t\t\t\t (__v4sf)\n\t\t\t\t\t\t\t\t __A));\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpord_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpordss ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpunord_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpunordss ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Perform a comparison on the four SPFP values of A and B.  For each\n   element, if the comparison is true, place a mask of all ones in the\n   result, otherwise a mask of zeros.  */\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpeq_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpeqps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmplt_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpltps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmple_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpleps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpgt_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpgtps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpge_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpgeps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpneq_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpneqps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnlt_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpnltps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnle_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpnleps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpngt_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpngtps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpnge_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpngeps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpord_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpordps ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cmpunord_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_cmpunordps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Compare the lower SPFP values of A and B and return 1 if true\n   and 0 if false.  */\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comieq_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comieq ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comilt_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comilt ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comile_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comile ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comigt_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comigt ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comige_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comige ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_comineq_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_comineq ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomieq_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomieq ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomilt_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomilt ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomile_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomile ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomigt_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomigt ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomige_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomige ((__v4sf)__A, (__v4sf)__B);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_ucomineq_ss (__m128 __A, __m128 __B)\n{\n  return __builtin_ia32_ucomineq ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Convert the lower SPFP value to a 32-bit integer according to the current\n   rounding mode.  */\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_si32 (__m128 __A)\n{\n  return __builtin_ia32_cvtss2si ((__v4sf) __A);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvt_ss2si (__m128 __A)\n{\n  return _mm_cvtss_si32 (__A);\n}\n\n#ifdef __x86_64__\n/* Convert the lower SPFP value to a 32-bit integer according to the\n   current rounding mode.  */\n\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_si64 (__m128 __A)\n{\n  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_si64x (__m128 __A)\n{\n  return __builtin_ia32_cvtss2si64 ((__v4sf) __A);\n}\n#endif\n\n/* Convert the two lower SPFP values to 32-bit integers according to the\n   current rounding mode.  Return the integers in packed form.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_pi32 (__m128 __A)\n{\n  return (__m64) __builtin_ia32_cvtps2pi ((__v4sf) __A);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvt_ps2pi (__m128 __A)\n{\n  return _mm_cvtps_pi32 (__A);\n}\n\n/* Truncate the lower SPFP value to a 32-bit integer.  */\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttss_si32 (__m128 __A)\n{\n  return __builtin_ia32_cvttss2si ((__v4sf) __A);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtt_ss2si (__m128 __A)\n{\n  return _mm_cvttss_si32 (__A);\n}\n\n#ifdef __x86_64__\n/* Truncate the lower SPFP value to a 32-bit integer.  */\n\n/* Intel intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttss_si64 (__m128 __A)\n{\n  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttss_si64x (__m128 __A)\n{\n  return __builtin_ia32_cvttss2si64 ((__v4sf) __A);\n}\n#endif\n\n/* Truncate the two lower SPFP values to 32-bit integers.  Return the\n   integers in packed form.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvttps_pi32 (__m128 __A)\n{\n  return (__m64) __builtin_ia32_cvttps2pi ((__v4sf) __A);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtt_ps2pi (__m128 __A)\n{\n  return _mm_cvttps_pi32 (__A);\n}\n\n/* Convert B to a SPFP value and insert it as element zero in A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi32_ss (__m128 __A, int __B)\n{\n  return (__m128) __builtin_ia32_cvtsi2ss ((__v4sf) __A, __B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvt_si2ss (__m128 __A, int __B)\n{\n  return _mm_cvtsi32_ss (__A, __B);\n}\n\n#ifdef __x86_64__\n/* Convert B to a SPFP value and insert it as element zero in A.  */\n\n/* Intel intrinsic.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64_ss (__m128 __A, long long __B)\n{\n  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);\n}\n\n/* Microsoft intrinsic.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtsi64x_ss (__m128 __A, long long __B)\n{\n  return (__m128) __builtin_ia32_cvtsi642ss ((__v4sf) __A, __B);\n}\n#endif\n\n/* Convert the two 32-bit values in B to SPFP form and insert them\n   as the two lower elements in A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi32_ps (__m128 __A, __m64 __B)\n{\n  return (__m128) __builtin_ia32_cvtpi2ps ((__v4sf) __A, (__v2si)__B);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvt_pi2ps (__m128 __A, __m64 __B)\n{\n  return _mm_cvtpi32_ps (__A, __B);\n}\n\n/* Convert the four signed 16-bit values in A to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi16_ps (__m64 __A)\n{\n  __v4hi __sign;\n  __v2si __hisi, __losi;\n  __v4sf __zero, __ra, __rb;\n\n  /* This comparison against zero gives us a mask that can be used to\n     fill in the missing sign bits in the unpack operations below, so\n     that we get signed values after unpacking.  */\n  __sign = __builtin_ia32_pcmpgtw ((__v4hi)0LL, (__v4hi)__A);\n\n  /* Convert the four words to doublewords.  */\n  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);\n  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);\n\n  /* Convert the doublewords to floating point two at a time.  */\n  __zero = (__v4sf) _mm_setzero_ps ();\n  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);\n  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);\n\n  return (__m128) __builtin_ia32_movlhps (__ra, __rb);\n}\n\n/* Convert the four unsigned 16-bit values in A to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpu16_ps (__m64 __A)\n{\n  __v2si __hisi, __losi;\n  __v4sf __zero, __ra, __rb;\n\n  /* Convert the four words to doublewords.  */\n  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);\n  __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, (__v4hi)0LL);\n\n  /* Convert the doublewords to floating point two at a time.  */\n  __zero = (__v4sf) _mm_setzero_ps ();\n  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);\n  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);\n\n  return (__m128) __builtin_ia32_movlhps (__ra, __rb);\n}\n\n/* Convert the low four signed 8-bit values in A to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi8_ps (__m64 __A)\n{\n  __v8qi __sign;\n\n  /* This comparison against zero gives us a mask that can be used to\n     fill in the missing sign bits in the unpack operations below, so\n     that we get signed values after unpacking.  */\n  __sign = __builtin_ia32_pcmpgtb ((__v8qi)0LL, (__v8qi)__A);\n\n  /* Convert the four low bytes to words.  */\n  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, __sign);\n\n  return _mm_cvtpi16_ps(__A);\n}\n\n/* Convert the low four unsigned 8-bit values in A to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpu8_ps(__m64 __A)\n{\n  __A = (__m64) __builtin_ia32_punpcklbw ((__v8qi)__A, (__v8qi)0LL);\n  return _mm_cvtpu16_ps(__A);\n}\n\n/* Convert the four signed 32-bit values in A and B to SPFP form.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtpi32x2_ps(__m64 __A, __m64 __B)\n{\n  __v4sf __zero = (__v4sf) _mm_setzero_ps ();\n  __v4sf __sfa = __builtin_ia32_cvtpi2ps (__zero, (__v2si)__A);\n  __v4sf __sfb = __builtin_ia32_cvtpi2ps (__sfa, (__v2si)__B);\n  return (__m128) __builtin_ia32_movlhps (__sfa, __sfb);\n}\n\n/* Convert the four SPFP values in A to four signed 16-bit integers.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_pi16(__m128 __A)\n{\n  __v4sf __hisf = (__v4sf)__A;\n  __v4sf __losf = __builtin_ia32_movhlps (__hisf, __hisf);\n  __v2si __hisi = __builtin_ia32_cvtps2pi (__hisf);\n  __v2si __losi = __builtin_ia32_cvtps2pi (__losf);\n  return (__m64) __builtin_ia32_packssdw (__hisi, __losi);\n}\n\n/* Convert the four SPFP values in A to four signed 8-bit integers.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtps_pi8(__m128 __A)\n{\n  __v4hi __tmp = (__v4hi) _mm_cvtps_pi16 (__A);\n  return (__m64) __builtin_ia32_packsswb (__tmp, (__v4hi)0LL);\n}\n\n/* Selects four specific SPFP values from A and B based on MASK.  */\n#ifdef __OPTIMIZE__\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_ps (__m128 __A, __m128 __B, int const __mask)\n{\n  return (__m128) __builtin_ia32_shufps ((__v4sf)__A, (__v4sf)__B, __mask);\n}\n#else\n#define _mm_shuffle_ps(A, B, MASK)\t\t\t\t\t\\\n  ((__m128) __builtin_ia32_shufps ((__v4sf)(__m128)(A),\t\t\t\\\n\t\t\t\t   (__v4sf)(__m128)(B), (int)(MASK)))\n#endif\n\n/* Selects and interleaves the upper two SPFP values from A and B.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpackhi_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_unpckhps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Selects and interleaves the lower two SPFP values from A and B.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_unpacklo_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_unpcklps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Sets the upper two SPFP values with 64-bits of data loaded from P;\n   the lower two values are passed through from A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadh_pi (__m128 __A, __m64 const *__P)\n{\n  return (__m128) __builtin_ia32_loadhps ((__v4sf)__A, (const __v2sf *)__P);\n}\n\n/* Stores the upper two SPFP values of A into P.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeh_pi (__m64 *__P, __m128 __A)\n{\n  __builtin_ia32_storehps ((__v2sf *)__P, (__v4sf)__A);\n}\n\n/* Moves the upper two values of B into the lower two values of A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movehl_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movhlps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Moves the lower two values of B into the upper two values of A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movelh_ps (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_ia32_movlhps ((__v4sf)__A, (__v4sf)__B);\n}\n\n/* Sets the lower two SPFP values with 64-bits of data loaded from P;\n   the upper two values are passed through from A.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadl_pi (__m128 __A, __m64 const *__P)\n{\n  return (__m128) __builtin_ia32_loadlps ((__v4sf)__A, (const __v2sf *)__P);\n}\n\n/* Stores the lower two SPFP values of A into P.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storel_pi (__m64 *__P, __m128 __A)\n{\n  __builtin_ia32_storelps ((__v2sf *)__P, (__v4sf)__A);\n}\n\n/* Creates a 4-bit mask from the most significant bits of the SPFP values.  */\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movemask_ps (__m128 __A)\n{\n  return __builtin_ia32_movmskps ((__v4sf)__A);\n}\n\n/* Return the contents of the control register.  */\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_getcsr (void)\n{\n  return __builtin_ia32_stmxcsr ();\n}\n\n/* Read exception bits from the control register.  */\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_GET_EXCEPTION_STATE (void)\n{\n  return _mm_getcsr() \u0026 _MM_EXCEPT_MASK;\n}\n\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_GET_EXCEPTION_MASK (void)\n{\n  return _mm_getcsr() \u0026 _MM_MASK_MASK;\n}\n\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_GET_ROUNDING_MODE (void)\n{\n  return _mm_getcsr() \u0026 _MM_ROUND_MASK;\n}\n\nextern __inline unsigned int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_GET_FLUSH_ZERO_MODE (void)\n{\n  return _mm_getcsr() \u0026 _MM_FLUSH_ZERO_MASK;\n}\n\n/* Set the control register to I.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setcsr (unsigned int __I)\n{\n  __builtin_ia32_ldmxcsr (__I);\n}\n\n/* Set exception bits in the control register.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_SET_EXCEPTION_STATE(unsigned int __mask)\n{\n  _mm_setcsr((_mm_getcsr() \u0026 ~_MM_EXCEPT_MASK) | __mask);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_SET_EXCEPTION_MASK (unsigned int __mask)\n{\n  _mm_setcsr((_mm_getcsr() \u0026 ~_MM_MASK_MASK) | __mask);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_SET_ROUNDING_MODE (unsigned int __mode)\n{\n  _mm_setcsr((_mm_getcsr() \u0026 ~_MM_ROUND_MASK) | __mode);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_MM_SET_FLUSH_ZERO_MODE (unsigned int __mode)\n{\n  _mm_setcsr((_mm_getcsr() \u0026 ~_MM_FLUSH_ZERO_MASK) | __mode);\n}\n\n/* Create a vector with element 0 as F and the rest zero.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_ss (float __F)\n{\n  return __extension__ (__m128)(__v4sf){ __F, 0.0f, 0.0f, 0.0f };\n}\n\n/* Create a vector with all four elements equal to F.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set1_ps (float __F)\n{\n  return __extension__ (__m128)(__v4sf){ __F, __F, __F, __F };\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_ps1 (float __F)\n{\n  return _mm_set1_ps (__F);\n}\n\n/* Create a vector with element 0 as *P and the rest zero.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_ss (float const *__P)\n{\n  return _mm_set_ss (*__P);\n}\n\n/* Create a vector with all four elements equal to *P.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load1_ps (float const *__P)\n{\n  return _mm_set1_ps (*__P);\n}\n\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_ps1 (float const *__P)\n{\n  return _mm_load1_ps (__P);\n}\n\n/* Load four SPFP values from P.  The address must be 16-byte aligned.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_load_ps (float const *__P)\n{\n  return *(__m128 *)__P;\n}\n\n/* Load four SPFP values from P.  The address need not be 16-byte aligned.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadu_ps (float const *__P)\n{\n  return *(__m128_u *)__P;\n}\n\n/* Load four SPFP values in reverse order.  The address must be aligned.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_loadr_ps (float const *__P)\n{\n  __v4sf __tmp = *(__v4sf *)__P;\n  return (__m128) __builtin_ia32_shufps (__tmp, __tmp, _MM_SHUFFLE (0,1,2,3));\n}\n\n/* Create the vector [Z Y X W].  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)\n{\n  return __extension__ (__m128)(__v4sf){ __W, __X, __Y, __Z };\n}\n\n/* Create the vector [W X Y Z].  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_setr_ps (float __Z, float __Y, float __X, float __W)\n{\n  return __extension__ (__m128)(__v4sf){ __Z, __Y, __X, __W };\n}\n\n/* Stores the lower SPFP value.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_ss (float *__P, __m128 __A)\n{\n  *__P = ((__v4sf)__A)[0];\n}\n\nextern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_cvtss_f32 (__m128 __A)\n{\n  return ((__v4sf)__A)[0];\n}\n\n/* Store four SPFP values.  The address must be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_ps (float *__P, __m128 __A)\n{\n  *(__m128 *)__P = __A;\n}\n\n/* Store four SPFP values.  The address need not be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storeu_ps (float *__P, __m128 __A)\n{\n  *(__m128_u *)__P = __A;\n}\n\n/* Store the lower SPFP value across four words.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store1_ps (float *__P, __m128 __A)\n{\n  __v4sf __va = (__v4sf)__A;\n  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,0,0,0));\n  _mm_storeu_ps (__P, __tmp);\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_store_ps1 (float *__P, __m128 __A)\n{\n  _mm_store1_ps (__P, __A);\n}\n\n/* Store four SPFP values in reverse order.  The address must be aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_storer_ps (float *__P, __m128 __A)\n{\n  __v4sf __va = (__v4sf)__A;\n  __v4sf __tmp = __builtin_ia32_shufps (__va, __va, _MM_SHUFFLE (0,1,2,3));\n  _mm_store_ps (__P, __tmp);\n}\n\n/* Sets the low SPFP value of A from the low value of B.  */\nextern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_move_ss (__m128 __A, __m128 __B)\n{\n  return (__m128) __builtin_shuffle ((__v4sf)__A, (__v4sf)__B,\n                                     __extension__\n                                     (__attribute__((__vector_size__ (16))) int)\n                                     {4,1,2,3});\n}\n\n/* Extracts one of the four words of A.  The selector N must be immediate.  */\n#ifdef __OPTIMIZE__\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_extract_pi16 (__m64 const __A, int const __N)\n{\n  return __builtin_ia32_vec_ext_v4hi ((__v4hi)__A, __N);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pextrw (__m64 const __A, int const __N)\n{\n  return _mm_extract_pi16 (__A, __N);\n}\n#else\n#define _mm_extract_pi16(A, N)\t\\\n  ((int) __builtin_ia32_vec_ext_v4hi ((__v4hi)(__m64)(A), (int)(N)))\n\n#define _m_pextrw(A, N) _mm_extract_pi16(A, N)\n#endif\n\n/* Inserts word D into one of four words of A.  The selector N must be\n   immediate.  */\n#ifdef __OPTIMIZE__\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_insert_pi16 (__m64 const __A, int const __D, int const __N)\n{\n  return (__m64) __builtin_ia32_vec_set_v4hi ((__v4hi)__A, __D, __N);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pinsrw (__m64 const __A, int const __D, int const __N)\n{\n  return _mm_insert_pi16 (__A, __D, __N);\n}\n#else\n#define _mm_insert_pi16(A, D, N)\t\t\t\t\\\n  ((__m64) __builtin_ia32_vec_set_v4hi ((__v4hi)(__m64)(A),\t\\\n\t\t\t\t\t(int)(D), (int)(N)))\n\n#define _m_pinsrw(A, D, N) _mm_insert_pi16(A, D, N)\n#endif\n\n/* Compute the element-wise maximum of signed 16-bit values.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_pi16 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pmaxsw ((__v4hi)__A, (__v4hi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pmaxsw (__m64 __A, __m64 __B)\n{\n  return _mm_max_pi16 (__A, __B);\n}\n\n/* Compute the element-wise maximum of unsigned 8-bit values.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_max_pu8 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pmaxub ((__v8qi)__A, (__v8qi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pmaxub (__m64 __A, __m64 __B)\n{\n  return _mm_max_pu8 (__A, __B);\n}\n\n/* Compute the element-wise minimum of signed 16-bit values.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_pi16 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pminsw ((__v4hi)__A, (__v4hi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pminsw (__m64 __A, __m64 __B)\n{\n  return _mm_min_pi16 (__A, __B);\n}\n\n/* Compute the element-wise minimum of unsigned 8-bit values.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_min_pu8 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pminub ((__v8qi)__A, (__v8qi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pminub (__m64 __A, __m64 __B)\n{\n  return _mm_min_pu8 (__A, __B);\n}\n\n/* Create an 8-bit mask of the signs of 8-bit values.  */\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_movemask_pi8 (__m64 __A)\n{\n  return __builtin_ia32_pmovmskb ((__v8qi)__A);\n}\n\nextern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pmovmskb (__m64 __A)\n{\n  return _mm_movemask_pi8 (__A);\n}\n\n/* Multiply four unsigned 16-bit values in A by four unsigned 16-bit values\n   in B and produce the high 16 bits of the 32-bit results.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_mulhi_pu16 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pmulhuw ((__v4hi)__A, (__v4hi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pmulhuw (__m64 __A, __m64 __B)\n{\n  return _mm_mulhi_pu16 (__A, __B);\n}\n\n/* Return a combination of the four 16-bit values in A.  The selector\n   must be an immediate.  */\n#ifdef __OPTIMIZE__\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_shuffle_pi16 (__m64 __A, int const __N)\n{\n  return (__m64) __builtin_ia32_pshufw ((__v4hi)__A, __N);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pshufw (__m64 __A, int const __N)\n{\n  return _mm_shuffle_pi16 (__A, __N);\n}\n#else\n#define _mm_shuffle_pi16(A, N) \\\n  ((__m64) __builtin_ia32_pshufw ((__v4hi)(__m64)(A), (int)(N)))\n\n#define _m_pshufw(A, N) _mm_shuffle_pi16 (A, N)\n#endif\n\n/* Conditionally store byte elements of A into P.  The high bit of each\n   byte in the selector N determines whether the corresponding byte from\n   A is stored.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)\n{\n#ifdef __MMX_WITH_SSE__\n  /* Emulate MMX maskmovq with SSE2 maskmovdqu and handle unmapped bits\n     64:127 at address __P.  */\n  typedef long long __v2di __attribute__ ((__vector_size__ (16)));\n  typedef char __v16qi __attribute__ ((__vector_size__ (16)));\n  /* Zero-extend __A and __N to 128 bits.  */\n  __v2di __A128 = __extension__ (__v2di) { ((__v1di) __A)[0], 0 };\n  __v2di __N128 = __extension__ (__v2di) { ((__v1di) __N)[0], 0 };\n\n  /* Check the alignment of __P.  */\n  __SIZE_TYPE__ offset = ((__SIZE_TYPE__) __P) \u0026 0xf;\n  if (offset)\n    {\n      /* If the misalignment of __P \u003e 8, subtract __P by 8 bytes.\n\t Otherwise, subtract __P by the misalignment.  */\n      if (offset \u003e 8)\n\toffset = 8;\n      __P = (char *) (((__SIZE_TYPE__) __P) - offset);\n\n      /* Shift __A128 and __N128 to the left by the adjustment.  */\n      switch (offset)\n\t{\n\tcase 1:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 8);\n\t  break;\n\tcase 2:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 2 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 2 * 8);\n\t  break;\n\tcase 3:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 3 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 3 * 8);\n\t  break;\n\tcase 4:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 4 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 4 * 8);\n\t  break;\n\tcase 5:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 5 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 5 * 8);\n\t  break;\n\tcase 6:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 6 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 6 * 8);\n\t  break;\n\tcase 7:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 7 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 7 * 8);\n\t  break;\n\tcase 8:\n\t  __A128 = __builtin_ia32_pslldqi128 (__A128, 8 * 8);\n\t  __N128 = __builtin_ia32_pslldqi128 (__N128, 8 * 8);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n  __builtin_ia32_maskmovdqu ((__v16qi)__A128, (__v16qi)__N128, __P);\n#else\n  __builtin_ia32_maskmovq ((__v8qi)__A, (__v8qi)__N, __P);\n#endif\n}\n\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_maskmovq (__m64 __A, __m64 __N, char *__P)\n{\n  _mm_maskmove_si64 (__A, __N, __P);\n}\n\n/* Compute the rounded averages of the unsigned 8-bit values in A and B.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_avg_pu8 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pavgb ((__v8qi)__A, (__v8qi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pavgb (__m64 __A, __m64 __B)\n{\n  return _mm_avg_pu8 (__A, __B);\n}\n\n/* Compute the rounded averages of the unsigned 16-bit values in A and B.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_avg_pu16 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_pavgw ((__v4hi)__A, (__v4hi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_pavgw (__m64 __A, __m64 __B)\n{\n  return _mm_avg_pu16 (__A, __B);\n}\n\n/* Compute the sum of the absolute differences of the unsigned 8-bit\n   values in A and B.  Return the value in the lower 16-bit word; the\n   upper words are cleared.  */\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sad_pu8 (__m64 __A, __m64 __B)\n{\n  return (__m64) __builtin_ia32_psadbw ((__v8qi)__A, (__v8qi)__B);\n}\n\nextern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_m_psadbw (__m64 __A, __m64 __B)\n{\n  return _mm_sad_pu8 (__A, __B);\n}\n\n/* Stores the data in A to the address P without polluting the caches.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_pi (__m64 *__P, __m64 __A)\n{\n  __builtin_ia32_movntq ((unsigned long long *)__P, (unsigned long long)__A);\n}\n\n/* Likewise.  The address must be 16-byte aligned.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_stream_ps (float *__P, __m128 __A)\n{\n  __builtin_ia32_movntps (__P, (__v4sf)__A);\n}\n\n/* Guarantees that every preceding store is globally visible before\n   any subsequent store.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_sfence (void)\n{\n  __builtin_ia32_sfence ();\n}\n\n/* Transpose the 4x4 matrix composed of row[0-3].  */\n#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n  __v4sf __r0 = (row0), __r1 = (row1), __r2 = (row2), __r3 = (row3);\t\\\n  __v4sf __t0 = __builtin_ia32_unpcklps (__r0, __r1);\t\t\t\\\n  __v4sf __t1 = __builtin_ia32_unpcklps (__r2, __r3);\t\t\t\\\n  __v4sf __t2 = __builtin_ia32_unpckhps (__r0, __r1);\t\t\t\\\n  __v4sf __t3 = __builtin_ia32_unpckhps (__r2, __r3);\t\t\t\\\n  (row0) = __builtin_ia32_movlhps (__t0, __t1);\t\t\t\t\\\n  (row1) = __builtin_ia32_movhlps (__t1, __t0);\t\t\t\t\\\n  (row2) = __builtin_ia32_movlhps (__t2, __t3);\t\t\t\t\\\n  (row3) = __builtin_ia32_movhlps (__t3, __t2);\t\t\t\t\\\n} while (0)\n\n/* For backward source compatibility.  */\n# include \u003cemmintrin.h\u003e\n\n#ifdef __DISABLE_SSE__\n#undef __DISABLE_SSE__\n#pragma GCC pop_options\n#endif /* __DISABLE_SSE__ */\n\n/* The execution of the next instruction is delayed by an implementation\n   specific amount of time.  The instruction does not modify the\n   architectural state.  This is after the pop_options pragma because\n   it does not require SSE support in the processor--the encoding is a\n   nop on processors that do not support it.  */\nextern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n_mm_pause (void)\n{\n  __builtin_ia32_pause ();\n}\n\n#endif /* _XMMINTRIN_H_INCLUDED */\n","traces":[{"line":186,"address":[6115763,6113997,6114845,6121367,6121885,6120331,6114978,6112898,6119295,6114192,6112143,6112800,6113310,6120002,6115108,6112702,6113547,6115380,6115630,6122592,6119813,6118865,6113143,6120849,6115893,6112604,6113390,6116004,6107283,6113094,6115219,6119484,6107742,6116165,6113467,6105197,6121556,6111614,6114422,6111934,6122074,6121038,6111565,6114077,6122403,6120520,6112996,6113791,6102650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[8997444,8997214,8996855,8996806,8995854,8995560,8994953,8994764,9002356,8995952,9004946,8995658,8994627,8996133,8995756,8995155,8985633,8997559,8995462,9005464,8990309,8996590,9003910,9002874,8990479,8987948,9004428,9001873,9003392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[6091033,6103792,6088526,6103428,6097395,6105346,6102350,6091203,6096796,6104828,6102433,6097762,6095820,6090750,6095416,6097647,6104310,6102910,6098107,6105500,6090863,6097287,6097179,6095279,6103274,6105864,6106018,6104982,6104464,6097106,6103946,6088661,6097877,6095616,6096949,6102756,6097992,6098222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[9005653,9005569,9005555,9005667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[13492928,13493026,13492942,13493040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":809,"address":[6115337,6115419,6115260,6114911,6115520,6115471,6115017,6115149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[6099019,6098459,6098565,6098967,6098808,6098697,6099068,6098885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[6128571,6128620,6119677,6127017,6120205,6127535,6121612,6120003,6130174,6122149,6128102,6126669,6127066,6130125,6121504,6129656,6122494,6122609,6121183,6129607,6122264,6129089,6121828,6129138,6122379,6119814,6128053,6122034,6121720,6126620,6127584,6121347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[6094985,6103747,6105245,6104209,6103229,6088362,6094923,6090456,6088303,6104783,6102711,6102255,6090607,6095051,6102655,6105819,6090503,6088462,6105301,6094857,6105763,6090657,6090553,6090409,6086104,6104265,6086151,6103691,6103173,6104727,6090711,6102311,6088412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[6099735,6099465,6099787,6091361,6099576,6099333,6099836,6099227,6086302,6091157,6099653,6086226,6088816,6088621,6090987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[6086316,6099593,6091378,6099853,6088635,6099670,6099752,6091174,6099804,6099244,6088833,6086240,6099482,6091004,6099350],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>